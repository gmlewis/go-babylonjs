package main

import (
	"bytes"
	"fmt"
	"go/format"
	"html/template"
	"io/ioutil"
	"log"
	"path/filepath"
	"strings"
)

const (
	prefix = "zzz_"
)

var (
	goTmpl = template.Must(template.New("source").Funcs(funcMap).Parse(source))

	funcMap = map[string]interface{}{
		"formatParents":   formatParents,
		"fromJSObject":    fromJSObject,
		"parameterGoList": parameterGoList,
		"parameterJSList": parameterJSList,
		"receiver":        receiver,
		"toLower":         toLower,
	}
)

func (c *classes) writeGo(destDir string) error {
	for k, v := range c.m {
		if strings.Contains(k, "&") {
			logf("Skipping %v", k)
			continue
		}

		var buf bytes.Buffer
		if err := goTmpl.Execute(&buf, v); err != nil {
			return fmt.Errorf("%v: template failed: %v", k, err)
		}

		filename := filepath.Join(destDir, prefix+k+".go")

		clean, err := format.Source(buf.Bytes())
		if err != nil {
			return fmt.Errorf("%v: unable to format: %v\n%v", k, err, buf.String())
		}

		logf("Writing %v...", filename)
		if err := ioutil.WriteFile(filename, clean, 0644); err != nil {
			return err
		}
	}
	return nil
}

func formatParents(parents []string) string {
	var lines []string
	for _, v := range parents {
		lines = append(lines, "*"+v)
	}
	if len(lines) == 0 {
		lines = append(lines, "p js.Value")
	}
	return strings.Join(lines, "\n")
}

func fromJSObject(parents []string) string {
	if len(parents) == 0 {
		return "p: p"
	}
	// Can only wrap first parent.
	return fmt.Sprintf("%vFromJSObject(p)", parents[0])
}

func receiver(name string) string {
	return strings.ToLower(name[0:1])
}

func toLower(s string) string {
	return strings.ToLower(s)
}

func parameterGoList(root *ClassHTML, name string) string {
	if s, ok := root.ConstructorNames[name]; ok {
		var params []string
		params = append([]string{}, s.GoParams...)

		if s.HasOpts {
			params = append(params, fmt.Sprintf("opts *%vOpts", name))
		}

		return strings.Join(params, ", ")
	}
	if s, ok := root.MethodNames[name]; ok {
		logf("parameterGoList: method: name=%v", name)
		return strings.Join(s.GoParams, ", ")
	}
	if s, ok := root.PropertyNames[name]; ok {
		logf("parameterGoList: property: name=%v", name)
		return strings.Join(s.GoParams, ", ")
	}
	log.Fatalf("parameterGoList: unknown signature: %v", name)
	return ""
}

func parameterJSList(root ClassHTML, name string) string {
	if s, ok := root.ConstructorNames[name]; ok {
		logf("parameterJSList: constructor: name=%v", name)
		return strings.Join(s.JSParams, ", ")
	}
	if s, ok := root.MethodNames[name]; ok {
		logf("parameterJSList: method: name=%v", name)
		return strings.Join(s.JSParams, ", ")
	}
	if s, ok := root.PropertyNames[name]; ok {
		logf("parameterJSList: property: name=%v", name)
		return strings.Join(s.JSParams, ", ")
	}
	log.Fatalf("parameterJSList: unknown signature: %v", name)
	return ""
}

const source = `// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// {{.Name}} represents a babylon.js {{.Name}}.
// {{.Summary}}
{{- with .Description}}
//
// {{.}}
{{- end -}}{{- with .SeeURL}}
//
// See: {{.}}
{{- end}}
type {{.Name}} struct{ {{.Parents | formatParents}} }

// JSObject returns the underlying js.Value.
func ({{.Name | receiver}} *{{.Name}}) JSObject() js.Value { return {{.Name | receiver}}.p }

// {{.Name}} returns a {{.Name}} JavaScript class.
func (ba *Babylon) {{.Name}}() *{{.Name}} {
	p := ba.ctx.Get("{{.Name}}")
	return {{.Name}}FromJSObject(p)
}

// {{.Name}}FromJSObject returns a wrapped {{.Name}} JavaScript class.
func {{.Name}}FromJSObject(p js.Value) *{{.Name}} {
	return &{{.Name}}{ {{.Parents | fromJSObject}} }
}

{{$root := .}}
{{$name := .Name}}

{{range $key, $value := .ConstructorNames}}{{if $value.HasOpts}}
// {{$key}}Opts contains optional parameters for {{$key}}.
type {{$key}}Opts struct {
{{range $opt := $value.GoOpts}}
  {{$opt}}
{{end}}
}
{{end}}{{end}}

{{range $key, $value := .ConstructorNames}}
// {{$key}} returns a new {{$name}} object.
//
// https://doc.babylonjs.com/api/classes/babylon.{{$name | toLower}}
func (ba *Babylon) {{$key}}({{$key | parameterGoList $root}}) *{{$name}} { {{if $value.HasOpts}}
if opts == nil {
opts = &{{$key}}Opts{}
}
{{end}}
	p := ba.ctx.Get("{{$name}}").New({{$key | parameterJSList $root}})
	return {{$name}}FromJSObject(p)
}
{{end}}

// TODO: methods
`

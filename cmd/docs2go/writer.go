package main

import (
	"bytes"
	"fmt"
	"go/format"
	"html/template"
	"io/ioutil"
	"path/filepath"
	"strings"
)

const (
	prefix = "zzz_"
)

var (
	goTmpl = template.Must(template.New("source").Funcs(funcMap).Parse(source))

	funcMap = map[string]interface{}{
		"formatParents": formatParents,
		"fromJSObject":  fromJSObject,
		"receiver":      receiver,
		"toLower":       toLower,
	}
)

func (c *classes) writeGo(destDir string) error {
	for k, v := range c.m {
		if strings.Contains(k, "&") {
			logf("Skipping %v", k)
			continue
		}

		var buf bytes.Buffer
		if err := goTmpl.Execute(&buf, v); err != nil {
			return err
		}

		filename := filepath.Join(destDir, prefix+k+".go")

		clean, err := format.Source(buf.Bytes())
		if err != nil {
			return fmt.Errorf("%v: unable to format: %v\n%v", k, err, buf.String())
		}

		logf("Writing %v...", filename)
		if err := ioutil.WriteFile(filename, clean, 0644); err != nil {
			return err
		}
	}
	return nil
}

func formatParents(parents []string) string {
	var lines []string
	for _, v := range parents {
		lines = append(lines, "*"+v)
	}
	return strings.Join(lines, "\n")
}

func fromJSObject(parents []string) string {
	if len(parents) == 0 {
		return "p: p"
	}
	// Can only wrap first parent.
	return fmt.Sprintf("%vFromJSObject(p)", parents[0])
}

func receiver(name string) string {
	return strings.ToLower(name[0:1])
}

func toLower(s string) string {
	return strings.ToLower(s)
}

const source = `// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// {{.Name}} represents a babylon.js {{.Name}}.
// {{.Summary}}
{{with .Description}}
//
// {{.}}
{{end -}}
{{with .SeeURL}}
//
// See: {{.}}
{{end -}}
type {{.Name}} struct{ {{.Parents | formatParents}} }

// JSObject returns the underlying js.Value.
func ({{.Name | receiver}} *{{.Name}}) JSObject() js.Value { return {{.Name | receiver}}.p }

// {{.Name}} returns a {{.Name}} JavaScript class.
func (b *Babylon) {{.Name}}() *{{.Name}} {
	p := b.ctx.Get("{{.Name}}")
	return {{.Name}}FromJSObject(p)
}

// {{.Name}}FromJSObject returns a wrapped {{.Name}} JavaScript class.
func {{.Name}}FromJSObject(p js.Value) *{{.Name}} {
	return &{{.Name}}{ {{.Parents | fromJSObject}} }
}

// New{{.Name}} returns a new {{.Name}} object.
//
// https://doc.babylonjs.com/api/classes/babylon.{{.Name | toLower}}
func (b *Babylon) New{{.Name}}(todo parameters) *{{.Name}} {
	p := b.ctx.Get("{{.Name}}").New(todo)
	return {{.Name}}FromJSObject(p)
}

// TODO: methods
`

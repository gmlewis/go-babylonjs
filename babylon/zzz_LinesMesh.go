// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// LinesMesh represents a babylon.js LinesMesh.
// Line mesh
//
// See: https://doc.babylonjs.com/babylon101/parametric_shapes
type LinesMesh struct {
	*Mesh
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (l *LinesMesh) JSObject() js.Value { return l.p }

// LinesMesh returns a LinesMesh JavaScript class.
func (ba *Babylon) LinesMesh() *LinesMesh {
	p := ba.ctx.Get("LinesMesh")
	return LinesMeshFromJSObject(p, ba.ctx)
}

// LinesMeshFromJSObject returns a wrapped LinesMesh JavaScript class.
func LinesMeshFromJSObject(p js.Value, ctx js.Value) *LinesMesh {
	return &LinesMesh{Mesh: MeshFromJSObject(p, ctx), ctx: ctx}
}

// LinesMeshArrayToJSArray returns a JavaScript Array for the wrapped array.
func LinesMeshArrayToJSArray(array []*LinesMesh) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewLinesMeshOpts contains optional parameters for NewLinesMesh.
type NewLinesMeshOpts struct {
	Scene              *Scene
	Parent             *Node
	Source             *LinesMesh
	DoNotCloneChildren *bool
	UseVertexColor     *bool
	UseVertexAlpha     *bool
}

// NewLinesMesh returns a new LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#constructor
func (ba *Babylon) NewLinesMesh(name string, opts *NewLinesMeshOpts) *LinesMesh {
	if opts == nil {
		opts = &NewLinesMeshOpts{}
	}

	args := make([]interface{}, 0, 1+6)

	args = append(args, name)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Parent == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Parent.JSObject())
	}
	if opts.Source == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Source.JSObject())
	}
	if opts.DoNotCloneChildren == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotCloneChildren)
	}
	if opts.UseVertexColor == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UseVertexColor)
	}
	if opts.UseVertexAlpha == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UseVertexAlpha)
	}

	p := ba.ctx.Get("LinesMesh").New(args...)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// LinesMeshCloneOpts contains optional parameters for LinesMesh.Clone.
type LinesMeshCloneOpts struct {
	NewParent          *Node
	DoNotCloneChildren *bool
}

// Clone calls the Clone method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#clone
func (l *LinesMesh) Clone(name string, opts *LinesMeshCloneOpts) *AbstractMesh {
	if opts == nil {
		opts = &LinesMeshCloneOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, name)

	if opts.NewParent == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.NewParent.JSObject())
	}
	if opts.DoNotCloneChildren == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotCloneChildren)
	}

	retVal := l.p.Call("clone", args...)
	return AbstractMeshFromJSObject(retVal, l.ctx)
}

// CreateInstance calls the CreateInstance method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createinstance
func (l *LinesMesh) CreateInstance(name string) *InstancedLinesMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := l.p.Call("createInstance", args...)
	return InstancedLinesMeshFromJSObject(retVal, l.ctx)
}

// LinesMeshDisposeOpts contains optional parameters for LinesMesh.Dispose.
type LinesMeshDisposeOpts struct {
	DoNotRecurse *bool
}

// Dispose calls the Dispose method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#dispose
func (l *LinesMesh) Dispose(opts *LinesMeshDisposeOpts) {
	if opts == nil {
		opts = &LinesMeshDisposeOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.DoNotRecurse == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotRecurse)
	}

	l.p.Call("dispose", args...)
}

// LinesMeshEnableEdgesRenderingOpts contains optional parameters for LinesMesh.EnableEdgesRendering.
type LinesMeshEnableEdgesRenderingOpts struct {
	Epsilon                       *float64
	CheckVerticesInsteadOfIndices *bool
}

// EnableEdgesRendering calls the EnableEdgesRendering method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#enableedgesrendering
func (l *LinesMesh) EnableEdgesRendering(opts *LinesMeshEnableEdgesRenderingOpts) *AbstractMesh {
	if opts == nil {
		opts = &LinesMeshEnableEdgesRenderingOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.Epsilon == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Epsilon)
	}
	if opts.CheckVerticesInsteadOfIndices == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CheckVerticesInsteadOfIndices)
	}

	retVal := l.p.Call("enableEdgesRendering", args...)
	return AbstractMeshFromJSObject(retVal, l.ctx)
}

// GetClassName calls the GetClassName method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#getclassname
func (l *LinesMesh) GetClassName() string {

	retVal := l.p.Call("getClassName")
	return retVal.String()
}

// IsReady calls the IsReady method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#isready
func (l *LinesMesh) IsReady() bool {

	retVal := l.p.Call("isReady")
	return retVal.Bool()
}

// Alpha returns the Alpha property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#alpha
func (l *LinesMesh) Alpha() float64 {
	retVal := l.p.Get("alpha")
	return retVal.Float()
}

// SetAlpha sets the Alpha property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#alpha
func (l *LinesMesh) SetAlpha(alpha float64) *LinesMesh {
	l.p.Set("alpha", alpha)
	return l
}

// Color returns the Color property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#color
func (l *LinesMesh) Color() *Color3 {
	retVal := l.p.Get("color")
	return Color3FromJSObject(retVal, l.ctx)
}

// SetColor sets the Color property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#color
func (l *LinesMesh) SetColor(color *Color3) *LinesMesh {
	l.p.Set("color", color.JSObject())
	return l
}

// IntersectionThreshold returns the IntersectionThreshold property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#intersectionthreshold
func (l *LinesMesh) IntersectionThreshold() float64 {
	retVal := l.p.Get("intersectionThreshold")
	return retVal.Float()
}

// SetIntersectionThreshold sets the IntersectionThreshold property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#intersectionthreshold
func (l *LinesMesh) SetIntersectionThreshold(intersectionThreshold float64) *LinesMesh {
	l.p.Set("intersectionThreshold", intersectionThreshold)
	return l
}

// UseVertexAlpha returns the UseVertexAlpha property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#usevertexalpha
func (l *LinesMesh) UseVertexAlpha() bool {
	retVal := l.p.Get("useVertexAlpha")
	return retVal.Bool()
}

// SetUseVertexAlpha sets the UseVertexAlpha property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#usevertexalpha
func (l *LinesMesh) SetUseVertexAlpha(useVertexAlpha bool) *LinesMesh {
	l.p.Set("useVertexAlpha", useVertexAlpha)
	return l
}

// UseVertexColor returns the UseVertexColor property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#usevertexcolor
func (l *LinesMesh) UseVertexColor() bool {
	retVal := l.p.Get("useVertexColor")
	return retVal.Bool()
}

// SetUseVertexColor sets the UseVertexColor property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#usevertexcolor
func (l *LinesMesh) SetUseVertexColor(useVertexColor bool) *LinesMesh {
	l.p.Set("useVertexColor", useVertexColor)
	return l
}

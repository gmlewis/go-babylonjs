// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// LinesMesh represents a babylon.js LinesMesh.
// Line mesh
//
// See: https://doc.babylonjs.com/babylon101/parametric_shapes
type LinesMesh struct {
	*Mesh
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (l *LinesMesh) JSObject() js.Value { return l.p }

// LinesMesh returns a LinesMesh JavaScript class.
func (ba *Babylon) LinesMesh() *LinesMesh {
	p := ba.ctx.Get("LinesMesh")
	return LinesMeshFromJSObject(p, ba.ctx)
}

// LinesMeshFromJSObject returns a wrapped LinesMesh JavaScript class.
func LinesMeshFromJSObject(p js.Value, ctx js.Value) *LinesMesh {
	return &LinesMesh{Mesh: MeshFromJSObject(p, ctx), ctx: ctx}
}

// LinesMeshArrayToJSArray returns a JavaScript Array for the wrapped array.
func LinesMeshArrayToJSArray(array []*LinesMesh) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewLinesMeshOpts contains optional parameters for NewLinesMesh.
type NewLinesMeshOpts struct {
	Scene              *Scene
	Parent             *Node
	Source             *LinesMesh
	DoNotCloneChildren *bool
	UseVertexColor     *bool
	UseVertexAlpha     *bool
}

// NewLinesMesh returns a new LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh
func (ba *Babylon) NewLinesMesh(name string, opts *NewLinesMeshOpts) *LinesMesh {
	if opts == nil {
		opts = &NewLinesMeshOpts{}
	}

	args := make([]interface{}, 0, 1+6)

	args = append(args, name)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Parent == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Parent.JSObject())
	}
	if opts.Source == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Source.JSObject())
	}
	if opts.DoNotCloneChildren == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotCloneChildren)
	}
	if opts.UseVertexColor == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UseVertexColor)
	}
	if opts.UseVertexAlpha == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UseVertexAlpha)
	}

	p := ba.ctx.Get("LinesMesh").New(args...)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// AddLODLevel calls the AddLODLevel method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#addlodlevel
func (l *LinesMesh) AddLODLevel(distance float64, mesh *Mesh) *Mesh {

	args := make([]interface{}, 0, 2+0)

	args = append(args, distance)
	args = append(args, mesh.JSObject())

	retVal := l.p.Call("addLODLevel", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshApplyDisplacementMapOpts contains optional parameters for LinesMesh.ApplyDisplacementMap.
type LinesMeshApplyDisplacementMapOpts struct {
	OnSuccess   *func()
	UvOffset    *Vector2
	UvScale     *Vector2
	ForceUpdate *bool
}

// ApplyDisplacementMap calls the ApplyDisplacementMap method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#applydisplacementmap
func (l *LinesMesh) ApplyDisplacementMap(url string, minHeight float64, maxHeight float64, opts *LinesMeshApplyDisplacementMapOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshApplyDisplacementMapOpts{}
	}

	args := make([]interface{}, 0, 3+4)

	args = append(args, url)
	args = append(args, minHeight)
	args = append(args, maxHeight)

	if opts.OnSuccess == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.OnSuccess)
	}
	if opts.UvOffset == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.UvOffset.JSObject())
	}
	if opts.UvScale == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.UvScale.JSObject())
	}
	if opts.ForceUpdate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceUpdate)
	}

	retVal := l.p.Call("applyDisplacementMap", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshApplyDisplacementMapFromBufferOpts contains optional parameters for LinesMesh.ApplyDisplacementMapFromBuffer.
type LinesMeshApplyDisplacementMapFromBufferOpts struct {
	UvOffset    *Vector2
	UvScale     *Vector2
	ForceUpdate *bool
}

// ApplyDisplacementMapFromBuffer calls the ApplyDisplacementMapFromBuffer method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#applydisplacementmapfrombuffer
func (l *LinesMesh) ApplyDisplacementMapFromBuffer(buffer js.Value, heightMapWidth float64, heightMapHeight float64, minHeight float64, maxHeight float64, opts *LinesMeshApplyDisplacementMapFromBufferOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshApplyDisplacementMapFromBufferOpts{}
	}

	args := make([]interface{}, 0, 5+3)

	args = append(args, buffer)
	args = append(args, heightMapWidth)
	args = append(args, heightMapHeight)
	args = append(args, minHeight)
	args = append(args, maxHeight)

	if opts.UvOffset == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.UvOffset.JSObject())
	}
	if opts.UvScale == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.UvScale.JSObject())
	}
	if opts.ForceUpdate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceUpdate)
	}

	retVal := l.p.Call("applyDisplacementMapFromBuffer", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// ApplySkeleton calls the ApplySkeleton method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#applyskeleton
func (l *LinesMesh) ApplySkeleton(skeleton *Skeleton) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, skeleton.JSObject())

	retVal := l.p.Call("applySkeleton", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// BakeCurrentTransformIntoVertices calls the BakeCurrentTransformIntoVertices method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#bakecurrenttransformintovertices
func (l *LinesMesh) BakeCurrentTransformIntoVertices() *Mesh {

	retVal := l.p.Call("bakeCurrentTransformIntoVertices")
	return MeshFromJSObject(retVal, l.ctx)
}

// BakeTransformIntoVertices calls the BakeTransformIntoVertices method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#baketransformintovertices
func (l *LinesMesh) BakeTransformIntoVertices(transform *Matrix) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, transform.JSObject())

	retVal := l.p.Call("bakeTransformIntoVertices", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// Center calls the Center method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#center
func (l *LinesMesh) Center(meshesOrMinMaxVector js.Value) *Vector3 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, meshesOrMinMaxVector)

	retVal := l.p.Call("Center", args...)
	return Vector3FromJSObject(retVal, l.ctx)
}

// CleanMatrixWeights calls the CleanMatrixWeights method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#cleanmatrixweights
func (l *LinesMesh) CleanMatrixWeights() {

	l.p.Call("cleanMatrixWeights")
}

// LinesMeshCloneOpts contains optional parameters for LinesMesh.Clone.
type LinesMeshCloneOpts struct {
	NewParent          *Node
	DoNotCloneChildren *bool
}

// Clone calls the Clone method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#clone
func (l *LinesMesh) Clone(name string, opts *LinesMeshCloneOpts) *AbstractMesh {
	if opts == nil {
		opts = &LinesMeshCloneOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, name)

	if opts.NewParent == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.NewParent.JSObject())
	}
	if opts.DoNotCloneChildren == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotCloneChildren)
	}

	retVal := l.p.Call("clone", args...)
	return AbstractMeshFromJSObject(retVal, l.ctx)
}

// ConvertToFlatShadedMesh calls the ConvertToFlatShadedMesh method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#converttoflatshadedmesh
func (l *LinesMesh) ConvertToFlatShadedMesh() *Mesh {

	retVal := l.p.Call("convertToFlatShadedMesh")
	return MeshFromJSObject(retVal, l.ctx)
}

// ConvertToUnIndexedMesh calls the ConvertToUnIndexedMesh method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#converttounindexedmesh
func (l *LinesMesh) ConvertToUnIndexedMesh() *Mesh {

	retVal := l.p.Call("convertToUnIndexedMesh")
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateBoxOpts contains optional parameters for LinesMesh.CreateBox.
type LinesMeshCreateBoxOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateBox calls the CreateBox method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createbox
func (l *LinesMesh) CreateBox(name string, size float64, opts *LinesMeshCreateBoxOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshCreateBoxOpts{}
	}

	args := make([]interface{}, 0, 2+3)

	args = append(args, name)
	args = append(args, size)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := l.p.Call("CreateBox", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateCylinderOpts contains optional parameters for LinesMesh.CreateCylinder.
type LinesMeshCreateCylinderOpts struct {
	Scene           *Scene
	Updatable       *interface{}
	SideOrientation *float64
}

// CreateCylinder calls the CreateCylinder method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createcylinder
func (l *LinesMesh) CreateCylinder(name string, height float64, diameterTop float64, diameterBottom float64, tessellation float64, subdivisions interface{}, opts *LinesMeshCreateCylinderOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshCreateCylinderOpts{}
	}

	args := make([]interface{}, 0, 6+3)

	args = append(args, name)
	args = append(args, height)
	args = append(args, diameterTop)
	args = append(args, diameterBottom)
	args = append(args, tessellation)
	args = append(args, subdivisions)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := l.p.Call("CreateCylinder", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateDashedLinesOpts contains optional parameters for LinesMesh.CreateDashedLines.
type LinesMeshCreateDashedLinesOpts struct {
	Scene     *Scene
	Updatable *bool
	Instance  *LinesMesh
}

// CreateDashedLines calls the CreateDashedLines method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createdashedlines
func (l *LinesMesh) CreateDashedLines(name string, points *Vector3, dashSize float64, gapSize float64, dashNb float64, opts *LinesMeshCreateDashedLinesOpts) *LinesMesh {
	if opts == nil {
		opts = &LinesMeshCreateDashedLinesOpts{}
	}

	args := make([]interface{}, 0, 5+3)

	args = append(args, name)
	args = append(args, points.JSObject())
	args = append(args, dashSize)
	args = append(args, gapSize)
	args = append(args, dashNb)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := l.p.Call("CreateDashedLines", args...)
	return LinesMeshFromJSObject(retVal, l.ctx)
}

// CreateDecal calls the CreateDecal method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createdecal
func (l *LinesMesh) CreateDecal(name string, sourceMesh *AbstractMesh, position *Vector3, normal *Vector3, size *Vector3, angle float64) *Mesh {

	args := make([]interface{}, 0, 6+0)

	args = append(args, name)
	args = append(args, sourceMesh.JSObject())
	args = append(args, position.JSObject())
	args = append(args, normal.JSObject())
	args = append(args, size.JSObject())
	args = append(args, angle)

	retVal := l.p.Call("CreateDecal", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateDiscOpts contains optional parameters for LinesMesh.CreateDisc.
type LinesMeshCreateDiscOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateDisc calls the CreateDisc method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createdisc
func (l *LinesMesh) CreateDisc(name string, radius float64, tessellation float64, opts *LinesMeshCreateDiscOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshCreateDiscOpts{}
	}

	args := make([]interface{}, 0, 3+3)

	args = append(args, name)
	args = append(args, radius)
	args = append(args, tessellation)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := l.p.Call("CreateDisc", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateGroundOpts contains optional parameters for LinesMesh.CreateGround.
type LinesMeshCreateGroundOpts struct {
	Scene     *Scene
	Updatable *bool
}

// CreateGround calls the CreateGround method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createground
func (l *LinesMesh) CreateGround(name string, width float64, height float64, subdivisions float64, opts *LinesMeshCreateGroundOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshCreateGroundOpts{}
	}

	args := make([]interface{}, 0, 4+2)

	args = append(args, name)
	args = append(args, width)
	args = append(args, height)
	args = append(args, subdivisions)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}

	retVal := l.p.Call("CreateGround", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateGroundFromHeightMapOpts contains optional parameters for LinesMesh.CreateGroundFromHeightMap.
type LinesMeshCreateGroundFromHeightMapOpts struct {
	Updatable   *bool
	OnReady     *func()
	AlphaFilter *float64
}

// CreateGroundFromHeightMap calls the CreateGroundFromHeightMap method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#creategroundfromheightmap
func (l *LinesMesh) CreateGroundFromHeightMap(name string, url string, width float64, height float64, subdivisions float64, minHeight float64, maxHeight float64, scene *Scene, opts *LinesMeshCreateGroundFromHeightMapOpts) *GroundMesh {
	if opts == nil {
		opts = &LinesMeshCreateGroundFromHeightMapOpts{}
	}

	args := make([]interface{}, 0, 8+3)

	args = append(args, name)
	args = append(args, url)
	args = append(args, width)
	args = append(args, height)
	args = append(args, subdivisions)
	args = append(args, minHeight)
	args = append(args, maxHeight)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.OnReady == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.OnReady)
	}
	if opts.AlphaFilter == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AlphaFilter)
	}

	retVal := l.p.Call("CreateGroundFromHeightMap", args...)
	return GroundMeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateHemisphereOpts contains optional parameters for LinesMesh.CreateHemisphere.
type LinesMeshCreateHemisphereOpts struct {
	Scene *Scene
}

// CreateHemisphere calls the CreateHemisphere method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createhemisphere
func (l *LinesMesh) CreateHemisphere(name string, segments float64, diameter float64, opts *LinesMeshCreateHemisphereOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshCreateHemisphereOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	args = append(args, name)
	args = append(args, segments)
	args = append(args, diameter)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}

	retVal := l.p.Call("CreateHemisphere", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// CreateIcoSphere calls the CreateIcoSphere method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createicosphere
func (l *LinesMesh) CreateIcoSphere(name string, options js.Value, scene *Scene) *Mesh {

	args := make([]interface{}, 0, 3+0)

	args = append(args, name)
	args = append(args, options)
	args = append(args, scene.JSObject())

	retVal := l.p.Call("CreateIcoSphere", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// CreateInstance calls the CreateInstance method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createinstance
func (l *LinesMesh) CreateInstance(name string) *InstancedLinesMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := l.p.Call("createInstance", args...)
	return InstancedLinesMeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateLatheOpts contains optional parameters for LinesMesh.CreateLathe.
type LinesMeshCreateLatheOpts struct {
	Updatable       *bool
	SideOrientation *float64
}

// CreateLathe calls the CreateLathe method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createlathe
func (l *LinesMesh) CreateLathe(name string, shape *Vector3, radius float64, tessellation float64, scene *Scene, opts *LinesMeshCreateLatheOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshCreateLatheOpts{}
	}

	args := make([]interface{}, 0, 5+2)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, radius)
	args = append(args, tessellation)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := l.p.Call("CreateLathe", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateLinesOpts contains optional parameters for LinesMesh.CreateLines.
type LinesMeshCreateLinesOpts struct {
	Scene     *Scene
	Updatable *bool
	Instance  *LinesMesh
}

// CreateLines calls the CreateLines method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createlines
func (l *LinesMesh) CreateLines(name string, points *Vector3, opts *LinesMeshCreateLinesOpts) *LinesMesh {
	if opts == nil {
		opts = &LinesMeshCreateLinesOpts{}
	}

	args := make([]interface{}, 0, 2+3)

	args = append(args, name)
	args = append(args, points.JSObject())

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := l.p.Call("CreateLines", args...)
	return LinesMeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreatePlaneOpts contains optional parameters for LinesMesh.CreatePlane.
type LinesMeshCreatePlaneOpts struct {
	Updatable       *bool
	SideOrientation *float64
}

// CreatePlane calls the CreatePlane method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createplane
func (l *LinesMesh) CreatePlane(name string, size float64, scene *Scene, opts *LinesMeshCreatePlaneOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshCreatePlaneOpts{}
	}

	args := make([]interface{}, 0, 3+2)

	args = append(args, name)
	args = append(args, size)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := l.p.Call("CreatePlane", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreatePolygonOpts contains optional parameters for LinesMesh.CreatePolygon.
type LinesMeshCreatePolygonOpts struct {
	Holes           *Vector3
	Updatable       *bool
	SideOrientation *float64
	EarcutInjection *interface{}
}

// CreatePolygon calls the CreatePolygon method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createpolygon
func (l *LinesMesh) CreatePolygon(name string, shape *Vector3, scene *Scene, opts *LinesMeshCreatePolygonOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshCreatePolygonOpts{}
	}

	args := make([]interface{}, 0, 3+4)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, scene.JSObject())

	if opts.Holes == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Holes.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.EarcutInjection == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.EarcutInjection)
	}

	retVal := l.p.Call("CreatePolygon", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// CreatePolyhedron calls the CreatePolyhedron method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createpolyhedron
func (l *LinesMesh) CreatePolyhedron(name string, options js.Value, scene *Scene) *Mesh {

	args := make([]interface{}, 0, 3+0)

	args = append(args, name)
	args = append(args, options)
	args = append(args, scene.JSObject())

	retVal := l.p.Call("CreatePolyhedron", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateRibbonOpts contains optional parameters for LinesMesh.CreateRibbon.
type LinesMeshCreateRibbonOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
	Instance        *Mesh
}

// CreateRibbon calls the CreateRibbon method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createribbon
func (l *LinesMesh) CreateRibbon(name string, pathArray *Vector3, closeArray bool, closePath bool, offset float64, opts *LinesMeshCreateRibbonOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshCreateRibbonOpts{}
	}

	args := make([]interface{}, 0, 5+4)

	args = append(args, name)
	args = append(args, pathArray.JSObject())
	args = append(args, closeArray)
	args = append(args, closePath)
	args = append(args, offset)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := l.p.Call("CreateRibbon", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateSphereOpts contains optional parameters for LinesMesh.CreateSphere.
type LinesMeshCreateSphereOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateSphere calls the CreateSphere method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createsphere
func (l *LinesMesh) CreateSphere(name string, segments float64, diameter float64, opts *LinesMeshCreateSphereOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshCreateSphereOpts{}
	}

	args := make([]interface{}, 0, 3+3)

	args = append(args, name)
	args = append(args, segments)
	args = append(args, diameter)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := l.p.Call("CreateSphere", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateTiledGroundOpts contains optional parameters for LinesMesh.CreateTiledGround.
type LinesMeshCreateTiledGroundOpts struct {
	Updatable *bool
}

// CreateTiledGround calls the CreateTiledGround method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createtiledground
func (l *LinesMesh) CreateTiledGround(name string, xmin float64, zmin float64, xmax float64, zmax float64, subdivisions js.Value, precision js.Value, scene *Scene, opts *LinesMeshCreateTiledGroundOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshCreateTiledGroundOpts{}
	}

	args := make([]interface{}, 0, 8+1)

	args = append(args, name)
	args = append(args, xmin)
	args = append(args, zmin)
	args = append(args, xmax)
	args = append(args, zmax)
	args = append(args, subdivisions)
	args = append(args, precision)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}

	retVal := l.p.Call("CreateTiledGround", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateTorusOpts contains optional parameters for LinesMesh.CreateTorus.
type LinesMeshCreateTorusOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateTorus calls the CreateTorus method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createtorus
func (l *LinesMesh) CreateTorus(name string, diameter float64, thickness float64, tessellation float64, opts *LinesMeshCreateTorusOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshCreateTorusOpts{}
	}

	args := make([]interface{}, 0, 4+3)

	args = append(args, name)
	args = append(args, diameter)
	args = append(args, thickness)
	args = append(args, tessellation)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := l.p.Call("CreateTorus", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateTorusKnotOpts contains optional parameters for LinesMesh.CreateTorusKnot.
type LinesMeshCreateTorusKnotOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateTorusKnot calls the CreateTorusKnot method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createtorusknot
func (l *LinesMesh) CreateTorusKnot(name string, radius float64, tube float64, radialSegments float64, tubularSegments float64, p float64, q float64, opts *LinesMeshCreateTorusKnotOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshCreateTorusKnotOpts{}
	}

	args := make([]interface{}, 0, 7+3)

	args = append(args, name)
	args = append(args, radius)
	args = append(args, tube)
	args = append(args, radialSegments)
	args = append(args, tubularSegments)
	args = append(args, p)
	args = append(args, q)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := l.p.Call("CreateTorusKnot", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshCreateTubeOpts contains optional parameters for LinesMesh.CreateTube.
type LinesMeshCreateTubeOpts struct {
	Updatable       *bool
	SideOrientation *float64
	Instance        *Mesh
}

// CreateTube calls the CreateTube method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#createtube
func (l *LinesMesh) CreateTube(name string, path *Vector3, radius float64, tessellation float64, radiusFunction func(), cap float64, scene *Scene, opts *LinesMeshCreateTubeOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshCreateTubeOpts{}
	}

	args := make([]interface{}, 0, 7+3)

	args = append(args, name)
	args = append(args, path.JSObject())
	args = append(args, radius)
	args = append(args, tessellation)
	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { radiusFunction(); return nil }))
	args = append(args, cap)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := l.p.Call("CreateTube", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshDisposeOpts contains optional parameters for LinesMesh.Dispose.
type LinesMeshDisposeOpts struct {
	DoNotRecurse *bool
}

// Dispose calls the Dispose method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#dispose
func (l *LinesMesh) Dispose(opts *LinesMeshDisposeOpts) {
	if opts == nil {
		opts = &LinesMeshDisposeOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.DoNotRecurse == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotRecurse)
	}

	l.p.Call("dispose", args...)
}

// LinesMeshEnableEdgesRenderingOpts contains optional parameters for LinesMesh.EnableEdgesRendering.
type LinesMeshEnableEdgesRenderingOpts struct {
	Epsilon                       *float64
	CheckVerticesInsteadOfIndices *bool
}

// EnableEdgesRendering calls the EnableEdgesRendering method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#enableedgesrendering
func (l *LinesMesh) EnableEdgesRendering(opts *LinesMeshEnableEdgesRenderingOpts) *AbstractMesh {
	if opts == nil {
		opts = &LinesMeshEnableEdgesRenderingOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.Epsilon == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Epsilon)
	}
	if opts.CheckVerticesInsteadOfIndices == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CheckVerticesInsteadOfIndices)
	}

	retVal := l.p.Call("enableEdgesRendering", args...)
	return AbstractMeshFromJSObject(retVal, l.ctx)
}

// LinesMeshExtrudePolygonOpts contains optional parameters for LinesMesh.ExtrudePolygon.
type LinesMeshExtrudePolygonOpts struct {
	Holes           *Vector3
	Updatable       *bool
	SideOrientation *float64
	EarcutInjection *interface{}
}

// ExtrudePolygon calls the ExtrudePolygon method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#extrudepolygon
func (l *LinesMesh) ExtrudePolygon(name string, shape *Vector3, depth float64, scene *Scene, opts *LinesMeshExtrudePolygonOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshExtrudePolygonOpts{}
	}

	args := make([]interface{}, 0, 4+4)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, depth)
	args = append(args, scene.JSObject())

	if opts.Holes == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Holes.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.EarcutInjection == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.EarcutInjection)
	}

	retVal := l.p.Call("ExtrudePolygon", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshExtrudeShapeOpts contains optional parameters for LinesMesh.ExtrudeShape.
type LinesMeshExtrudeShapeOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
	Instance        *Mesh
}

// ExtrudeShape calls the ExtrudeShape method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#extrudeshape
func (l *LinesMesh) ExtrudeShape(name string, shape *Vector3, path *Vector3, scale float64, rotation float64, cap float64, opts *LinesMeshExtrudeShapeOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshExtrudeShapeOpts{}
	}

	args := make([]interface{}, 0, 6+4)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, path.JSObject())
	args = append(args, scale)
	args = append(args, rotation)
	args = append(args, cap)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := l.p.Call("ExtrudeShape", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshExtrudeShapeCustomOpts contains optional parameters for LinesMesh.ExtrudeShapeCustom.
type LinesMeshExtrudeShapeCustomOpts struct {
	Updatable       *bool
	SideOrientation *float64
	Instance        *Mesh
}

// ExtrudeShapeCustom calls the ExtrudeShapeCustom method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#extrudeshapecustom
func (l *LinesMesh) ExtrudeShapeCustom(name string, shape *Vector3, path *Vector3, scaleFunction func(), rotationFunction func(), ribbonCloseArray bool, ribbonClosePath bool, cap float64, scene *Scene, opts *LinesMeshExtrudeShapeCustomOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshExtrudeShapeCustomOpts{}
	}

	args := make([]interface{}, 0, 9+3)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, path.JSObject())
	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { scaleFunction(); return nil }))
	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { rotationFunction(); return nil }))
	args = append(args, ribbonCloseArray)
	args = append(args, ribbonClosePath)
	args = append(args, cap)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := l.p.Call("ExtrudeShapeCustom", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshFlipFacesOpts contains optional parameters for LinesMesh.FlipFaces.
type LinesMeshFlipFacesOpts struct {
	FlipNormals *bool
}

// FlipFaces calls the FlipFaces method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#flipfaces
func (l *LinesMesh) FlipFaces(opts *LinesMeshFlipFacesOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshFlipFacesOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.FlipNormals == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FlipNormals)
	}

	retVal := l.p.Call("flipFaces", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// ForceSharedVertices calls the ForceSharedVertices method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#forcesharedvertices
func (l *LinesMesh) ForceSharedVertices() {

	l.p.Call("forceSharedVertices")
}

// FreezeNormals calls the FreezeNormals method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#freezenormals
func (l *LinesMesh) FreezeNormals() *Mesh {

	retVal := l.p.Call("freezeNormals")
	return MeshFromJSObject(retVal, l.ctx)
}

// GetAnimatables calls the GetAnimatables method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#getanimatables
func (l *LinesMesh) GetAnimatables() *IAnimatable {

	retVal := l.p.Call("getAnimatables")
	return IAnimatableFromJSObject(retVal, l.ctx)
}

// GetClassName calls the GetClassName method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#getclassname
func (l *LinesMesh) GetClassName() string {

	retVal := l.p.Call("getClassName")
	return retVal.String()
}

// GetEmittedParticleSystems calls the GetEmittedParticleSystems method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#getemittedparticlesystems
func (l *LinesMesh) GetEmittedParticleSystems() *IParticleSystem {

	retVal := l.p.Call("getEmittedParticleSystems")
	return IParticleSystemFromJSObject(retVal, l.ctx)
}

// GetHierarchyEmittedParticleSystems calls the GetHierarchyEmittedParticleSystems method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#gethierarchyemittedparticlesystems
func (l *LinesMesh) GetHierarchyEmittedParticleSystems() *IParticleSystem {

	retVal := l.p.Call("getHierarchyEmittedParticleSystems")
	return IParticleSystemFromJSObject(retVal, l.ctx)
}

// LinesMeshGetIndicesOpts contains optional parameters for LinesMesh.GetIndices.
type LinesMeshGetIndicesOpts struct {
	CopyWhenShared *bool
	ForceCopy      *bool
}

// GetIndices calls the GetIndices method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#getindices
func (l *LinesMesh) GetIndices(opts *LinesMeshGetIndicesOpts) js.Value {
	if opts == nil {
		opts = &LinesMeshGetIndicesOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.CopyWhenShared == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CopyWhenShared)
	}
	if opts.ForceCopy == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceCopy)
	}

	retVal := l.p.Call("getIndices", args...)
	return retVal
}

// LinesMeshGetLODOpts contains optional parameters for LinesMesh.GetLOD.
type LinesMeshGetLODOpts struct {
	BoundingSphere *BoundingSphere
}

// GetLOD calls the GetLOD method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#getlod
func (l *LinesMesh) GetLOD(camera *Camera, opts *LinesMeshGetLODOpts) *AbstractMesh {
	if opts == nil {
		opts = &LinesMeshGetLODOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, camera.JSObject())

	if opts.BoundingSphere == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.BoundingSphere.JSObject())
	}

	retVal := l.p.Call("getLOD", args...)
	return AbstractMeshFromJSObject(retVal, l.ctx)
}

// GetLODLevelAtDistance calls the GetLODLevelAtDistance method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#getlodlevelatdistance
func (l *LinesMesh) GetLODLevelAtDistance(distance float64) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, distance)

	retVal := l.p.Call("getLODLevelAtDistance", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// GetLODLevels calls the GetLODLevels method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#getlodlevels
func (l *LinesMesh) GetLODLevels() *MeshLODLevel {

	retVal := l.p.Call("getLODLevels")
	return MeshLODLevelFromJSObject(retVal, l.ctx)
}

// GetTotalIndices calls the GetTotalIndices method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#gettotalindices
func (l *LinesMesh) GetTotalIndices() float64 {

	retVal := l.p.Call("getTotalIndices")
	return retVal.Float()
}

// GetTotalVertices calls the GetTotalVertices method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#gettotalvertices
func (l *LinesMesh) GetTotalVertices() float64 {

	retVal := l.p.Call("getTotalVertices")
	return retVal.Float()
}

// GetVertexBuffer calls the GetVertexBuffer method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#getvertexbuffer
func (l *LinesMesh) GetVertexBuffer(kind string) *VertexBuffer {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	retVal := l.p.Call("getVertexBuffer", args...)
	return VertexBufferFromJSObject(retVal, l.ctx)
}

// LinesMeshGetVerticesDataOpts contains optional parameters for LinesMesh.GetVerticesData.
type LinesMeshGetVerticesDataOpts struct {
	CopyWhenShared *bool
	ForceCopy      *bool
}

// GetVerticesData calls the GetVerticesData method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#getverticesdata
func (l *LinesMesh) GetVerticesData(kind string, opts *LinesMeshGetVerticesDataOpts) js.Value {
	if opts == nil {
		opts = &LinesMeshGetVerticesDataOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, kind)

	if opts.CopyWhenShared == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CopyWhenShared)
	}
	if opts.ForceCopy == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceCopy)
	}

	retVal := l.p.Call("getVerticesData", args...)
	return retVal
}

// GetVerticesDataKinds calls the GetVerticesDataKinds method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#getverticesdatakinds
func (l *LinesMesh) GetVerticesDataKinds() string {

	retVal := l.p.Call("getVerticesDataKinds")
	return retVal.String()
}

// IncreaseVertices calls the IncreaseVertices method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#increasevertices
func (l *LinesMesh) IncreaseVertices(numberPerEdge float64) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, numberPerEdge)

	l.p.Call("increaseVertices", args...)
}

// LinesMeshInstantiateHierarchyOpts contains optional parameters for LinesMesh.InstantiateHierarchy.
type LinesMeshInstantiateHierarchyOpts struct {
	NewParent        *TransformNode
	Options          js.Value
	OnNewNodeCreated *func()
}

// InstantiateHierarchy calls the InstantiateHierarchy method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#instantiatehierarchy
func (l *LinesMesh) InstantiateHierarchy(opts *LinesMeshInstantiateHierarchyOpts) *TransformNode {
	if opts == nil {
		opts = &LinesMeshInstantiateHierarchyOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.NewParent == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.NewParent.JSObject())
	}
	if opts.Options == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Options)
	}
	if opts.OnNewNodeCreated == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.OnNewNodeCreated)
	}

	retVal := l.p.Call("instantiateHierarchy", args...)
	return TransformNodeFromJSObject(retVal, l.ctx)
}

// IsInFrustum calls the IsInFrustum method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#isinfrustum
func (l *LinesMesh) IsInFrustum(frustumPlanes *Plane) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, frustumPlanes.JSObject())

	retVal := l.p.Call("isInFrustum", args...)
	return retVal.Bool()
}

// IsReady calls the IsReady method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#isready
func (l *LinesMesh) IsReady() bool {

	retVal := l.p.Call("isReady")
	return retVal.Bool()
}

// IsVertexBufferUpdatable calls the IsVertexBufferUpdatable method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#isvertexbufferupdatable
func (l *LinesMesh) IsVertexBufferUpdatable(kind string) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	retVal := l.p.Call("isVertexBufferUpdatable", args...)
	return retVal.Bool()
}

// IsVerticesDataPresent calls the IsVerticesDataPresent method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#isverticesdatapresent
func (l *LinesMesh) IsVerticesDataPresent(kind string) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	retVal := l.p.Call("isVerticesDataPresent", args...)
	return retVal.Bool()
}

// MakeGeometryUnique calls the MakeGeometryUnique method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#makegeometryunique
func (l *LinesMesh) MakeGeometryUnique() *Mesh {

	retVal := l.p.Call("makeGeometryUnique")
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshMarkVerticesDataAsUpdatableOpts contains optional parameters for LinesMesh.MarkVerticesDataAsUpdatable.
type LinesMeshMarkVerticesDataAsUpdatableOpts struct {
	Updatable *bool
}

// MarkVerticesDataAsUpdatable calls the MarkVerticesDataAsUpdatable method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#markverticesdataasupdatable
func (l *LinesMesh) MarkVerticesDataAsUpdatable(kind string, opts *LinesMeshMarkVerticesDataAsUpdatableOpts) {
	if opts == nil {
		opts = &LinesMeshMarkVerticesDataAsUpdatableOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, kind)

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}

	l.p.Call("markVerticesDataAsUpdatable", args...)
}

// LinesMeshMergeMeshesOpts contains optional parameters for LinesMesh.MergeMeshes.
type LinesMeshMergeMeshesOpts struct {
	DisposeSource          *bool
	Allow32BitsIndices     *bool
	MeshSubclass           *Mesh
	SubdivideWithSubMeshes *bool
	MultiMultiMaterials    *bool
}

// MergeMeshes calls the MergeMeshes method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#mergemeshes
func (l *LinesMesh) MergeMeshes(meshes []*Mesh, opts *LinesMeshMergeMeshesOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshMergeMeshesOpts{}
	}

	args := make([]interface{}, 0, 1+5)

	args = append(args, MeshArrayToJSArray(meshes))

	if opts.DisposeSource == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DisposeSource)
	}
	if opts.Allow32BitsIndices == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Allow32BitsIndices)
	}
	if opts.MeshSubclass == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.MeshSubclass.JSObject())
	}
	if opts.SubdivideWithSubMeshes == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SubdivideWithSubMeshes)
	}
	if opts.MultiMultiMaterials == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MultiMultiMaterials)
	}

	retVal := l.p.Call("MergeMeshes", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// MinMax calls the MinMax method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#minmax
func (l *LinesMesh) MinMax(meshes *AbstractMesh) js.Value {

	args := make([]interface{}, 0, 1+0)

	args = append(args, meshes.JSObject())

	retVal := l.p.Call("MinMax", args...)
	return retVal
}

// LinesMeshOptimizeIndicesOpts contains optional parameters for LinesMesh.OptimizeIndices.
type LinesMeshOptimizeIndicesOpts struct {
	SuccessCallback *func()
}

// OptimizeIndices calls the OptimizeIndices method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#optimizeindices
func (l *LinesMesh) OptimizeIndices(opts *LinesMeshOptimizeIndicesOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshOptimizeIndicesOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.SuccessCallback == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.SuccessCallback)
	}

	retVal := l.p.Call("optimizeIndices", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// Parse calls the Parse method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#parse
func (l *LinesMesh) Parse(parsedMesh interface{}, scene *Scene, rootUrl string) *Mesh {

	args := make([]interface{}, 0, 3+0)

	args = append(args, parsedMesh)
	args = append(args, scene.JSObject())
	args = append(args, rootUrl)

	retVal := l.p.Call("Parse", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshRefreshBoundingInfoOpts contains optional parameters for LinesMesh.RefreshBoundingInfo.
type LinesMeshRefreshBoundingInfoOpts struct {
	ApplySkeleton *bool
}

// RefreshBoundingInfo calls the RefreshBoundingInfo method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#refreshboundinginfo
func (l *LinesMesh) RefreshBoundingInfo(opts *LinesMeshRefreshBoundingInfoOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshRefreshBoundingInfoOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.ApplySkeleton == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ApplySkeleton)
	}

	retVal := l.p.Call("refreshBoundingInfo", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// RegisterAfterRender calls the RegisterAfterRender method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#registerafterrender
func (l *LinesMesh) RegisterAfterRender(jsFunc func()) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	retVal := l.p.Call("registerAfterRender", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// RegisterBeforeRender calls the RegisterBeforeRender method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#registerbeforerender
func (l *LinesMesh) RegisterBeforeRender(jsFunc func()) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	retVal := l.p.Call("registerBeforeRender", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// RegisterInstancedBuffer calls the RegisterInstancedBuffer method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#registerinstancedbuffer
func (l *LinesMesh) RegisterInstancedBuffer(kind string, stride float64) {

	args := make([]interface{}, 0, 2+0)

	args = append(args, kind)
	args = append(args, stride)

	l.p.Call("registerInstancedBuffer", args...)
}

// RemoveLODLevel calls the RemoveLODLevel method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#removelodlevel
func (l *LinesMesh) RemoveLODLevel(mesh *Mesh) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, mesh.JSObject())

	retVal := l.p.Call("removeLODLevel", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// RemoveVerticesData calls the RemoveVerticesData method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#removeverticesdata
func (l *LinesMesh) RemoveVerticesData(kind string) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	l.p.Call("removeVerticesData", args...)
}

// LinesMeshRenderOpts contains optional parameters for LinesMesh.Render.
type LinesMeshRenderOpts struct {
	EffectiveMeshReplacement *AbstractMesh
}

// Render calls the Render method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#render
func (l *LinesMesh) Render(subMesh *SubMesh, enableAlphaMode bool, opts *LinesMeshRenderOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshRenderOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, subMesh.JSObject())
	args = append(args, enableAlphaMode)

	if opts.EffectiveMeshReplacement == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.EffectiveMeshReplacement.JSObject())
	}

	retVal := l.p.Call("render", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// Serialize calls the Serialize method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#serialize
func (l *LinesMesh) Serialize(serializationObject interface{}) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, serializationObject)

	l.p.Call("serialize", args...)
}

// LinesMeshSetIndicesOpts contains optional parameters for LinesMesh.SetIndices.
type LinesMeshSetIndicesOpts struct {
	TotalVertices *float64
	Updatable     *bool
}

// SetIndices calls the SetIndices method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#setindices
func (l *LinesMesh) SetIndices(indices js.Value, opts *LinesMeshSetIndicesOpts) *AbstractMesh {
	if opts == nil {
		opts = &LinesMeshSetIndicesOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, indices)

	if opts.TotalVertices == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.TotalVertices)
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}

	retVal := l.p.Call("setIndices", args...)
	return AbstractMeshFromJSObject(retVal, l.ctx)
}

// SetMaterialByID calls the SetMaterialByID method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#setmaterialbyid
func (l *LinesMesh) SetMaterialByID(id string) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := l.p.Call("setMaterialByID", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// SetNormalsForCPUSkinning calls the SetNormalsForCPUSkinning method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#setnormalsforcpuskinning
func (l *LinesMesh) SetNormalsForCPUSkinning() js.Value {

	retVal := l.p.Call("setNormalsForCPUSkinning")
	return retVal
}

// SetPositionsForCPUSkinning calls the SetPositionsForCPUSkinning method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#setpositionsforcpuskinning
func (l *LinesMesh) SetPositionsForCPUSkinning() js.Value {

	retVal := l.p.Call("setPositionsForCPUSkinning")
	return retVal
}

// SetVerticesBuffer calls the SetVerticesBuffer method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#setverticesbuffer
func (l *LinesMesh) SetVerticesBuffer(buffer *VertexBuffer) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, buffer.JSObject())

	retVal := l.p.Call("setVerticesBuffer", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshSetVerticesDataOpts contains optional parameters for LinesMesh.SetVerticesData.
type LinesMeshSetVerticesDataOpts struct {
	Updatable *bool
	Stride    *float64
}

// SetVerticesData calls the SetVerticesData method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#setverticesdata
func (l *LinesMesh) SetVerticesData(kind string, data js.Value, opts *LinesMeshSetVerticesDataOpts) *AbstractMesh {
	if opts == nil {
		opts = &LinesMeshSetVerticesDataOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, kind)
	args = append(args, data)

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.Stride == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Stride)
	}

	retVal := l.p.Call("setVerticesData", args...)
	return AbstractMeshFromJSObject(retVal, l.ctx)
}

// LinesMeshSimplifyOpts contains optional parameters for LinesMesh.Simplify.
type LinesMeshSimplifyOpts struct {
	ParallelProcessing *bool
	SimplificationType js.Value
	SuccessCallback    *func()
}

// Simplify calls the Simplify method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#simplify
func (l *LinesMesh) Simplify(settings []*ISimplificationSettings, opts *LinesMeshSimplifyOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshSimplifyOpts{}
	}

	args := make([]interface{}, 0, 1+3)

	args = append(args, ISimplificationSettingsArrayToJSArray(settings))

	if opts.ParallelProcessing == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ParallelProcessing)
	}
	if opts.SimplificationType == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.SimplificationType)
	}
	if opts.SuccessCallback == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.SuccessCallback)
	}

	retVal := l.p.Call("simplify", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// Subdivide calls the Subdivide method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#subdivide
func (l *LinesMesh) Subdivide(count float64) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, count)

	l.p.Call("subdivide", args...)
}

// SynchronizeInstances calls the SynchronizeInstances method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#synchronizeinstances
func (l *LinesMesh) SynchronizeInstances() *Mesh {

	retVal := l.p.Call("synchronizeInstances")
	return MeshFromJSObject(retVal, l.ctx)
}

// ToLeftHanded calls the ToLeftHanded method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#tolefthanded
func (l *LinesMesh) ToLeftHanded() *Mesh {

	retVal := l.p.Call("toLeftHanded")
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshToStringOpts contains optional parameters for LinesMesh.ToString.
type LinesMeshToStringOpts struct {
	FullDetails *bool
}

// ToString calls the ToString method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#tostring
func (l *LinesMesh) ToString(opts *LinesMeshToStringOpts) string {
	if opts == nil {
		opts = &LinesMeshToStringOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.FullDetails == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FullDetails)
	}

	retVal := l.p.Call("toString", args...)
	return retVal.String()
}

// UnfreezeNormals calls the UnfreezeNormals method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#unfreezenormals
func (l *LinesMesh) UnfreezeNormals() *Mesh {

	retVal := l.p.Call("unfreezeNormals")
	return MeshFromJSObject(retVal, l.ctx)
}

// UnregisterAfterRender calls the UnregisterAfterRender method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#unregisterafterrender
func (l *LinesMesh) UnregisterAfterRender(jsFunc func()) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	retVal := l.p.Call("unregisterAfterRender", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// UnregisterBeforeRender calls the UnregisterBeforeRender method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#unregisterbeforerender
func (l *LinesMesh) UnregisterBeforeRender(jsFunc func()) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	retVal := l.p.Call("unregisterBeforeRender", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshUpdateIndicesOpts contains optional parameters for LinesMesh.UpdateIndices.
type LinesMeshUpdateIndicesOpts struct {
	Offset        *float64
	GpuMemoryOnly *bool
}

// UpdateIndices calls the UpdateIndices method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#updateindices
func (l *LinesMesh) UpdateIndices(indices js.Value, opts *LinesMeshUpdateIndicesOpts) *AbstractMesh {
	if opts == nil {
		opts = &LinesMeshUpdateIndicesOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, indices)

	if opts.Offset == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Offset)
	}
	if opts.GpuMemoryOnly == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.GpuMemoryOnly)
	}

	retVal := l.p.Call("updateIndices", args...)
	return AbstractMeshFromJSObject(retVal, l.ctx)
}

// LinesMeshUpdateMeshPositionsOpts contains optional parameters for LinesMesh.UpdateMeshPositions.
type LinesMeshUpdateMeshPositionsOpts struct {
	ComputeNormals *bool
}

// UpdateMeshPositions calls the UpdateMeshPositions method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#updatemeshpositions
func (l *LinesMesh) UpdateMeshPositions(positionFunction func(), opts *LinesMeshUpdateMeshPositionsOpts) *Mesh {
	if opts == nil {
		opts = &LinesMeshUpdateMeshPositionsOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { positionFunction(); return nil }))

	if opts.ComputeNormals == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ComputeNormals)
	}

	retVal := l.p.Call("updateMeshPositions", args...)
	return MeshFromJSObject(retVal, l.ctx)
}

// LinesMeshUpdateVerticesDataOpts contains optional parameters for LinesMesh.UpdateVerticesData.
type LinesMeshUpdateVerticesDataOpts struct {
	UpdateExtends *bool
	MakeItUnique  *bool
}

// UpdateVerticesData calls the UpdateVerticesData method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#updateverticesdata
func (l *LinesMesh) UpdateVerticesData(kind string, data js.Value, opts *LinesMeshUpdateVerticesDataOpts) *AbstractMesh {
	if opts == nil {
		opts = &LinesMeshUpdateVerticesDataOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, kind)
	args = append(args, data)

	if opts.UpdateExtends == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UpdateExtends)
	}
	if opts.MakeItUnique == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MakeItUnique)
	}

	retVal := l.p.Call("updateVerticesData", args...)
	return AbstractMeshFromJSObject(retVal, l.ctx)
}

// ValidateSkinning calls the ValidateSkinning method on the LinesMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#validateskinning
func (l *LinesMesh) ValidateSkinning() js.Value {

	retVal := l.p.Call("validateSkinning")
	return retVal
}

/*

// Alpha returns the Alpha property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#alpha
func (l *LinesMesh) Alpha(alpha float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(alpha)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetAlpha sets the Alpha property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#alpha
func (l *LinesMesh) SetAlpha(alpha float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(alpha)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// AreNormalsFrozen returns the AreNormalsFrozen property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#arenormalsfrozen
func (l *LinesMesh) AreNormalsFrozen(areNormalsFrozen bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(areNormalsFrozen)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetAreNormalsFrozen sets the AreNormalsFrozen property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#arenormalsfrozen
func (l *LinesMesh) SetAreNormalsFrozen(areNormalsFrozen bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(areNormalsFrozen)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// BACKSIDE returns the BACKSIDE property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#backside
func (l *LinesMesh) BACKSIDE(BACKSIDE float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(BACKSIDE)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetBACKSIDE sets the BACKSIDE property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#backside
func (l *LinesMesh) SetBACKSIDE(BACKSIDE float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(BACKSIDE)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// BOTTOM returns the BOTTOM property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#bottom
func (l *LinesMesh) BOTTOM(BOTTOM float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(BOTTOM)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetBOTTOM sets the BOTTOM property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#bottom
func (l *LinesMesh) SetBOTTOM(BOTTOM float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(BOTTOM)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// CAP_ALL returns the CAP_ALL property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#cap_all
func (l *LinesMesh) CAP_ALL(CAP_ALL float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(CAP_ALL)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetCAP_ALL sets the CAP_ALL property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#cap_all
func (l *LinesMesh) SetCAP_ALL(CAP_ALL float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(CAP_ALL)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// CAP_END returns the CAP_END property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#cap_end
func (l *LinesMesh) CAP_END(CAP_END float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(CAP_END)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetCAP_END sets the CAP_END property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#cap_end
func (l *LinesMesh) SetCAP_END(CAP_END float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(CAP_END)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// CAP_START returns the CAP_START property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#cap_start
func (l *LinesMesh) CAP_START(CAP_START float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(CAP_START)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetCAP_START sets the CAP_START property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#cap_start
func (l *LinesMesh) SetCAP_START(CAP_START float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(CAP_START)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// CENTER returns the CENTER property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#center
func (l *LinesMesh) CENTER(CENTER float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(CENTER)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetCENTER sets the CENTER property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#center
func (l *LinesMesh) SetCENTER(CENTER float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(CENTER)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// Color returns the Color property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#color
func (l *LinesMesh) Color(color *Color3) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(color.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetColor sets the Color property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#color
func (l *LinesMesh) SetColor(color *Color3) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(color.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// DEFAULTSIDE returns the DEFAULTSIDE property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#defaultside
func (l *LinesMesh) DEFAULTSIDE(DEFAULTSIDE float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(DEFAULTSIDE)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetDEFAULTSIDE sets the DEFAULTSIDE property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#defaultside
func (l *LinesMesh) SetDEFAULTSIDE(DEFAULTSIDE float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(DEFAULTSIDE)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// DOUBLESIDE returns the DOUBLESIDE property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#doubleside
func (l *LinesMesh) DOUBLESIDE(DOUBLESIDE float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(DOUBLESIDE)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetDOUBLESIDE sets the DOUBLESIDE property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#doubleside
func (l *LinesMesh) SetDOUBLESIDE(DOUBLESIDE float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(DOUBLESIDE)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// DelayLoadState returns the DelayLoadState property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#delayloadstate
func (l *LinesMesh) DelayLoadState(delayLoadState float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(delayLoadState)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetDelayLoadState sets the DelayLoadState property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#delayloadstate
func (l *LinesMesh) SetDelayLoadState(delayLoadState float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(delayLoadState)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// DelayLoadingFile returns the DelayLoadingFile property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#delayloadingfile
func (l *LinesMesh) DelayLoadingFile(delayLoadingFile string) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(delayLoadingFile)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetDelayLoadingFile sets the DelayLoadingFile property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#delayloadingfile
func (l *LinesMesh) SetDelayLoadingFile(delayLoadingFile string) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(delayLoadingFile)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// FLIP_N_ROTATE_ROW returns the FLIP_N_ROTATE_ROW property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#flip_n_rotate_row
func (l *LinesMesh) FLIP_N_ROTATE_ROW(FLIP_N_ROTATE_ROW float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(FLIP_N_ROTATE_ROW)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetFLIP_N_ROTATE_ROW sets the FLIP_N_ROTATE_ROW property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#flip_n_rotate_row
func (l *LinesMesh) SetFLIP_N_ROTATE_ROW(FLIP_N_ROTATE_ROW float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(FLIP_N_ROTATE_ROW)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// FLIP_N_ROTATE_TILE returns the FLIP_N_ROTATE_TILE property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#flip_n_rotate_tile
func (l *LinesMesh) FLIP_N_ROTATE_TILE(FLIP_N_ROTATE_TILE float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(FLIP_N_ROTATE_TILE)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetFLIP_N_ROTATE_TILE sets the FLIP_N_ROTATE_TILE property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#flip_n_rotate_tile
func (l *LinesMesh) SetFLIP_N_ROTATE_TILE(FLIP_N_ROTATE_TILE float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(FLIP_N_ROTATE_TILE)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// FLIP_ROW returns the FLIP_ROW property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#flip_row
func (l *LinesMesh) FLIP_ROW(FLIP_ROW float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(FLIP_ROW)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetFLIP_ROW sets the FLIP_ROW property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#flip_row
func (l *LinesMesh) SetFLIP_ROW(FLIP_ROW float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(FLIP_ROW)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// FLIP_TILE returns the FLIP_TILE property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#flip_tile
func (l *LinesMesh) FLIP_TILE(FLIP_TILE float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(FLIP_TILE)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetFLIP_TILE sets the FLIP_TILE property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#flip_tile
func (l *LinesMesh) SetFLIP_TILE(FLIP_TILE float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(FLIP_TILE)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// FRONTSIDE returns the FRONTSIDE property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#frontside
func (l *LinesMesh) FRONTSIDE(FRONTSIDE float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(FRONTSIDE)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetFRONTSIDE sets the FRONTSIDE property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#frontside
func (l *LinesMesh) SetFRONTSIDE(FRONTSIDE float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(FRONTSIDE)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// Geometry returns the Geometry property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#geometry
func (l *LinesMesh) Geometry(geometry *Geometry) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(geometry.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetGeometry sets the Geometry property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#geometry
func (l *LinesMesh) SetGeometry(geometry *Geometry) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(geometry.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// HasInstances returns the HasInstances property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#hasinstances
func (l *LinesMesh) HasInstances(hasInstances bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(hasInstances)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetHasInstances sets the HasInstances property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#hasinstances
func (l *LinesMesh) SetHasInstances(hasInstances bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(hasInstances)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// HasLODLevels returns the HasLODLevels property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#haslodlevels
func (l *LinesMesh) HasLODLevels(hasLODLevels bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(hasLODLevels)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetHasLODLevels sets the HasLODLevels property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#haslodlevels
func (l *LinesMesh) SetHasLODLevels(hasLODLevels bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(hasLODLevels)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// InstancedBuffers returns the InstancedBuffers property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#instancedbuffers
func (l *LinesMesh) InstancedBuffers(instancedBuffers js.Value) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(instancedBuffers)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetInstancedBuffers sets the InstancedBuffers property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#instancedbuffers
func (l *LinesMesh) SetInstancedBuffers(instancedBuffers js.Value) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(instancedBuffers)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// Instances returns the Instances property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#instances
func (l *LinesMesh) Instances(instances *InstancedMesh) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(instances.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetInstances sets the Instances property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#instances
func (l *LinesMesh) SetInstances(instances *InstancedMesh) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(instances.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// IntersectionThreshold returns the IntersectionThreshold property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#intersectionthreshold
func (l *LinesMesh) IntersectionThreshold(intersectionThreshold float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(intersectionThreshold)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetIntersectionThreshold sets the IntersectionThreshold property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#intersectionthreshold
func (l *LinesMesh) SetIntersectionThreshold(intersectionThreshold float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(intersectionThreshold)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// IsBlocked returns the IsBlocked property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#isblocked
func (l *LinesMesh) IsBlocked(isBlocked bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(isBlocked)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetIsBlocked sets the IsBlocked property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#isblocked
func (l *LinesMesh) SetIsBlocked(isBlocked bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(isBlocked)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// IsUnIndexed returns the IsUnIndexed property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#isunindexed
func (l *LinesMesh) IsUnIndexed(isUnIndexed bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(isUnIndexed)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetIsUnIndexed sets the IsUnIndexed property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#isunindexed
func (l *LinesMesh) SetIsUnIndexed(isUnIndexed bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(isUnIndexed)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// LEFT returns the LEFT property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#left
func (l *LinesMesh) LEFT(LEFT float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(LEFT)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetLEFT sets the LEFT property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#left
func (l *LinesMesh) SetLEFT(LEFT float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(LEFT)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// ManualUpdateOfWorldMatrixInstancedBuffer returns the ManualUpdateOfWorldMatrixInstancedBuffer property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#manualupdateofworldmatrixinstancedbuffer
func (l *LinesMesh) ManualUpdateOfWorldMatrixInstancedBuffer(manualUpdateOfWorldMatrixInstancedBuffer bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(manualUpdateOfWorldMatrixInstancedBuffer)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetManualUpdateOfWorldMatrixInstancedBuffer sets the ManualUpdateOfWorldMatrixInstancedBuffer property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#manualupdateofworldmatrixinstancedbuffer
func (l *LinesMesh) SetManualUpdateOfWorldMatrixInstancedBuffer(manualUpdateOfWorldMatrixInstancedBuffer bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(manualUpdateOfWorldMatrixInstancedBuffer)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// MorphTargetManager returns the MorphTargetManager property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#morphtargetmanager
func (l *LinesMesh) MorphTargetManager(morphTargetManager *MorphTargetManager) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(morphTargetManager.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetMorphTargetManager sets the MorphTargetManager property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#morphtargetmanager
func (l *LinesMesh) SetMorphTargetManager(morphTargetManager *MorphTargetManager) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(morphTargetManager.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// NO_CAP returns the NO_CAP property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#no_cap
func (l *LinesMesh) NO_CAP(NO_CAP float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(NO_CAP)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetNO_CAP sets the NO_CAP property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#no_cap
func (l *LinesMesh) SetNO_CAP(NO_CAP float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(NO_CAP)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// NO_FLIP returns the NO_FLIP property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#no_flip
func (l *LinesMesh) NO_FLIP(NO_FLIP float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(NO_FLIP)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetNO_FLIP sets the NO_FLIP property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#no_flip
func (l *LinesMesh) SetNO_FLIP(NO_FLIP float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(NO_FLIP)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// OnAfterRenderObservable returns the OnAfterRenderObservable property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#onafterrenderobservable
func (l *LinesMesh) OnAfterRenderObservable(onAfterRenderObservable *Observable) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(onAfterRenderObservable.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetOnAfterRenderObservable sets the OnAfterRenderObservable property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#onafterrenderobservable
func (l *LinesMesh) SetOnAfterRenderObservable(onAfterRenderObservable *Observable) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(onAfterRenderObservable.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// OnBeforeBindObservable returns the OnBeforeBindObservable property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#onbeforebindobservable
func (l *LinesMesh) OnBeforeBindObservable(onBeforeBindObservable *Observable) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(onBeforeBindObservable.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetOnBeforeBindObservable sets the OnBeforeBindObservable property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#onbeforebindobservable
func (l *LinesMesh) SetOnBeforeBindObservable(onBeforeBindObservable *Observable) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(onBeforeBindObservable.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// OnBeforeDraw returns the OnBeforeDraw property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#onbeforedraw
func (l *LinesMesh) OnBeforeDraw(onBeforeDraw func()) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(js.FuncOf(func(this js.Value, args []js.Value) interface{} {onBeforeDraw(); return nil}))
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetOnBeforeDraw sets the OnBeforeDraw property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#onbeforedraw
func (l *LinesMesh) SetOnBeforeDraw(onBeforeDraw func()) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(js.FuncOf(func(this js.Value, args []js.Value) interface{} {onBeforeDraw(); return nil}))
	return LinesMeshFromJSObject(p, ba.ctx)
}

// OnBeforeDrawObservable returns the OnBeforeDrawObservable property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#onbeforedrawobservable
func (l *LinesMesh) OnBeforeDrawObservable(onBeforeDrawObservable *Observable) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(onBeforeDrawObservable.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetOnBeforeDrawObservable sets the OnBeforeDrawObservable property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#onbeforedrawobservable
func (l *LinesMesh) SetOnBeforeDrawObservable(onBeforeDrawObservable *Observable) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(onBeforeDrawObservable.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// OnBeforeRenderObservable returns the OnBeforeRenderObservable property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#onbeforerenderobservable
func (l *LinesMesh) OnBeforeRenderObservable(onBeforeRenderObservable *Observable) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(onBeforeRenderObservable.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetOnBeforeRenderObservable sets the OnBeforeRenderObservable property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#onbeforerenderobservable
func (l *LinesMesh) SetOnBeforeRenderObservable(onBeforeRenderObservable *Observable) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(onBeforeRenderObservable.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// OnLODLevelSelection returns the OnLODLevelSelection property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#onlodlevelselection
func (l *LinesMesh) OnLODLevelSelection(onLODLevelSelection func()) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(js.FuncOf(func(this js.Value, args []js.Value) interface{} {onLODLevelSelection(); return nil}))
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetOnLODLevelSelection sets the OnLODLevelSelection property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#onlodlevelselection
func (l *LinesMesh) SetOnLODLevelSelection(onLODLevelSelection func()) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(js.FuncOf(func(this js.Value, args []js.Value) interface{} {onLODLevelSelection(); return nil}))
	return LinesMeshFromJSObject(p, ba.ctx)
}

// OverrideMaterialSideOrientation returns the OverrideMaterialSideOrientation property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#overridematerialsideorientation
func (l *LinesMesh) OverrideMaterialSideOrientation(overrideMaterialSideOrientation float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(overrideMaterialSideOrientation)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetOverrideMaterialSideOrientation sets the OverrideMaterialSideOrientation property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#overridematerialsideorientation
func (l *LinesMesh) SetOverrideMaterialSideOrientation(overrideMaterialSideOrientation float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(overrideMaterialSideOrientation)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// OverridenInstanceCount returns the OverridenInstanceCount property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#overrideninstancecount
func (l *LinesMesh) OverridenInstanceCount(overridenInstanceCount float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(overridenInstanceCount)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetOverridenInstanceCount sets the OverridenInstanceCount property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#overrideninstancecount
func (l *LinesMesh) SetOverridenInstanceCount(overridenInstanceCount float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(overridenInstanceCount)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// RIGHT returns the RIGHT property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#right
func (l *LinesMesh) RIGHT(RIGHT float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(RIGHT)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetRIGHT sets the RIGHT property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#right
func (l *LinesMesh) SetRIGHT(RIGHT float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(RIGHT)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// ROTATE_ROW returns the ROTATE_ROW property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#rotate_row
func (l *LinesMesh) ROTATE_ROW(ROTATE_ROW float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(ROTATE_ROW)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetROTATE_ROW sets the ROTATE_ROW property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#rotate_row
func (l *LinesMesh) SetROTATE_ROW(ROTATE_ROW float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(ROTATE_ROW)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// ROTATE_TILE returns the ROTATE_TILE property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#rotate_tile
func (l *LinesMesh) ROTATE_TILE(ROTATE_TILE float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(ROTATE_TILE)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetROTATE_TILE sets the ROTATE_TILE property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#rotate_tile
func (l *LinesMesh) SetROTATE_TILE(ROTATE_TILE float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(ROTATE_TILE)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// Source returns the Source property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#source
func (l *LinesMesh) Source(source *Mesh) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(source.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetSource sets the Source property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#source
func (l *LinesMesh) SetSource(source *Mesh) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(source.JSObject())
	return LinesMeshFromJSObject(p, ba.ctx)
}

// TOP returns the TOP property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#top
func (l *LinesMesh) TOP(TOP float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(TOP)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetTOP sets the TOP property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#top
func (l *LinesMesh) SetTOP(TOP float64) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(TOP)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// UseVertexAlpha returns the UseVertexAlpha property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#usevertexalpha
func (l *LinesMesh) UseVertexAlpha(useVertexAlpha bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(useVertexAlpha)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetUseVertexAlpha sets the UseVertexAlpha property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#usevertexalpha
func (l *LinesMesh) SetUseVertexAlpha(useVertexAlpha bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(useVertexAlpha)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// UseVertexColor returns the UseVertexColor property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#usevertexcolor
func (l *LinesMesh) UseVertexColor(useVertexColor bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(useVertexColor)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetUseVertexColor sets the UseVertexColor property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#usevertexcolor
func (l *LinesMesh) SetUseVertexColor(useVertexColor bool) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(useVertexColor)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// WorldMatrixInstancedBuffer returns the WorldMatrixInstancedBuffer property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#worldmatrixinstancedbuffer
func (l *LinesMesh) WorldMatrixInstancedBuffer(worldMatrixInstancedBuffer js.Value) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(worldMatrixInstancedBuffer)
	return LinesMeshFromJSObject(p, ba.ctx)
}

// SetWorldMatrixInstancedBuffer sets the WorldMatrixInstancedBuffer property of class LinesMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.linesmesh#worldmatrixinstancedbuffer
func (l *LinesMesh) SetWorldMatrixInstancedBuffer(worldMatrixInstancedBuffer js.Value) *LinesMesh {
	p := ba.ctx.Get("LinesMesh").New(worldMatrixInstancedBuffer)
	return LinesMeshFromJSObject(p, ba.ctx)
}

*/

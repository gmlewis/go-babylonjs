// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// Scene represents a babylon.js Scene.
// Represents a scene to be rendered by the engine.
//
// See: http://doc.babylonjs.com/features/scene
type Scene struct {
	*AbstractScene
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (s *Scene) JSObject() js.Value { return s.p }

// Scene returns a Scene JavaScript class.
func (ba *Babylon) Scene() *Scene {
	p := ba.ctx.Get("Scene")
	return SceneFromJSObject(p, ba.ctx)
}

// SceneFromJSObject returns a wrapped Scene JavaScript class.
func SceneFromJSObject(p js.Value, ctx js.Value) *Scene {
	return &Scene{AbstractScene: AbstractSceneFromJSObject(p, ctx), ctx: ctx}
}

// SceneArrayToJSArray returns a JavaScript Array for the wrapped array.
func SceneArrayToJSArray(array []*Scene) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewSceneOpts contains optional parameters for NewScene.
type NewSceneOpts struct {
	Options js.Value
}

// NewScene returns a new Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene
func (ba *Babylon) NewScene(engine *Engine, opts *NewSceneOpts) *Scene {
	if opts == nil {
		opts = &NewSceneOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, engine.JSObject())

	args = append(args, opts.Options)

	p := ba.ctx.Get("Scene").New(args...)
	return SceneFromJSObject(p, ba.ctx)
}

// AddActionManager calls the AddActionManager method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#addactionmanager
func (s *Scene) AddActionManager(newActionManager *AbstractActionManager) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, newActionManager.JSObject())

	s.p.Call("addActionManager", args...)
}

// AddAnimation calls the AddAnimation method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#addanimation
func (s *Scene) AddAnimation(newAnimation *Animation) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, newAnimation.JSObject())

	s.p.Call("addAnimation", args...)
}

// AddAnimationGroup calls the AddAnimationGroup method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#addanimationgroup
func (s *Scene) AddAnimationGroup(newAnimationGroup *AnimationGroup) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, newAnimationGroup.JSObject())

	s.p.Call("addAnimationGroup", args...)
}

// AddCamera calls the AddCamera method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#addcamera
func (s *Scene) AddCamera(newCamera *Camera) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, newCamera.JSObject())

	s.p.Call("addCamera", args...)
}

// AddGeometry calls the AddGeometry method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#addgeometry
func (s *Scene) AddGeometry(newGeometry *Geometry) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, newGeometry.JSObject())

	s.p.Call("addGeometry", args...)
}

// AddLight calls the AddLight method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#addlight
func (s *Scene) AddLight(newLight *Light) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, newLight.JSObject())

	s.p.Call("addLight", args...)
}

// AddMaterial calls the AddMaterial method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#addmaterial
func (s *Scene) AddMaterial(newMaterial *Material) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, newMaterial.JSObject())

	s.p.Call("addMaterial", args...)
}

// SceneAddMeshOpts contains optional parameters for Scene.AddMesh.
type SceneAddMeshOpts struct {
	Recursive *bool
}

// AddMesh calls the AddMesh method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#addmesh
func (s *Scene) AddMesh(newMesh *AbstractMesh, opts *SceneAddMeshOpts) {
	if opts == nil {
		opts = &SceneAddMeshOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, newMesh.JSObject())

	if opts.Recursive == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Recursive)
	}

	s.p.Call("addMesh", args...)
}

// AddMorphTargetManager calls the AddMorphTargetManager method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#addmorphtargetmanager
func (s *Scene) AddMorphTargetManager(newMorphTargetManager *MorphTargetManager) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, newMorphTargetManager.JSObject())

	s.p.Call("addMorphTargetManager", args...)
}

// AddMultiMaterial calls the AddMultiMaterial method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#addmultimaterial
func (s *Scene) AddMultiMaterial(newMultiMaterial *MultiMaterial) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, newMultiMaterial.JSObject())

	s.p.Call("addMultiMaterial", args...)
}

// AddParticleSystem calls the AddParticleSystem method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#addparticlesystem
func (s *Scene) AddParticleSystem(newParticleSystem *IParticleSystem) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, newParticleSystem.JSObject())

	s.p.Call("addParticleSystem", args...)
}

// AddSkeleton calls the AddSkeleton method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#addskeleton
func (s *Scene) AddSkeleton(newSkeleton *Skeleton) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, newSkeleton.JSObject())

	s.p.Call("addSkeleton", args...)
}

// AddTexture calls the AddTexture method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#addtexture
func (s *Scene) AddTexture(newTexture *BaseTexture) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, newTexture.JSObject())

	s.p.Call("addTexture", args...)
}

// AddTransformNode calls the AddTransformNode method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#addtransformnode
func (s *Scene) AddTransformNode(newTransformNode *TransformNode) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, newTransformNode.JSObject())

	s.p.Call("addTransformNode", args...)
}

// Animate calls the Animate method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#animate
func (s *Scene) Animate() {

	s.p.Call("animate")
}

// SceneAttachControlOpts contains optional parameters for Scene.AttachControl.
type SceneAttachControlOpts struct {
	AttachUp   *bool
	AttachDown *bool
	AttachMove *bool
}

// AttachControl calls the AttachControl method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#attachcontrol
func (s *Scene) AttachControl(opts *SceneAttachControlOpts) {
	if opts == nil {
		opts = &SceneAttachControlOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.AttachUp == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AttachUp)
	}
	if opts.AttachDown == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AttachDown)
	}
	if opts.AttachMove == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AttachMove)
	}

	s.p.Call("attachControl", args...)
}

// SceneBeginAnimationOpts contains optional parameters for Scene.BeginAnimation.
type SceneBeginAnimationOpts struct {
	Loop            *bool
	SpeedRatio      *float64
	OnAnimationEnd  func()
	Animatable      *Animatable
	StopCurrent     *bool
	TargetMask      func()
	OnAnimationLoop func()
}

// BeginAnimation calls the BeginAnimation method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#beginanimation
func (s *Scene) BeginAnimation(target interface{}, from float64, to float64, opts *SceneBeginAnimationOpts) *Animatable {
	if opts == nil {
		opts = &SceneBeginAnimationOpts{}
	}

	args := make([]interface{}, 0, 3+7)

	args = append(args, target)
	args = append(args, from)
	args = append(args, to)

	if opts.Loop == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Loop)
	}
	if opts.SpeedRatio == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SpeedRatio)
	}
	if opts.OnAnimationEnd == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OnAnimationEnd(); return nil }) /* never freed! */)
	}
	if opts.Animatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Animatable.JSObject())
	}
	if opts.StopCurrent == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.StopCurrent)
	}
	if opts.TargetMask == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.TargetMask(); return nil }) /* never freed! */)
	}
	if opts.OnAnimationLoop == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OnAnimationLoop(); return nil }) /* never freed! */)
	}

	retVal := s.p.Call("beginAnimation", args...)
	return AnimatableFromJSObject(retVal, s.ctx)
}

// SceneBeginDirectAnimationOpts contains optional parameters for Scene.BeginDirectAnimation.
type SceneBeginDirectAnimationOpts struct {
	Loop            *bool
	SpeedRatio      *float64
	OnAnimationEnd  func()
	OnAnimationLoop func()
}

// BeginDirectAnimation calls the BeginDirectAnimation method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#begindirectanimation
func (s *Scene) BeginDirectAnimation(target interface{}, animations []*Animation, from float64, to float64, opts *SceneBeginDirectAnimationOpts) *Animatable {
	if opts == nil {
		opts = &SceneBeginDirectAnimationOpts{}
	}

	args := make([]interface{}, 0, 4+4)

	args = append(args, target)
	args = append(args, AnimationArrayToJSArray(animations))
	args = append(args, from)
	args = append(args, to)

	if opts.Loop == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Loop)
	}
	if opts.SpeedRatio == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SpeedRatio)
	}
	if opts.OnAnimationEnd == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OnAnimationEnd(); return nil }) /* never freed! */)
	}
	if opts.OnAnimationLoop == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OnAnimationLoop(); return nil }) /* never freed! */)
	}

	retVal := s.p.Call("beginDirectAnimation", args...)
	return AnimatableFromJSObject(retVal, s.ctx)
}

// SceneBeginDirectHierarchyAnimationOpts contains optional parameters for Scene.BeginDirectHierarchyAnimation.
type SceneBeginDirectHierarchyAnimationOpts struct {
	Loop            *bool
	SpeedRatio      *float64
	OnAnimationEnd  func()
	OnAnimationLoop func()
}

// BeginDirectHierarchyAnimation calls the BeginDirectHierarchyAnimation method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#begindirecthierarchyanimation
func (s *Scene) BeginDirectHierarchyAnimation(target *Node, directDescendantsOnly bool, animations []*Animation, from float64, to float64, opts *SceneBeginDirectHierarchyAnimationOpts) []*Animatable {
	if opts == nil {
		opts = &SceneBeginDirectHierarchyAnimationOpts{}
	}

	args := make([]interface{}, 0, 5+4)

	args = append(args, target.JSObject())
	args = append(args, directDescendantsOnly)
	args = append(args, AnimationArrayToJSArray(animations))
	args = append(args, from)
	args = append(args, to)

	if opts.Loop == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Loop)
	}
	if opts.SpeedRatio == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SpeedRatio)
	}
	if opts.OnAnimationEnd == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OnAnimationEnd(); return nil }) /* never freed! */)
	}
	if opts.OnAnimationLoop == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OnAnimationLoop(); return nil }) /* never freed! */)
	}

	retVal := s.p.Call("beginDirectHierarchyAnimation", args...)
	result := []*Animatable{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, AnimatableFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// SceneBeginHierarchyAnimationOpts contains optional parameters for Scene.BeginHierarchyAnimation.
type SceneBeginHierarchyAnimationOpts struct {
	Loop            *bool
	SpeedRatio      *float64
	OnAnimationEnd  func()
	Animatable      *Animatable
	StopCurrent     *bool
	TargetMask      func()
	OnAnimationLoop func()
}

// BeginHierarchyAnimation calls the BeginHierarchyAnimation method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#beginhierarchyanimation
func (s *Scene) BeginHierarchyAnimation(target interface{}, directDescendantsOnly bool, from float64, to float64, opts *SceneBeginHierarchyAnimationOpts) []*Animatable {
	if opts == nil {
		opts = &SceneBeginHierarchyAnimationOpts{}
	}

	args := make([]interface{}, 0, 4+7)

	args = append(args, target)
	args = append(args, directDescendantsOnly)
	args = append(args, from)
	args = append(args, to)

	if opts.Loop == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Loop)
	}
	if opts.SpeedRatio == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SpeedRatio)
	}
	if opts.OnAnimationEnd == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OnAnimationEnd(); return nil }) /* never freed! */)
	}
	if opts.Animatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Animatable.JSObject())
	}
	if opts.StopCurrent == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.StopCurrent)
	}
	if opts.TargetMask == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.TargetMask(); return nil }) /* never freed! */)
	}
	if opts.OnAnimationLoop == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OnAnimationLoop(); return nil }) /* never freed! */)
	}

	retVal := s.p.Call("beginHierarchyAnimation", args...)
	result := []*Animatable{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, AnimatableFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// SceneBeginWeightedAnimationOpts contains optional parameters for Scene.BeginWeightedAnimation.
type SceneBeginWeightedAnimationOpts struct {
	Loop            *bool
	SpeedRatio      *float64
	OnAnimationEnd  func()
	Animatable      *Animatable
	TargetMask      func()
	OnAnimationLoop func()
}

// BeginWeightedAnimation calls the BeginWeightedAnimation method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#beginweightedanimation
func (s *Scene) BeginWeightedAnimation(target interface{}, from float64, to float64, weight float64, opts *SceneBeginWeightedAnimationOpts) *Animatable {
	if opts == nil {
		opts = &SceneBeginWeightedAnimationOpts{}
	}

	args := make([]interface{}, 0, 4+6)

	args = append(args, target)
	args = append(args, from)
	args = append(args, to)
	args = append(args, weight)

	if opts.Loop == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Loop)
	}
	if opts.SpeedRatio == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SpeedRatio)
	}
	if opts.OnAnimationEnd == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OnAnimationEnd(); return nil }) /* never freed! */)
	}
	if opts.Animatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Animatable.JSObject())
	}
	if opts.TargetMask == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.TargetMask(); return nil }) /* never freed! */)
	}
	if opts.OnAnimationLoop == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OnAnimationLoop(); return nil }) /* never freed! */)
	}

	retVal := s.p.Call("beginWeightedAnimation", args...)
	return AnimatableFromJSObject(retVal, s.ctx)
}

// CleanCachedTextureBuffer calls the CleanCachedTextureBuffer method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#cleancachedtexturebuffer
func (s *Scene) CleanCachedTextureBuffer() {

	s.p.Call("cleanCachedTextureBuffer")
}

// ClearCachedVertexData calls the ClearCachedVertexData method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#clearcachedvertexdata
func (s *Scene) ClearCachedVertexData() {

	s.p.Call("clearCachedVertexData")
}

// CollisionCoordinatorFactory calls the CollisionCoordinatorFactory method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#collisioncoordinatorfactory
func (s *Scene) CollisionCoordinatorFactory() js.Value {

	retVal := s.p.Call("CollisionCoordinatorFactory")
	return retVal
}

// SceneCreateDefaultCameraOpts contains optional parameters for Scene.CreateDefaultCamera.
type SceneCreateDefaultCameraOpts struct {
	CreateArcRotateCamera *bool
	Replace               *bool
	AttachCameraControls  *bool
}

// CreateDefaultCamera calls the CreateDefaultCamera method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#createdefaultcamera
func (s *Scene) CreateDefaultCamera(opts *SceneCreateDefaultCameraOpts) {
	if opts == nil {
		opts = &SceneCreateDefaultCameraOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.CreateArcRotateCamera == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CreateArcRotateCamera)
	}
	if opts.Replace == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Replace)
	}
	if opts.AttachCameraControls == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AttachCameraControls)
	}

	s.p.Call("createDefaultCamera", args...)
}

// SceneCreateDefaultCameraOrLightOpts contains optional parameters for Scene.CreateDefaultCameraOrLight.
type SceneCreateDefaultCameraOrLightOpts struct {
	CreateArcRotateCamera *bool
	Replace               *bool
	AttachCameraControls  *bool
}

// CreateDefaultCameraOrLight calls the CreateDefaultCameraOrLight method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#createdefaultcameraorlight
func (s *Scene) CreateDefaultCameraOrLight(opts *SceneCreateDefaultCameraOrLightOpts) {
	if opts == nil {
		opts = &SceneCreateDefaultCameraOrLightOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.CreateArcRotateCamera == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CreateArcRotateCamera)
	}
	if opts.Replace == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Replace)
	}
	if opts.AttachCameraControls == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AttachCameraControls)
	}

	s.p.Call("createDefaultCameraOrLight", args...)
}

// SceneCreateDefaultEnvironmentOpts contains optional parameters for Scene.CreateDefaultEnvironment.
type SceneCreateDefaultEnvironmentOpts struct {
	Options *IEnvironmentHelperOptions
}

// CreateDefaultEnvironment calls the CreateDefaultEnvironment method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#createdefaultenvironment
func (s *Scene) CreateDefaultEnvironment(opts *SceneCreateDefaultEnvironmentOpts) *EnvironmentHelper {
	if opts == nil {
		opts = &SceneCreateDefaultEnvironmentOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.Options == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Options.JSObject())
	}

	retVal := s.p.Call("createDefaultEnvironment", args...)
	return EnvironmentHelperFromJSObject(retVal, s.ctx)
}

// SceneCreateDefaultLightOpts contains optional parameters for Scene.CreateDefaultLight.
type SceneCreateDefaultLightOpts struct {
	Replace *bool
}

// CreateDefaultLight calls the CreateDefaultLight method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#createdefaultlight
func (s *Scene) CreateDefaultLight(opts *SceneCreateDefaultLightOpts) {
	if opts == nil {
		opts = &SceneCreateDefaultLightOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.Replace == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Replace)
	}

	s.p.Call("createDefaultLight", args...)
}

// SceneCreateDefaultSkyboxOpts contains optional parameters for Scene.CreateDefaultSkybox.
type SceneCreateDefaultSkyboxOpts struct {
	EnvironmentTexture  *BaseTexture
	Pbr                 *bool
	Scale               *float64
	Blur                *float64
	SetGlobalEnvTexture *bool
}

// CreateDefaultSkybox calls the CreateDefaultSkybox method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#createdefaultskybox
func (s *Scene) CreateDefaultSkybox(opts *SceneCreateDefaultSkyboxOpts) *Mesh {
	if opts == nil {
		opts = &SceneCreateDefaultSkyboxOpts{}
	}

	args := make([]interface{}, 0, 0+5)

	if opts.EnvironmentTexture == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.EnvironmentTexture.JSObject())
	}
	if opts.Pbr == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Pbr)
	}
	if opts.Scale == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Scale)
	}
	if opts.Blur == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Blur)
	}
	if opts.SetGlobalEnvTexture == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SetGlobalEnvTexture)
	}

	retVal := s.p.Call("createDefaultSkybox", args...)
	return MeshFromJSObject(retVal, s.ctx)
}

// SceneCreateDefaultVRExperienceOpts contains optional parameters for Scene.CreateDefaultVRExperience.
type SceneCreateDefaultVRExperienceOpts struct {
	WebVROptions js.Value
}

// CreateDefaultVRExperience calls the CreateDefaultVRExperience method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#createdefaultvrexperience
func (s *Scene) CreateDefaultVRExperience(opts *SceneCreateDefaultVRExperienceOpts) *VRExperienceHelper {
	if opts == nil {
		opts = &SceneCreateDefaultVRExperienceOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	args = append(args, opts.WebVROptions)

	retVal := s.p.Call("createDefaultVRExperience", args...)
	return VRExperienceHelperFromJSObject(retVal, s.ctx)
}

// CreateDefaultXRExperienceAsync calls the CreateDefaultXRExperienceAsync method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#createdefaultxrexperienceasync
func (s *Scene) CreateDefaultXRExperienceAsync(options *WebXRDefaultExperienceOptions) *Promise {

	args := make([]interface{}, 0, 1+0)

	args = append(args, options.JSObject())

	retVal := s.p.Call("createDefaultXRExperienceAsync", args...)
	return PromiseFromJSObject(retVal, s.ctx)
}

// SceneCreateOrUpdateSelectionOctreeOpts contains optional parameters for Scene.CreateOrUpdateSelectionOctree.
type SceneCreateOrUpdateSelectionOctreeOpts struct {
	MaxCapacity *float64
	MaxDepth    *float64
}

// CreateOrUpdateSelectionOctree calls the CreateOrUpdateSelectionOctree method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#createorupdateselectionoctree
func (s *Scene) CreateOrUpdateSelectionOctree(opts *SceneCreateOrUpdateSelectionOctreeOpts) *Octree {
	if opts == nil {
		opts = &SceneCreateOrUpdateSelectionOctreeOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.MaxCapacity == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MaxCapacity)
	}
	if opts.MaxDepth == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MaxDepth)
	}

	retVal := s.p.Call("createOrUpdateSelectionOctree", args...)
	return OctreeFromJSObject(retVal, s.ctx)
}

// SceneCreatePickingRayOpts contains optional parameters for Scene.CreatePickingRay.
type SceneCreatePickingRayOpts struct {
	CameraViewSpace *bool
}

// CreatePickingRay calls the CreatePickingRay method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#createpickingray
func (s *Scene) CreatePickingRay(x float64, y float64, world *Matrix, camera *Camera, opts *SceneCreatePickingRayOpts) *Ray {
	if opts == nil {
		opts = &SceneCreatePickingRayOpts{}
	}

	args := make([]interface{}, 0, 4+1)

	args = append(args, x)
	args = append(args, y)
	args = append(args, world.JSObject())
	args = append(args, camera.JSObject())

	if opts.CameraViewSpace == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CameraViewSpace)
	}

	retVal := s.p.Call("createPickingRay", args...)
	return RayFromJSObject(retVal, s.ctx)
}

// SceneCreatePickingRayInCameraSpaceOpts contains optional parameters for Scene.CreatePickingRayInCameraSpace.
type SceneCreatePickingRayInCameraSpaceOpts struct {
	Camera *Camera
}

// CreatePickingRayInCameraSpace calls the CreatePickingRayInCameraSpace method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#createpickingrayincameraspace
func (s *Scene) CreatePickingRayInCameraSpace(x float64, y float64, opts *SceneCreatePickingRayInCameraSpaceOpts) *Ray {
	if opts == nil {
		opts = &SceneCreatePickingRayInCameraSpaceOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, x)
	args = append(args, y)

	if opts.Camera == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Camera.JSObject())
	}

	retVal := s.p.Call("createPickingRayInCameraSpace", args...)
	return RayFromJSObject(retVal, s.ctx)
}

// SceneCreatePickingRayInCameraSpaceToRefOpts contains optional parameters for Scene.CreatePickingRayInCameraSpaceToRef.
type SceneCreatePickingRayInCameraSpaceToRefOpts struct {
	Camera *Camera
}

// CreatePickingRayInCameraSpaceToRef calls the CreatePickingRayInCameraSpaceToRef method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#createpickingrayincameraspacetoref
func (s *Scene) CreatePickingRayInCameraSpaceToRef(x float64, y float64, result *Ray, opts *SceneCreatePickingRayInCameraSpaceToRefOpts) *Scene {
	if opts == nil {
		opts = &SceneCreatePickingRayInCameraSpaceToRefOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	args = append(args, x)
	args = append(args, y)
	args = append(args, result.JSObject())

	if opts.Camera == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Camera.JSObject())
	}

	retVal := s.p.Call("createPickingRayInCameraSpaceToRef", args...)
	return SceneFromJSObject(retVal, s.ctx)
}

// SceneCreatePickingRayToRefOpts contains optional parameters for Scene.CreatePickingRayToRef.
type SceneCreatePickingRayToRefOpts struct {
	CameraViewSpace *bool
}

// CreatePickingRayToRef calls the CreatePickingRayToRef method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#createpickingraytoref
func (s *Scene) CreatePickingRayToRef(x float64, y float64, world *Matrix, result *Ray, camera *Camera, opts *SceneCreatePickingRayToRefOpts) *Scene {
	if opts == nil {
		opts = &SceneCreatePickingRayToRefOpts{}
	}

	args := make([]interface{}, 0, 5+1)

	args = append(args, x)
	args = append(args, y)
	args = append(args, world.JSObject())
	args = append(args, result.JSObject())
	args = append(args, camera.JSObject())

	if opts.CameraViewSpace == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CameraViewSpace)
	}

	retVal := s.p.Call("createPickingRayToRef", args...)
	return SceneFromJSObject(retVal, s.ctx)
}

// DefaultMaterialFactory calls the DefaultMaterialFactory method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#defaultmaterialfactory
func (s *Scene) DefaultMaterialFactory(scene *Scene) *Material {

	args := make([]interface{}, 0, 1+0)

	args = append(args, scene.JSObject())

	retVal := s.p.Call("DefaultMaterialFactory", args...)
	return MaterialFromJSObject(retVal, s.ctx)
}

// DeleteCompoundImpostor calls the DeleteCompoundImpostor method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#deletecompoundimpostor
func (s *Scene) DeleteCompoundImpostor(compound interface{}) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, compound)

	s.p.Call("deleteCompoundImpostor", args...)
}

// DetachControl calls the DetachControl method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#detachcontrol
func (s *Scene) DetachControl() {

	s.p.Call("detachControl")
}

// SceneDisableDepthRendererOpts contains optional parameters for Scene.DisableDepthRenderer.
type SceneDisableDepthRendererOpts struct {
	Camera *Camera
}

// DisableDepthRenderer calls the DisableDepthRenderer method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#disabledepthrenderer
func (s *Scene) DisableDepthRenderer(opts *SceneDisableDepthRendererOpts) {
	if opts == nil {
		opts = &SceneDisableDepthRendererOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.Camera == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Camera.JSObject())
	}

	s.p.Call("disableDepthRenderer", args...)
}

// DisableGeometryBufferRenderer calls the DisableGeometryBufferRenderer method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#disablegeometrybufferrenderer
func (s *Scene) DisableGeometryBufferRenderer() {

	s.p.Call("disableGeometryBufferRenderer")
}

// DisablePhysicsEngine calls the DisablePhysicsEngine method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#disablephysicsengine
func (s *Scene) DisablePhysicsEngine() {

	s.p.Call("disablePhysicsEngine")
}

// Dispose calls the Dispose method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#dispose
func (s *Scene) Dispose() {

	s.p.Call("dispose")
}

// SceneEnableDepthRendererOpts contains optional parameters for Scene.EnableDepthRenderer.
type SceneEnableDepthRendererOpts struct {
	Camera              *Camera
	StoreNonLinearDepth *bool
}

// EnableDepthRenderer calls the EnableDepthRenderer method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#enabledepthrenderer
func (s *Scene) EnableDepthRenderer(opts *SceneEnableDepthRendererOpts) *DepthRenderer {
	if opts == nil {
		opts = &SceneEnableDepthRendererOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.Camera == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Camera.JSObject())
	}
	if opts.StoreNonLinearDepth == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.StoreNonLinearDepth)
	}

	retVal := s.p.Call("enableDepthRenderer", args...)
	return DepthRendererFromJSObject(retVal, s.ctx)
}

// SceneEnableGeometryBufferRendererOpts contains optional parameters for Scene.EnableGeometryBufferRenderer.
type SceneEnableGeometryBufferRendererOpts struct {
	Ratio *float64
}

// EnableGeometryBufferRenderer calls the EnableGeometryBufferRenderer method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#enablegeometrybufferrenderer
func (s *Scene) EnableGeometryBufferRenderer(opts *SceneEnableGeometryBufferRendererOpts) *GeometryBufferRenderer {
	if opts == nil {
		opts = &SceneEnableGeometryBufferRendererOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.Ratio == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Ratio)
	}

	retVal := s.p.Call("enableGeometryBufferRenderer", args...)
	return GeometryBufferRendererFromJSObject(retVal, s.ctx)
}

// SceneEnablePhysicsOpts contains optional parameters for Scene.EnablePhysics.
type SceneEnablePhysicsOpts struct {
	Plugin js.Value
}

// EnablePhysics calls the EnablePhysics method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#enablephysics
func (s *Scene) EnablePhysics(gravity *Vector3, opts *SceneEnablePhysicsOpts) bool {
	if opts == nil {
		opts = &SceneEnablePhysicsOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, gravity.JSObject())

	args = append(args, opts.Plugin)

	retVal := s.p.Call("enablePhysics", args...)
	return retVal.Bool()
}

// SceneExecuteOnceBeforeRenderOpts contains optional parameters for Scene.ExecuteOnceBeforeRender.
type SceneExecuteOnceBeforeRenderOpts struct {
	Timeout *float64
}

// ExecuteOnceBeforeRender calls the ExecuteOnceBeforeRender method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#executeoncebeforerender
func (s *Scene) ExecuteOnceBeforeRender(jsFunc func(), opts *SceneExecuteOnceBeforeRenderOpts) {
	if opts == nil {
		opts = &SceneExecuteOnceBeforeRenderOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	if opts.Timeout == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Timeout)
	}

	s.p.Call("executeOnceBeforeRender", args...)
}

// ExecuteWhenReady calls the ExecuteWhenReady method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#executewhenready
func (s *Scene) ExecuteWhenReady(jsFunc func()) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	s.p.Call("executeWhenReady", args...)
}

// FreeActiveMeshes calls the FreeActiveMeshes method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#freeactivemeshes
func (s *Scene) FreeActiveMeshes() {

	s.p.Call("freeActiveMeshes")
}

// FreeProcessedMaterials calls the FreeProcessedMaterials method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#freeprocessedmaterials
func (s *Scene) FreeProcessedMaterials() {

	s.p.Call("freeProcessedMaterials")
}

// FreeRenderingGroups calls the FreeRenderingGroups method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#freerenderinggroups
func (s *Scene) FreeRenderingGroups() {

	s.p.Call("freeRenderingGroups")
}

// SceneFreezeActiveMeshesOpts contains optional parameters for Scene.FreezeActiveMeshes.
type SceneFreezeActiveMeshesOpts struct {
	SkipEvaluateActiveMeshes *bool
}

// FreezeActiveMeshes calls the FreezeActiveMeshes method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#freezeactivemeshes
func (s *Scene) FreezeActiveMeshes(opts *SceneFreezeActiveMeshesOpts) *Scene {
	if opts == nil {
		opts = &SceneFreezeActiveMeshesOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.SkipEvaluateActiveMeshes == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SkipEvaluateActiveMeshes)
	}

	retVal := s.p.Call("freezeActiveMeshes", args...)
	return SceneFromJSObject(retVal, s.ctx)
}

// FreezeMaterials calls the FreezeMaterials method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#freezematerials
func (s *Scene) FreezeMaterials() {

	s.p.Call("freezeMaterials")
}

// GetActiveBones calls the GetActiveBones method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getactivebones
func (s *Scene) GetActiveBones() float64 {

	retVal := s.p.Call("getActiveBones")
	return retVal.Float()
}

// GetActiveIndices calls the GetActiveIndices method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getactiveindices
func (s *Scene) GetActiveIndices() float64 {

	retVal := s.p.Call("getActiveIndices")
	return retVal.Float()
}

// GetActiveMeshes calls the GetActiveMeshes method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getactivemeshes
func (s *Scene) GetActiveMeshes() *SmartArray {

	retVal := s.p.Call("getActiveMeshes")
	return SmartArrayFromJSObject(retVal, s.ctx)
}

// GetActiveParticles calls the GetActiveParticles method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getactiveparticles
func (s *Scene) GetActiveParticles() float64 {

	retVal := s.p.Call("getActiveParticles")
	return retVal.Float()
}

// GetAllAnimatablesByTarget calls the GetAllAnimatablesByTarget method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getallanimatablesbytarget
func (s *Scene) GetAllAnimatablesByTarget(target interface{}) []*Animatable {

	args := make([]interface{}, 0, 1+0)

	args = append(args, target)

	retVal := s.p.Call("getAllAnimatablesByTarget", args...)
	result := []*Animatable{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, AnimatableFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// GetAnimatableByTarget calls the GetAnimatableByTarget method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getanimatablebytarget
func (s *Scene) GetAnimatableByTarget(target interface{}) *Animatable {

	args := make([]interface{}, 0, 1+0)

	args = append(args, target)

	retVal := s.p.Call("getAnimatableByTarget", args...)
	return AnimatableFromJSObject(retVal, s.ctx)
}

// GetAnimationGroupByName calls the GetAnimationGroupByName method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getanimationgroupbyname
func (s *Scene) GetAnimationGroupByName(name string) *AnimationGroup {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := s.p.Call("getAnimationGroupByName", args...)
	return AnimationGroupFromJSObject(retVal, s.ctx)
}

// GetAnimationRatio calls the GetAnimationRatio method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getanimationratio
func (s *Scene) GetAnimationRatio() float64 {

	retVal := s.p.Call("getAnimationRatio")
	return retVal.Float()
}

// GetAutoClearDepthStencilSetup calls the GetAutoClearDepthStencilSetup method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getautocleardepthstencilsetup
func (s *Scene) GetAutoClearDepthStencilSetup(index float64) *IRenderingManagerAutoClearSetup {

	args := make([]interface{}, 0, 1+0)

	args = append(args, index)

	retVal := s.p.Call("getAutoClearDepthStencilSetup", args...)
	return IRenderingManagerAutoClearSetupFromJSObject(retVal, s.ctx)
}

// GetBoneByID calls the GetBoneByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getbonebyid
func (s *Scene) GetBoneByID(id string) *Bone {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getBoneByID", args...)
	return BoneFromJSObject(retVal, s.ctx)
}

// GetBoneByName calls the GetBoneByName method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getbonebyname
func (s *Scene) GetBoneByName(name string) *Bone {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := s.p.Call("getBoneByName", args...)
	return BoneFromJSObject(retVal, s.ctx)
}

// GetBoundingBoxRenderer calls the GetBoundingBoxRenderer method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getboundingboxrenderer
func (s *Scene) GetBoundingBoxRenderer() *BoundingBoxRenderer {

	retVal := s.p.Call("getBoundingBoxRenderer")
	return BoundingBoxRendererFromJSObject(retVal, s.ctx)
}

// GetCachedEffect calls the GetCachedEffect method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getcachedeffect
func (s *Scene) GetCachedEffect() *Effect {

	retVal := s.p.Call("getCachedEffect")
	return EffectFromJSObject(retVal, s.ctx)
}

// GetCachedMaterial calls the GetCachedMaterial method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getcachedmaterial
func (s *Scene) GetCachedMaterial() *Material {

	retVal := s.p.Call("getCachedMaterial")
	return MaterialFromJSObject(retVal, s.ctx)
}

// GetCachedVisibility calls the GetCachedVisibility method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getcachedvisibility
func (s *Scene) GetCachedVisibility() float64 {

	retVal := s.p.Call("getCachedVisibility")
	return retVal.Float()
}

// GetCameraByID calls the GetCameraByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getcamerabyid
func (s *Scene) GetCameraByID(id string) *Camera {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getCameraByID", args...)
	return CameraFromJSObject(retVal, s.ctx)
}

// GetCameraByName calls the GetCameraByName method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getcamerabyname
func (s *Scene) GetCameraByName(name string) *Camera {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := s.p.Call("getCameraByName", args...)
	return CameraFromJSObject(retVal, s.ctx)
}

// GetCameraByUniqueID calls the GetCameraByUniqueID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getcamerabyuniqueid
func (s *Scene) GetCameraByUniqueID(uniqueId float64) *Camera {

	args := make([]interface{}, 0, 1+0)

	args = append(args, uniqueId)

	retVal := s.p.Call("getCameraByUniqueID", args...)
	return CameraFromJSObject(retVal, s.ctx)
}

// SceneGetCamerasByTagsOpts contains optional parameters for Scene.GetCamerasByTags.
type SceneGetCamerasByTagsOpts struct {
	ForEach func()
}

// GetCamerasByTags calls the GetCamerasByTags method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getcamerasbytags
func (s *Scene) GetCamerasByTags(tagsQuery string, opts *SceneGetCamerasByTagsOpts) []*Camera {
	if opts == nil {
		opts = &SceneGetCamerasByTagsOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, tagsQuery)

	if opts.ForEach == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.ForEach(); return nil }) /* never freed! */)
	}

	retVal := s.p.Call("getCamerasByTags", args...)
	result := []*Camera{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, CameraFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// GetClassName calls the GetClassName method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getclassname
func (s *Scene) GetClassName() string {

	retVal := s.p.Call("getClassName")
	return retVal.String()
}

// GetEngine calls the GetEngine method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getengine
func (s *Scene) GetEngine() *Engine {

	retVal := s.p.Call("getEngine")
	return EngineFromJSObject(retVal, s.ctx)
}

// GetFrameId calls the GetFrameId method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getframeid
func (s *Scene) GetFrameId() float64 {

	retVal := s.p.Call("getFrameId")
	return retVal.Float()
}

// GetGeometries calls the GetGeometries method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getgeometries
func (s *Scene) GetGeometries() []*Geometry {

	retVal := s.p.Call("getGeometries")
	result := []*Geometry{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, GeometryFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// GetGeometryByID calls the GetGeometryByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getgeometrybyid
func (s *Scene) GetGeometryByID(id string) *Geometry {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getGeometryByID", args...)
	return GeometryFromJSObject(retVal, s.ctx)
}

// GetInternalStep calls the GetInternalStep method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getinternalstep
func (s *Scene) GetInternalStep() float64 {

	retVal := s.p.Call("getInternalStep")
	return retVal.Float()
}

// GetLastEntryByID calls the GetLastEntryByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getlastentrybyid
func (s *Scene) GetLastEntryByID(id string) *Node {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getLastEntryByID", args...)
	return NodeFromJSObject(retVal, s.ctx)
}

// GetLastMaterialByID calls the GetLastMaterialByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getlastmaterialbyid
func (s *Scene) GetLastMaterialByID(id string) *Material {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getLastMaterialByID", args...)
	return MaterialFromJSObject(retVal, s.ctx)
}

// GetLastMeshByID calls the GetLastMeshByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getlastmeshbyid
func (s *Scene) GetLastMeshByID(id string) *AbstractMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getLastMeshByID", args...)
	return AbstractMeshFromJSObject(retVal, s.ctx)
}

// GetLastSkeletonByID calls the GetLastSkeletonByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getlastskeletonbyid
func (s *Scene) GetLastSkeletonByID(id string) *Skeleton {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getLastSkeletonByID", args...)
	return SkeletonFromJSObject(retVal, s.ctx)
}

// GetLightByID calls the GetLightByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getlightbyid
func (s *Scene) GetLightByID(id string) *Light {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getLightByID", args...)
	return LightFromJSObject(retVal, s.ctx)
}

// GetLightByName calls the GetLightByName method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getlightbyname
func (s *Scene) GetLightByName(name string) *Light {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := s.p.Call("getLightByName", args...)
	return LightFromJSObject(retVal, s.ctx)
}

// GetLightByUniqueID calls the GetLightByUniqueID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getlightbyuniqueid
func (s *Scene) GetLightByUniqueID(uniqueId float64) *Light {

	args := make([]interface{}, 0, 1+0)

	args = append(args, uniqueId)

	retVal := s.p.Call("getLightByUniqueID", args...)
	return LightFromJSObject(retVal, s.ctx)
}

// SceneGetLightsByTagsOpts contains optional parameters for Scene.GetLightsByTags.
type SceneGetLightsByTagsOpts struct {
	ForEach func()
}

// GetLightsByTags calls the GetLightsByTags method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getlightsbytags
func (s *Scene) GetLightsByTags(tagsQuery string, opts *SceneGetLightsByTagsOpts) []*Light {
	if opts == nil {
		opts = &SceneGetLightsByTagsOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, tagsQuery)

	if opts.ForEach == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.ForEach(); return nil }) /* never freed! */)
	}

	retVal := s.p.Call("getLightsByTags", args...)
	result := []*Light{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, LightFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// GetMaterialByID calls the GetMaterialByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getmaterialbyid
func (s *Scene) GetMaterialByID(id string) *Material {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getMaterialByID", args...)
	return MaterialFromJSObject(retVal, s.ctx)
}

// GetMaterialByName calls the GetMaterialByName method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getmaterialbyname
func (s *Scene) GetMaterialByName(name string) *Material {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := s.p.Call("getMaterialByName", args...)
	return MaterialFromJSObject(retVal, s.ctx)
}

// SceneGetMaterialByTagsOpts contains optional parameters for Scene.GetMaterialByTags.
type SceneGetMaterialByTagsOpts struct {
	ForEach func()
}

// GetMaterialByTags calls the GetMaterialByTags method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getmaterialbytags
func (s *Scene) GetMaterialByTags(tagsQuery string, opts *SceneGetMaterialByTagsOpts) []*Material {
	if opts == nil {
		opts = &SceneGetMaterialByTagsOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, tagsQuery)

	if opts.ForEach == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.ForEach(); return nil }) /* never freed! */)
	}

	retVal := s.p.Call("getMaterialByTags", args...)
	result := []*Material{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, MaterialFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// GetMaterialByUniqueID calls the GetMaterialByUniqueID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getmaterialbyuniqueid
func (s *Scene) GetMaterialByUniqueID(uniqueId float64) *Material {

	args := make([]interface{}, 0, 1+0)

	args = append(args, uniqueId)

	retVal := s.p.Call("getMaterialByUniqueID", args...)
	return MaterialFromJSObject(retVal, s.ctx)
}

// GetMeshByID calls the GetMeshByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getmeshbyid
func (s *Scene) GetMeshByID(id string) *AbstractMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getMeshByID", args...)
	return AbstractMeshFromJSObject(retVal, s.ctx)
}

// GetMeshByName calls the GetMeshByName method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getmeshbyname
func (s *Scene) GetMeshByName(name string) *AbstractMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := s.p.Call("getMeshByName", args...)
	return AbstractMeshFromJSObject(retVal, s.ctx)
}

// GetMeshByUniqueID calls the GetMeshByUniqueID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getmeshbyuniqueid
func (s *Scene) GetMeshByUniqueID(uniqueId float64) *AbstractMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, uniqueId)

	retVal := s.p.Call("getMeshByUniqueID", args...)
	return AbstractMeshFromJSObject(retVal, s.ctx)
}

// GetMeshesByID calls the GetMeshesByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getmeshesbyid
func (s *Scene) GetMeshesByID(id string) []*AbstractMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getMeshesByID", args...)
	result := []*AbstractMesh{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, AbstractMeshFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// SceneGetMeshesByTagsOpts contains optional parameters for Scene.GetMeshesByTags.
type SceneGetMeshesByTagsOpts struct {
	ForEach func()
}

// GetMeshesByTags calls the GetMeshesByTags method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getmeshesbytags
func (s *Scene) GetMeshesByTags(tagsQuery string, opts *SceneGetMeshesByTagsOpts) []*Mesh {
	if opts == nil {
		opts = &SceneGetMeshesByTagsOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, tagsQuery)

	if opts.ForEach == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.ForEach(); return nil }) /* never freed! */)
	}

	retVal := s.p.Call("getMeshesByTags", args...)
	result := []*Mesh{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, MeshFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// GetMorphTargetById calls the GetMorphTargetById method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getmorphtargetbyid
func (s *Scene) GetMorphTargetById(id string) *MorphTarget {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getMorphTargetById", args...)
	return MorphTargetFromJSObject(retVal, s.ctx)
}

// GetMorphTargetManagerById calls the GetMorphTargetManagerById method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getmorphtargetmanagerbyid
func (s *Scene) GetMorphTargetManagerById(id float64) *MorphTargetManager {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getMorphTargetManagerById", args...)
	return MorphTargetManagerFromJSObject(retVal, s.ctx)
}

// GetNodeByID calls the GetNodeByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getnodebyid
func (s *Scene) GetNodeByID(id string) *Node {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getNodeByID", args...)
	return NodeFromJSObject(retVal, s.ctx)
}

// GetNodeByName calls the GetNodeByName method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getnodebyname
func (s *Scene) GetNodeByName(name string) *Node {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := s.p.Call("getNodeByName", args...)
	return NodeFromJSObject(retVal, s.ctx)
}

// GetOutlineRenderer calls the GetOutlineRenderer method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getoutlinerenderer
func (s *Scene) GetOutlineRenderer() *OutlineRenderer {

	retVal := s.p.Call("getOutlineRenderer")
	return OutlineRendererFromJSObject(retVal, s.ctx)
}

// GetParticleSystemByID calls the GetParticleSystemByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getparticlesystembyid
func (s *Scene) GetParticleSystemByID(id string) *IParticleSystem {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getParticleSystemByID", args...)
	return IParticleSystemFromJSObject(retVal, s.ctx)
}

// GetPhysicsEngine calls the GetPhysicsEngine method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getphysicsengine
func (s *Scene) GetPhysicsEngine() *IPhysicsEngine {

	retVal := s.p.Call("getPhysicsEngine")
	return IPhysicsEngineFromJSObject(retVal, s.ctx)
}

// GetPointerOverMesh calls the GetPointerOverMesh method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getpointerovermesh
func (s *Scene) GetPointerOverMesh() *AbstractMesh {

	retVal := s.p.Call("getPointerOverMesh")
	return AbstractMeshFromJSObject(retVal, s.ctx)
}

// GetPointerOverSprite calls the GetPointerOverSprite method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getpointeroversprite
func (s *Scene) GetPointerOverSprite() *Sprite {

	retVal := s.p.Call("getPointerOverSprite")
	return SpriteFromJSObject(retVal, s.ctx)
}

// GetProjectionMatrix calls the GetProjectionMatrix method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getprojectionmatrix
func (s *Scene) GetProjectionMatrix() *Matrix {

	retVal := s.p.Call("getProjectionMatrix")
	return MatrixFromJSObject(retVal, s.ctx)
}

// GetRenderId calls the GetRenderId method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getrenderid
func (s *Scene) GetRenderId() float64 {

	retVal := s.p.Call("getRenderId")
	return retVal.Float()
}

// GetSceneUniformBuffer calls the GetSceneUniformBuffer method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getsceneuniformbuffer
func (s *Scene) GetSceneUniformBuffer() *UniformBuffer {

	retVal := s.p.Call("getSceneUniformBuffer")
	return UniformBufferFromJSObject(retVal, s.ctx)
}

// GetSkeletonById calls the GetSkeletonById method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getskeletonbyid
func (s *Scene) GetSkeletonById(id string) *Skeleton {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getSkeletonById", args...)
	return SkeletonFromJSObject(retVal, s.ctx)
}

// GetSkeletonByName calls the GetSkeletonByName method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getskeletonbyname
func (s *Scene) GetSkeletonByName(name string) *Skeleton {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := s.p.Call("getSkeletonByName", args...)
	return SkeletonFromJSObject(retVal, s.ctx)
}

// GetSkeletonByUniqueId calls the GetSkeletonByUniqueId method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getskeletonbyuniqueid
func (s *Scene) GetSkeletonByUniqueId(uniqueId float64) *Skeleton {

	args := make([]interface{}, 0, 1+0)

	args = append(args, uniqueId)

	retVal := s.p.Call("getSkeletonByUniqueId", args...)
	return SkeletonFromJSObject(retVal, s.ctx)
}

// GetSoundByName calls the GetSoundByName method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getsoundbyname
func (s *Scene) GetSoundByName(name string) *Sound {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := s.p.Call("getSoundByName", args...)
	return SoundFromJSObject(retVal, s.ctx)
}

// GetStepId calls the GetStepId method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getstepid
func (s *Scene) GetStepId() float64 {

	retVal := s.p.Call("getStepId")
	return retVal.Float()
}

// GetTextureByUniqueID calls the GetTextureByUniqueID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#gettexturebyuniqueid
func (s *Scene) GetTextureByUniqueID(uniqueId float64) *BaseTexture {

	args := make([]interface{}, 0, 1+0)

	args = append(args, uniqueId)

	retVal := s.p.Call("getTextureByUniqueID", args...)
	return BaseTextureFromJSObject(retVal, s.ctx)
}

// GetTotalVertices calls the GetTotalVertices method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#gettotalvertices
func (s *Scene) GetTotalVertices() float64 {

	retVal := s.p.Call("getTotalVertices")
	return retVal.Float()
}

// GetTransformMatrix calls the GetTransformMatrix method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#gettransformmatrix
func (s *Scene) GetTransformMatrix() *Matrix {

	retVal := s.p.Call("getTransformMatrix")
	return MatrixFromJSObject(retVal, s.ctx)
}

// GetTransformNodeByID calls the GetTransformNodeByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#gettransformnodebyid
func (s *Scene) GetTransformNodeByID(id string) *TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getTransformNodeByID", args...)
	return TransformNodeFromJSObject(retVal, s.ctx)
}

// GetTransformNodeByName calls the GetTransformNodeByName method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#gettransformnodebyname
func (s *Scene) GetTransformNodeByName(name string) *TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := s.p.Call("getTransformNodeByName", args...)
	return TransformNodeFromJSObject(retVal, s.ctx)
}

// GetTransformNodeByUniqueID calls the GetTransformNodeByUniqueID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#gettransformnodebyuniqueid
func (s *Scene) GetTransformNodeByUniqueID(uniqueId float64) *TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, uniqueId)

	retVal := s.p.Call("getTransformNodeByUniqueID", args...)
	return TransformNodeFromJSObject(retVal, s.ctx)
}

// GetTransformNodesByID calls the GetTransformNodesByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#gettransformnodesbyid
func (s *Scene) GetTransformNodesByID(id string) []*TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("getTransformNodesByID", args...)
	result := []*TransformNode{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, TransformNodeFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// GetUniqueId calls the GetUniqueId method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getuniqueid
func (s *Scene) GetUniqueId() float64 {

	retVal := s.p.Call("getUniqueId")
	return retVal.Float()
}

// GetViewMatrix calls the GetViewMatrix method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getviewmatrix
func (s *Scene) GetViewMatrix() *Matrix {

	retVal := s.p.Call("getViewMatrix")
	return MatrixFromJSObject(retVal, s.ctx)
}

// GetWaitingItemsCount calls the GetWaitingItemsCount method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getwaitingitemscount
func (s *Scene) GetWaitingItemsCount() float64 {

	retVal := s.p.Call("getWaitingItemsCount")
	return retVal.Float()
}

// SceneGetWorldExtendsOpts contains optional parameters for Scene.GetWorldExtends.
type SceneGetWorldExtendsOpts struct {
	FilterPredicate func()
}

// GetWorldExtends calls the GetWorldExtends method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getworldextends
func (s *Scene) GetWorldExtends(opts *SceneGetWorldExtendsOpts) js.Value {
	if opts == nil {
		opts = &SceneGetWorldExtendsOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.FilterPredicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.FilterPredicate(); return nil }) /* never freed! */)
	}

	retVal := s.p.Call("getWorldExtends", args...)
	return retVal
}

// IncrementRenderId calls the IncrementRenderId method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#incrementrenderid
func (s *Scene) IncrementRenderId() {

	s.p.Call("incrementRenderId")
}

// IsActiveMesh calls the IsActiveMesh method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#isactivemesh
func (s *Scene) IsActiveMesh(mesh *AbstractMesh) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, mesh.JSObject())

	retVal := s.p.Call("isActiveMesh", args...)
	return retVal.Bool()
}

// SceneIsCachedMaterialInvalidOpts contains optional parameters for Scene.IsCachedMaterialInvalid.
type SceneIsCachedMaterialInvalidOpts struct {
	Visibility *float64
}

// IsCachedMaterialInvalid calls the IsCachedMaterialInvalid method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#iscachedmaterialinvalid
func (s *Scene) IsCachedMaterialInvalid(material *Material, effect *Effect, opts *SceneIsCachedMaterialInvalidOpts) bool {
	if opts == nil {
		opts = &SceneIsCachedMaterialInvalidOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, material.JSObject())
	args = append(args, effect.JSObject())

	if opts.Visibility == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Visibility)
	}

	retVal := s.p.Call("isCachedMaterialInvalid", args...)
	return retVal.Bool()
}

// IsPhysicsEnabled calls the IsPhysicsEnabled method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#isphysicsenabled
func (s *Scene) IsPhysicsEnabled() bool {

	retVal := s.p.Call("isPhysicsEnabled")
	return retVal.Bool()
}

// SceneIsPointerCapturedOpts contains optional parameters for Scene.IsPointerCaptured.
type SceneIsPointerCapturedOpts struct {
	PointerId *float64
}

// IsPointerCaptured calls the IsPointerCaptured method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ispointercaptured
func (s *Scene) IsPointerCaptured(opts *SceneIsPointerCapturedOpts) bool {
	if opts == nil {
		opts = &SceneIsPointerCapturedOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.PointerId == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.PointerId)
	}

	retVal := s.p.Call("isPointerCaptured", args...)
	return retVal.Bool()
}

// IsReady calls the IsReady method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#isready
func (s *Scene) IsReady() bool {

	retVal := s.p.Call("isReady")
	return retVal.Bool()
}

// SceneMarkAllMaterialsAsDirtyOpts contains optional parameters for Scene.MarkAllMaterialsAsDirty.
type SceneMarkAllMaterialsAsDirtyOpts struct {
	Predicate func()
}

// MarkAllMaterialsAsDirty calls the MarkAllMaterialsAsDirty method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#markallmaterialsasdirty
func (s *Scene) MarkAllMaterialsAsDirty(flag float64, opts *SceneMarkAllMaterialsAsDirtyOpts) {
	if opts == nil {
		opts = &SceneMarkAllMaterialsAsDirtyOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, flag)

	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.Predicate(); return nil }) /* never freed! */)
	}

	s.p.Call("markAllMaterialsAsDirty", args...)
}

// SceneMultiPickOpts contains optional parameters for Scene.MultiPick.
type SceneMultiPickOpts struct {
	Predicate         func()
	Camera            *Camera
	TrianglePredicate js.Value
}

// MultiPick calls the MultiPick method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#multipick
func (s *Scene) MultiPick(x float64, y float64, opts *SceneMultiPickOpts) []*PickingInfo {
	if opts == nil {
		opts = &SceneMultiPickOpts{}
	}

	args := make([]interface{}, 0, 2+3)

	args = append(args, x)
	args = append(args, y)

	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.Predicate(); return nil }) /* never freed! */)
	}
	if opts.Camera == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Camera.JSObject())
	}
	args = append(args, opts.TrianglePredicate)

	retVal := s.p.Call("multiPick", args...)
	result := []*PickingInfo{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, PickingInfoFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// SceneMultiPickSpriteOpts contains optional parameters for Scene.MultiPickSprite.
type SceneMultiPickSpriteOpts struct {
	Predicate func()
	Camera    *Camera
}

// MultiPickSprite calls the MultiPickSprite method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#multipicksprite
func (s *Scene) MultiPickSprite(x float64, y float64, opts *SceneMultiPickSpriteOpts) []*PickingInfo {
	if opts == nil {
		opts = &SceneMultiPickSpriteOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, x)
	args = append(args, y)

	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.Predicate(); return nil }) /* never freed! */)
	}
	if opts.Camera == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Camera.JSObject())
	}

	retVal := s.p.Call("multiPickSprite", args...)
	result := []*PickingInfo{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, PickingInfoFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// SceneMultiPickSpriteWithRayOpts contains optional parameters for Scene.MultiPickSpriteWithRay.
type SceneMultiPickSpriteWithRayOpts struct {
	Predicate func()
	Camera    *Camera
}

// MultiPickSpriteWithRay calls the MultiPickSpriteWithRay method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#multipickspritewithray
func (s *Scene) MultiPickSpriteWithRay(ray *Ray, opts *SceneMultiPickSpriteWithRayOpts) []*PickingInfo {
	if opts == nil {
		opts = &SceneMultiPickSpriteWithRayOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, ray.JSObject())

	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.Predicate(); return nil }) /* never freed! */)
	}
	if opts.Camera == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Camera.JSObject())
	}

	retVal := s.p.Call("multiPickSpriteWithRay", args...)
	result := []*PickingInfo{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, PickingInfoFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// SceneMultiPickWithRayOpts contains optional parameters for Scene.MultiPickWithRay.
type SceneMultiPickWithRayOpts struct {
	TrianglePredicate js.Value
}

// MultiPickWithRay calls the MultiPickWithRay method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#multipickwithray
func (s *Scene) MultiPickWithRay(ray *Ray, predicate func(), opts *SceneMultiPickWithRayOpts) []*PickingInfo {
	if opts == nil {
		opts = &SceneMultiPickWithRayOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, ray.JSObject())
	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { predicate(); return nil }))

	args = append(args, opts.TrianglePredicate)

	retVal := s.p.Call("multiPickWithRay", args...)
	result := []*PickingInfo{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, PickingInfoFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// ScenePickOpts contains optional parameters for Scene.Pick.
type ScenePickOpts struct {
	Predicate         func()
	FastCheck         *bool
	Camera            *Camera
	TrianglePredicate js.Value
}

// Pick calls the Pick method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#pick
func (s *Scene) Pick(x float64, y float64, opts *ScenePickOpts) *PickingInfo {
	if opts == nil {
		opts = &ScenePickOpts{}
	}

	args := make([]interface{}, 0, 2+4)

	args = append(args, x)
	args = append(args, y)

	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.Predicate(); return nil }) /* never freed! */)
	}
	if opts.FastCheck == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FastCheck)
	}
	if opts.Camera == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Camera.JSObject())
	}
	args = append(args, opts.TrianglePredicate)

	retVal := s.p.Call("pick", args...)
	return PickingInfoFromJSObject(retVal, s.ctx)
}

// ScenePickSpriteOpts contains optional parameters for Scene.PickSprite.
type ScenePickSpriteOpts struct {
	Predicate func()
	FastCheck *bool
	Camera    *Camera
}

// PickSprite calls the PickSprite method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#picksprite
func (s *Scene) PickSprite(x float64, y float64, opts *ScenePickSpriteOpts) *PickingInfo {
	if opts == nil {
		opts = &ScenePickSpriteOpts{}
	}

	args := make([]interface{}, 0, 2+3)

	args = append(args, x)
	args = append(args, y)

	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.Predicate(); return nil }) /* never freed! */)
	}
	if opts.FastCheck == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FastCheck)
	}
	if opts.Camera == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Camera.JSObject())
	}

	retVal := s.p.Call("pickSprite", args...)
	return PickingInfoFromJSObject(retVal, s.ctx)
}

// ScenePickSpriteWithRayOpts contains optional parameters for Scene.PickSpriteWithRay.
type ScenePickSpriteWithRayOpts struct {
	Predicate func()
	FastCheck *bool
	Camera    *Camera
}

// PickSpriteWithRay calls the PickSpriteWithRay method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#pickspritewithray
func (s *Scene) PickSpriteWithRay(ray *Ray, opts *ScenePickSpriteWithRayOpts) *PickingInfo {
	if opts == nil {
		opts = &ScenePickSpriteWithRayOpts{}
	}

	args := make([]interface{}, 0, 1+3)

	args = append(args, ray.JSObject())

	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.Predicate(); return nil }) /* never freed! */)
	}
	if opts.FastCheck == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FastCheck)
	}
	if opts.Camera == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Camera.JSObject())
	}

	retVal := s.p.Call("pickSpriteWithRay", args...)
	return PickingInfoFromJSObject(retVal, s.ctx)
}

// ScenePickWithRayOpts contains optional parameters for Scene.PickWithRay.
type ScenePickWithRayOpts struct {
	Predicate         func()
	FastCheck         *bool
	TrianglePredicate js.Value
}

// PickWithRay calls the PickWithRay method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#pickwithray
func (s *Scene) PickWithRay(ray *Ray, opts *ScenePickWithRayOpts) *PickingInfo {
	if opts == nil {
		opts = &ScenePickWithRayOpts{}
	}

	args := make([]interface{}, 0, 1+3)

	args = append(args, ray.JSObject())

	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.Predicate(); return nil }) /* never freed! */)
	}
	if opts.FastCheck == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FastCheck)
	}
	args = append(args, opts.TrianglePredicate)

	retVal := s.p.Call("pickWithRay", args...)
	return PickingInfoFromJSObject(retVal, s.ctx)
}

// ScenePushGeometryOpts contains optional parameters for Scene.PushGeometry.
type ScenePushGeometryOpts struct {
	Force *bool
}

// PushGeometry calls the PushGeometry method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#pushgeometry
func (s *Scene) PushGeometry(geometry *Geometry, opts *ScenePushGeometryOpts) bool {
	if opts == nil {
		opts = &ScenePushGeometryOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, geometry.JSObject())

	if opts.Force == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Force)
	}

	retVal := s.p.Call("pushGeometry", args...)
	return retVal.Bool()
}

// RegisterAfterRender calls the RegisterAfterRender method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#registerafterrender
func (s *Scene) RegisterAfterRender(jsFunc func()) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	s.p.Call("registerAfterRender", args...)
}

// RegisterBeforeRender calls the RegisterBeforeRender method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#registerbeforerender
func (s *Scene) RegisterBeforeRender(jsFunc func()) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	s.p.Call("registerBeforeRender", args...)
}

// RemoveActionManager calls the RemoveActionManager method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removeactionmanager
func (s *Scene) RemoveActionManager(toRemove *AbstractActionManager) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, toRemove.JSObject())

	retVal := s.p.Call("removeActionManager", args...)
	return retVal.Float()
}

// RemoveAnimation calls the RemoveAnimation method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removeanimation
func (s *Scene) RemoveAnimation(toRemove *Animation) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, toRemove.JSObject())

	retVal := s.p.Call("removeAnimation", args...)
	return retVal.Float()
}

// RemoveAnimationGroup calls the RemoveAnimationGroup method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removeanimationgroup
func (s *Scene) RemoveAnimationGroup(toRemove *AnimationGroup) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, toRemove.JSObject())

	retVal := s.p.Call("removeAnimationGroup", args...)
	return retVal.Float()
}

// RemoveCamera calls the RemoveCamera method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removecamera
func (s *Scene) RemoveCamera(toRemove *Camera) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, toRemove.JSObject())

	retVal := s.p.Call("removeCamera", args...)
	return retVal.Float()
}

// RemoveExternalData calls the RemoveExternalData method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removeexternaldata
func (s *Scene) RemoveExternalData(key string) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, key)

	retVal := s.p.Call("removeExternalData", args...)
	return retVal.Bool()
}

// RemoveGeometry calls the RemoveGeometry method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removegeometry
func (s *Scene) RemoveGeometry(geometry *Geometry) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, geometry.JSObject())

	retVal := s.p.Call("removeGeometry", args...)
	return retVal.Bool()
}

// RemoveLight calls the RemoveLight method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removelight
func (s *Scene) RemoveLight(toRemove *Light) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, toRemove.JSObject())

	retVal := s.p.Call("removeLight", args...)
	return retVal.Float()
}

// RemoveMaterial calls the RemoveMaterial method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removematerial
func (s *Scene) RemoveMaterial(toRemove *Material) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, toRemove.JSObject())

	retVal := s.p.Call("removeMaterial", args...)
	return retVal.Float()
}

// SceneRemoveMeshOpts contains optional parameters for Scene.RemoveMesh.
type SceneRemoveMeshOpts struct {
	Recursive *bool
}

// RemoveMesh calls the RemoveMesh method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removemesh
func (s *Scene) RemoveMesh(toRemove *AbstractMesh, opts *SceneRemoveMeshOpts) float64 {
	if opts == nil {
		opts = &SceneRemoveMeshOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, toRemove.JSObject())

	if opts.Recursive == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Recursive)
	}

	retVal := s.p.Call("removeMesh", args...)
	return retVal.Float()
}

// RemoveMorphTargetManager calls the RemoveMorphTargetManager method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removemorphtargetmanager
func (s *Scene) RemoveMorphTargetManager(toRemove *MorphTargetManager) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, toRemove.JSObject())

	retVal := s.p.Call("removeMorphTargetManager", args...)
	return retVal.Float()
}

// RemoveMultiMaterial calls the RemoveMultiMaterial method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removemultimaterial
func (s *Scene) RemoveMultiMaterial(toRemove *MultiMaterial) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, toRemove.JSObject())

	retVal := s.p.Call("removeMultiMaterial", args...)
	return retVal.Float()
}

// RemoveParticleSystem calls the RemoveParticleSystem method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removeparticlesystem
func (s *Scene) RemoveParticleSystem(toRemove *IParticleSystem) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, toRemove.JSObject())

	retVal := s.p.Call("removeParticleSystem", args...)
	return retVal.Float()
}

// RemoveSkeleton calls the RemoveSkeleton method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removeskeleton
func (s *Scene) RemoveSkeleton(toRemove *Skeleton) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, toRemove.JSObject())

	retVal := s.p.Call("removeSkeleton", args...)
	return retVal.Float()
}

// RemoveTexture calls the RemoveTexture method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removetexture
func (s *Scene) RemoveTexture(toRemove *BaseTexture) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, toRemove.JSObject())

	retVal := s.p.Call("removeTexture", args...)
	return retVal.Float()
}

// RemoveTransformNode calls the RemoveTransformNode method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#removetransformnode
func (s *Scene) RemoveTransformNode(toRemove *TransformNode) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, toRemove.JSObject())

	retVal := s.p.Call("removeTransformNode", args...)
	return retVal.Float()
}

// SceneRenderOpts contains optional parameters for Scene.Render.
type SceneRenderOpts struct {
	UpdateCameras    *bool
	IgnoreAnimations *bool
}

// Render calls the Render method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#render
func (s *Scene) Render(opts *SceneRenderOpts) {
	if opts == nil {
		opts = &SceneRenderOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.UpdateCameras == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UpdateCameras)
	}
	if opts.IgnoreAnimations == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IgnoreAnimations)
	}

	s.p.Call("render", args...)
}

// ResetCachedMaterial calls the ResetCachedMaterial method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#resetcachedmaterial
func (s *Scene) ResetCachedMaterial() {

	s.p.Call("resetCachedMaterial")
}

// ResetLastAnimationTimeFrame calls the ResetLastAnimationTimeFrame method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#resetlastanimationtimeframe
func (s *Scene) ResetLastAnimationTimeFrame() {

	s.p.Call("resetLastAnimationTimeFrame")
}

// SetActiveCameraByID calls the SetActiveCameraByID method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#setactivecamerabyid
func (s *Scene) SetActiveCameraByID(id string) *Camera {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := s.p.Call("setActiveCameraByID", args...)
	return CameraFromJSObject(retVal, s.ctx)
}

// SetActiveCameraByName calls the SetActiveCameraByName method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#setactivecamerabyname
func (s *Scene) SetActiveCameraByName(name string) *Camera {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := s.p.Call("setActiveCameraByName", args...)
	return CameraFromJSObject(retVal, s.ctx)
}

// SetDefaultCandidateProviders calls the SetDefaultCandidateProviders method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#setdefaultcandidateproviders
func (s *Scene) SetDefaultCandidateProviders() {

	s.p.Call("setDefaultCandidateProviders")
}

// SetPointerOverMesh calls the SetPointerOverMesh method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#setpointerovermesh
func (s *Scene) SetPointerOverMesh(mesh *AbstractMesh) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, mesh.JSObject())

	s.p.Call("setPointerOverMesh", args...)
}

// SetPointerOverSprite calls the SetPointerOverSprite method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#setpointeroversprite
func (s *Scene) SetPointerOverSprite(sprite *Sprite) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, sprite.JSObject())

	s.p.Call("setPointerOverSprite", args...)
}

// SceneSetRenderingAutoClearDepthStencilOpts contains optional parameters for Scene.SetRenderingAutoClearDepthStencil.
type SceneSetRenderingAutoClearDepthStencilOpts struct {
	Depth   *bool
	Stencil *bool
}

// SetRenderingAutoClearDepthStencil calls the SetRenderingAutoClearDepthStencil method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#setrenderingautocleardepthstencil
func (s *Scene) SetRenderingAutoClearDepthStencil(renderingGroupId float64, autoClearDepthStencil bool, opts *SceneSetRenderingAutoClearDepthStencilOpts) {
	if opts == nil {
		opts = &SceneSetRenderingAutoClearDepthStencilOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, renderingGroupId)
	args = append(args, autoClearDepthStencil)

	if opts.Depth == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Depth)
	}
	if opts.Stencil == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Stencil)
	}

	s.p.Call("setRenderingAutoClearDepthStencil", args...)
}

// SceneSetRenderingOrderOpts contains optional parameters for Scene.SetRenderingOrder.
type SceneSetRenderingOrderOpts struct {
	OpaqueSortCompareFn      func()
	AlphaTestSortCompareFn   func()
	TransparentSortCompareFn func()
}

// SetRenderingOrder calls the SetRenderingOrder method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#setrenderingorder
func (s *Scene) SetRenderingOrder(renderingGroupId float64, opts *SceneSetRenderingOrderOpts) {
	if opts == nil {
		opts = &SceneSetRenderingOrderOpts{}
	}

	args := make([]interface{}, 0, 1+3)

	args = append(args, renderingGroupId)

	if opts.OpaqueSortCompareFn == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OpaqueSortCompareFn(); return nil }) /* never freed! */)
	}
	if opts.AlphaTestSortCompareFn == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.AlphaTestSortCompareFn(); return nil }) /* never freed! */)
	}
	if opts.TransparentSortCompareFn == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.TransparentSortCompareFn(); return nil }) /* never freed! */)
	}

	s.p.Call("setRenderingOrder", args...)
}

// SetStepId calls the SetStepId method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#setstepid
func (s *Scene) SetStepId(newStepId float64) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, newStepId)

	s.p.Call("setStepId", args...)
}

// SceneSetTransformMatrixOpts contains optional parameters for Scene.SetTransformMatrix.
type SceneSetTransformMatrixOpts struct {
	ViewR       *Matrix
	ProjectionR *Matrix
}

// SetTransformMatrix calls the SetTransformMatrix method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#settransformmatrix
func (s *Scene) SetTransformMatrix(viewL *Matrix, projectionL *Matrix, opts *SceneSetTransformMatrixOpts) {
	if opts == nil {
		opts = &SceneSetTransformMatrixOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, viewL.JSObject())
	args = append(args, projectionL.JSObject())

	if opts.ViewR == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.ViewR.JSObject())
	}
	if opts.ProjectionR == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.ProjectionR.JSObject())
	}

	s.p.Call("setTransformMatrix", args...)
}

// SceneSimulatePointerDownOpts contains optional parameters for Scene.SimulatePointerDown.
type SceneSimulatePointerDownOpts struct {
	PointerEventInit js.Value
}

// SimulatePointerDown calls the SimulatePointerDown method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#simulatepointerdown
func (s *Scene) SimulatePointerDown(pickResult *PickingInfo, opts *SceneSimulatePointerDownOpts) *Scene {
	if opts == nil {
		opts = &SceneSimulatePointerDownOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, pickResult.JSObject())

	args = append(args, opts.PointerEventInit)

	retVal := s.p.Call("simulatePointerDown", args...)
	return SceneFromJSObject(retVal, s.ctx)
}

// SceneSimulatePointerMoveOpts contains optional parameters for Scene.SimulatePointerMove.
type SceneSimulatePointerMoveOpts struct {
	PointerEventInit js.Value
}

// SimulatePointerMove calls the SimulatePointerMove method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#simulatepointermove
func (s *Scene) SimulatePointerMove(pickResult *PickingInfo, opts *SceneSimulatePointerMoveOpts) *Scene {
	if opts == nil {
		opts = &SceneSimulatePointerMoveOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, pickResult.JSObject())

	args = append(args, opts.PointerEventInit)

	retVal := s.p.Call("simulatePointerMove", args...)
	return SceneFromJSObject(retVal, s.ctx)
}

// SceneSimulatePointerUpOpts contains optional parameters for Scene.SimulatePointerUp.
type SceneSimulatePointerUpOpts struct {
	PointerEventInit js.Value
	DoubleTap        *bool
}

// SimulatePointerUp calls the SimulatePointerUp method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#simulatepointerup
func (s *Scene) SimulatePointerUp(pickResult *PickingInfo, opts *SceneSimulatePointerUpOpts) *Scene {
	if opts == nil {
		opts = &SceneSimulatePointerUpOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, pickResult.JSObject())

	args = append(args, opts.PointerEventInit)
	if opts.DoubleTap == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoubleTap)
	}

	retVal := s.p.Call("simulatePointerUp", args...)
	return SceneFromJSObject(retVal, s.ctx)
}

// SortLightsByPriority calls the SortLightsByPriority method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#sortlightsbypriority
func (s *Scene) SortLightsByPriority() {

	s.p.Call("sortLightsByPriority")
}

// StopAllAnimations calls the StopAllAnimations method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#stopallanimations
func (s *Scene) StopAllAnimations() {

	s.p.Call("stopAllAnimations")
}

// SceneStopAnimationOpts contains optional parameters for Scene.StopAnimation.
type SceneStopAnimationOpts struct {
	AnimationName *string
	TargetMask    func()
}

// StopAnimation calls the StopAnimation method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#stopanimation
func (s *Scene) StopAnimation(target interface{}, opts *SceneStopAnimationOpts) {
	if opts == nil {
		opts = &SceneStopAnimationOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, target)

	if opts.AnimationName == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AnimationName)
	}
	if opts.TargetMask == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.TargetMask(); return nil }) /* never freed! */)
	}

	s.p.Call("stopAnimation", args...)
}

// SceneSwitchActiveCameraOpts contains optional parameters for Scene.SwitchActiveCamera.
type SceneSwitchActiveCameraOpts struct {
	AttachControl *bool
}

// SwitchActiveCamera calls the SwitchActiveCamera method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#switchactivecamera
func (s *Scene) SwitchActiveCamera(newCamera *Camera, opts *SceneSwitchActiveCameraOpts) {
	if opts == nil {
		opts = &SceneSwitchActiveCameraOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, newCamera.JSObject())

	if opts.AttachControl == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AttachControl)
	}

	s.p.Call("switchActiveCamera", args...)
}

// UnfreezeActiveMeshes calls the UnfreezeActiveMeshes method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#unfreezeactivemeshes
func (s *Scene) UnfreezeActiveMeshes() *Scene {

	retVal := s.p.Call("unfreezeActiveMeshes")
	return SceneFromJSObject(retVal, s.ctx)
}

// UnfreezeMaterials calls the UnfreezeMaterials method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#unfreezematerials
func (s *Scene) UnfreezeMaterials() {

	s.p.Call("unfreezeMaterials")
}

// UnregisterAfterRender calls the UnregisterAfterRender method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#unregisterafterrender
func (s *Scene) UnregisterAfterRender(jsFunc func()) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	s.p.Call("unregisterAfterRender", args...)
}

// UnregisterBeforeRender calls the UnregisterBeforeRender method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#unregisterbeforerender
func (s *Scene) UnregisterBeforeRender(jsFunc func()) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	s.p.Call("unregisterBeforeRender", args...)
}

// SceneUpdateTransformMatrixOpts contains optional parameters for Scene.UpdateTransformMatrix.
type SceneUpdateTransformMatrixOpts struct {
	Force *bool
}

// UpdateTransformMatrix calls the UpdateTransformMatrix method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#updatetransformmatrix
func (s *Scene) UpdateTransformMatrix(opts *SceneUpdateTransformMatrixOpts) {
	if opts == nil {
		opts = &SceneUpdateTransformMatrixOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.Force == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Force)
	}

	s.p.Call("updateTransformMatrix", args...)
}

// WhenReadyAsync calls the WhenReadyAsync method on the Scene object.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#whenreadyasync
func (s *Scene) WhenReadyAsync() *Promise {

	retVal := s.p.Call("whenReadyAsync")
	return PromiseFromJSObject(retVal, s.ctx)
}

// ActionManager returns the ActionManager property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#actionmanager
func (s *Scene) ActionManager() *AbstractActionManager {
	retVal := s.p.Get("actionManager")
	return AbstractActionManagerFromJSObject(retVal, s.ctx)
}

// SetActionManager sets the ActionManager property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#actionmanager
func (s *Scene) SetActionManager(actionManager *AbstractActionManager) *Scene {
	s.p.Set("actionManager", actionManager.JSObject())
	return s
}

// ActiveBonesPerfCounter returns the ActiveBonesPerfCounter property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#activebonesperfcounter
func (s *Scene) ActiveBonesPerfCounter() *PerfCounter {
	retVal := s.p.Get("activeBonesPerfCounter")
	return PerfCounterFromJSObject(retVal, s.ctx)
}

// SetActiveBonesPerfCounter sets the ActiveBonesPerfCounter property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#activebonesperfcounter
func (s *Scene) SetActiveBonesPerfCounter(activeBonesPerfCounter *PerfCounter) *Scene {
	s.p.Set("activeBonesPerfCounter", activeBonesPerfCounter.JSObject())
	return s
}

// ActiveCamera returns the ActiveCamera property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#activecamera
func (s *Scene) ActiveCamera() *Camera {
	retVal := s.p.Get("activeCamera")
	return CameraFromJSObject(retVal, s.ctx)
}

// SetActiveCamera sets the ActiveCamera property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#activecamera
func (s *Scene) SetActiveCamera(activeCamera *Camera) *Scene {
	s.p.Set("activeCamera", activeCamera.JSObject())
	return s
}

// ActiveCameras returns the ActiveCameras property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#activecameras
func (s *Scene) ActiveCameras() []*Camera {
	retVal := s.p.Get("activeCameras")
	result := []*Camera{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, CameraFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// SetActiveCameras sets the ActiveCameras property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#activecameras
func (s *Scene) SetActiveCameras(activeCameras []*Camera) *Scene {
	s.p.Set("activeCameras", activeCameras)
	return s
}

// ActiveParticlesPerfCounter returns the ActiveParticlesPerfCounter property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#activeparticlesperfcounter
func (s *Scene) ActiveParticlesPerfCounter() *PerfCounter {
	retVal := s.p.Get("activeParticlesPerfCounter")
	return PerfCounterFromJSObject(retVal, s.ctx)
}

// SetActiveParticlesPerfCounter sets the ActiveParticlesPerfCounter property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#activeparticlesperfcounter
func (s *Scene) SetActiveParticlesPerfCounter(activeParticlesPerfCounter *PerfCounter) *Scene {
	s.p.Set("activeParticlesPerfCounter", activeParticlesPerfCounter.JSObject())
	return s
}

// AfterCameraRender returns the AfterCameraRender property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#aftercamerarender
func (s *Scene) AfterCameraRender() js.Value {
	retVal := s.p.Get("afterCameraRender")
	return retVal
}

// SetAfterCameraRender sets the AfterCameraRender property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#aftercamerarender
func (s *Scene) SetAfterCameraRender(afterCameraRender func()) *Scene {
	s.p.Set("afterCameraRender", js.FuncOf(func(this js.Value, args []js.Value) interface{} { afterCameraRender(); return nil }))
	return s
}

// AfterRender returns the AfterRender property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#afterrender
func (s *Scene) AfterRender() js.Value {
	retVal := s.p.Get("afterRender")
	return retVal
}

// SetAfterRender sets the AfterRender property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#afterrender
func (s *Scene) SetAfterRender(afterRender func()) *Scene {
	s.p.Set("afterRender", js.FuncOf(func(this js.Value, args []js.Value) interface{} { afterRender(); return nil }))
	return s
}

// AmbientColor returns the AmbientColor property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ambientcolor
func (s *Scene) AmbientColor() *Color3 {
	retVal := s.p.Get("ambientColor")
	return Color3FromJSObject(retVal, s.ctx)
}

// SetAmbientColor sets the AmbientColor property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ambientcolor
func (s *Scene) SetAmbientColor(ambientColor *Color3) *Scene {
	s.p.Set("ambientColor", ambientColor.JSObject())
	return s
}

// Animatables returns the Animatables property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#animatables
func (s *Scene) Animatables() []*Animatable {
	retVal := s.p.Get("animatables")
	result := []*Animatable{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, AnimatableFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// SetAnimatables sets the Animatables property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#animatables
func (s *Scene) SetAnimatables(animatables []*Animatable) *Scene {
	s.p.Set("animatables", animatables)
	return s
}

// AnimationPropertiesOverride returns the AnimationPropertiesOverride property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#animationpropertiesoverride
func (s *Scene) AnimationPropertiesOverride() *AnimationPropertiesOverride {
	retVal := s.p.Get("animationPropertiesOverride")
	return AnimationPropertiesOverrideFromJSObject(retVal, s.ctx)
}

// SetAnimationPropertiesOverride sets the AnimationPropertiesOverride property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#animationpropertiesoverride
func (s *Scene) SetAnimationPropertiesOverride(animationPropertiesOverride *AnimationPropertiesOverride) *Scene {
	s.p.Set("animationPropertiesOverride", animationPropertiesOverride.JSObject())
	return s
}

// AnimationTimeScale returns the AnimationTimeScale property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#animationtimescale
func (s *Scene) AnimationTimeScale() float64 {
	retVal := s.p.Get("animationTimeScale")
	return retVal.Float()
}

// SetAnimationTimeScale sets the AnimationTimeScale property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#animationtimescale
func (s *Scene) SetAnimationTimeScale(animationTimeScale float64) *Scene {
	s.p.Set("animationTimeScale", animationTimeScale)
	return s
}

// AnimationsEnabled returns the AnimationsEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#animationsenabled
func (s *Scene) AnimationsEnabled() bool {
	retVal := s.p.Get("animationsEnabled")
	return retVal.Bool()
}

// SetAnimationsEnabled sets the AnimationsEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#animationsenabled
func (s *Scene) SetAnimationsEnabled(animationsEnabled bool) *Scene {
	s.p.Set("animationsEnabled", animationsEnabled)
	return s
}

// AudioEnabled returns the AudioEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#audioenabled
func (s *Scene) AudioEnabled() bool {
	retVal := s.p.Get("audioEnabled")
	return retVal.Bool()
}

// SetAudioEnabled sets the AudioEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#audioenabled
func (s *Scene) SetAudioEnabled(audioEnabled bool) *Scene {
	s.p.Set("audioEnabled", audioEnabled)
	return s
}

// AudioListenerPositionProvider returns the AudioListenerPositionProvider property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#audiolistenerpositionprovider
func (s *Scene) AudioListenerPositionProvider() js.Value {
	retVal := s.p.Get("audioListenerPositionProvider")
	return retVal
}

// SetAudioListenerPositionProvider sets the AudioListenerPositionProvider property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#audiolistenerpositionprovider
func (s *Scene) SetAudioListenerPositionProvider(audioListenerPositionProvider func()) *Scene {
	s.p.Set("audioListenerPositionProvider", js.FuncOf(func(this js.Value, args []js.Value) interface{} { audioListenerPositionProvider(); return nil }))
	return s
}

// AudioPositioningRefreshRate returns the AudioPositioningRefreshRate property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#audiopositioningrefreshrate
func (s *Scene) AudioPositioningRefreshRate() float64 {
	retVal := s.p.Get("audioPositioningRefreshRate")
	return retVal.Float()
}

// SetAudioPositioningRefreshRate sets the AudioPositioningRefreshRate property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#audiopositioningrefreshrate
func (s *Scene) SetAudioPositioningRefreshRate(audioPositioningRefreshRate float64) *Scene {
	s.p.Set("audioPositioningRefreshRate", audioPositioningRefreshRate)
	return s
}

// AutoClear returns the AutoClear property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#autoclear
func (s *Scene) AutoClear() bool {
	retVal := s.p.Get("autoClear")
	return retVal.Bool()
}

// SetAutoClear sets the AutoClear property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#autoclear
func (s *Scene) SetAutoClear(autoClear bool) *Scene {
	s.p.Set("autoClear", autoClear)
	return s
}

// AutoClearDepthAndStencil returns the AutoClearDepthAndStencil property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#autocleardepthandstencil
func (s *Scene) AutoClearDepthAndStencil() bool {
	retVal := s.p.Get("autoClearDepthAndStencil")
	return retVal.Bool()
}

// SetAutoClearDepthAndStencil sets the AutoClearDepthAndStencil property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#autocleardepthandstencil
func (s *Scene) SetAutoClearDepthAndStencil(autoClearDepthAndStencil bool) *Scene {
	s.p.Set("autoClearDepthAndStencil", autoClearDepthAndStencil)
	return s
}

// BeforeCameraRender returns the BeforeCameraRender property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#beforecamerarender
func (s *Scene) BeforeCameraRender() js.Value {
	retVal := s.p.Get("beforeCameraRender")
	return retVal
}

// SetBeforeCameraRender sets the BeforeCameraRender property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#beforecamerarender
func (s *Scene) SetBeforeCameraRender(beforeCameraRender func()) *Scene {
	s.p.Set("beforeCameraRender", js.FuncOf(func(this js.Value, args []js.Value) interface{} { beforeCameraRender(); return nil }))
	return s
}

// BeforeRender returns the BeforeRender property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#beforerender
func (s *Scene) BeforeRender() js.Value {
	retVal := s.p.Get("beforeRender")
	return retVal
}

// SetBeforeRender sets the BeforeRender property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#beforerender
func (s *Scene) SetBeforeRender(beforeRender func()) *Scene {
	s.p.Set("beforeRender", js.FuncOf(func(this js.Value, args []js.Value) interface{} { beforeRender(); return nil }))
	return s
}

// BlockMaterialDirtyMechanism returns the BlockMaterialDirtyMechanism property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#blockmaterialdirtymechanism
func (s *Scene) BlockMaterialDirtyMechanism() bool {
	retVal := s.p.Get("blockMaterialDirtyMechanism")
	return retVal.Bool()
}

// SetBlockMaterialDirtyMechanism sets the BlockMaterialDirtyMechanism property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#blockmaterialdirtymechanism
func (s *Scene) SetBlockMaterialDirtyMechanism(blockMaterialDirtyMechanism bool) *Scene {
	s.p.Set("blockMaterialDirtyMechanism", blockMaterialDirtyMechanism)
	return s
}

// BlockfreeActiveMeshesAndRenderingGroups returns the BlockfreeActiveMeshesAndRenderingGroups property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#blockfreeactivemeshesandrenderinggroups
func (s *Scene) BlockfreeActiveMeshesAndRenderingGroups() bool {
	retVal := s.p.Get("blockfreeActiveMeshesAndRenderingGroups")
	return retVal.Bool()
}

// SetBlockfreeActiveMeshesAndRenderingGroups sets the BlockfreeActiveMeshesAndRenderingGroups property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#blockfreeactivemeshesandrenderinggroups
func (s *Scene) SetBlockfreeActiveMeshesAndRenderingGroups(blockfreeActiveMeshesAndRenderingGroups bool) *Scene {
	s.p.Set("blockfreeActiveMeshesAndRenderingGroups", blockfreeActiveMeshesAndRenderingGroups)
	return s
}

// CameraToUseForPointers returns the CameraToUseForPointers property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#cameratouseforpointers
func (s *Scene) CameraToUseForPointers() *Camera {
	retVal := s.p.Get("cameraToUseForPointers")
	return CameraFromJSObject(retVal, s.ctx)
}

// SetCameraToUseForPointers sets the CameraToUseForPointers property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#cameratouseforpointers
func (s *Scene) SetCameraToUseForPointers(cameraToUseForPointers *Camera) *Scene {
	s.p.Set("cameraToUseForPointers", cameraToUseForPointers.JSObject())
	return s
}

// ClearColor returns the ClearColor property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#clearcolor
func (s *Scene) ClearColor() *Color4 {
	retVal := s.p.Get("clearColor")
	return Color4FromJSObject(retVal, s.ctx)
}

// ClipPlane returns the ClipPlane property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#clipplane
func (s *Scene) ClipPlane() *Plane {
	retVal := s.p.Get("clipPlane")
	return PlaneFromJSObject(retVal, s.ctx)
}

// SetClipPlane sets the ClipPlane property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#clipplane
func (s *Scene) SetClipPlane(clipPlane *Plane) *Scene {
	s.p.Set("clipPlane", clipPlane.JSObject())
	return s
}

// ClipPlane2 returns the ClipPlane2 property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#clipplane2
func (s *Scene) ClipPlane2() *Plane {
	retVal := s.p.Get("clipPlane2")
	return PlaneFromJSObject(retVal, s.ctx)
}

// SetClipPlane2 sets the ClipPlane2 property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#clipplane2
func (s *Scene) SetClipPlane2(clipPlane2 *Plane) *Scene {
	s.p.Set("clipPlane2", clipPlane2.JSObject())
	return s
}

// ClipPlane3 returns the ClipPlane3 property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#clipplane3
func (s *Scene) ClipPlane3() *Plane {
	retVal := s.p.Get("clipPlane3")
	return PlaneFromJSObject(retVal, s.ctx)
}

// SetClipPlane3 sets the ClipPlane3 property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#clipplane3
func (s *Scene) SetClipPlane3(clipPlane3 *Plane) *Scene {
	s.p.Set("clipPlane3", clipPlane3.JSObject())
	return s
}

// ClipPlane4 returns the ClipPlane4 property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#clipplane4
func (s *Scene) ClipPlane4() *Plane {
	retVal := s.p.Get("clipPlane4")
	return PlaneFromJSObject(retVal, s.ctx)
}

// SetClipPlane4 sets the ClipPlane4 property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#clipplane4
func (s *Scene) SetClipPlane4(clipPlane4 *Plane) *Scene {
	s.p.Set("clipPlane4", clipPlane4.JSObject())
	return s
}

// CollisionsEnabled returns the CollisionsEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#collisionsenabled
func (s *Scene) CollisionsEnabled() bool {
	retVal := s.p.Get("collisionsEnabled")
	return retVal.Bool()
}

// SetCollisionsEnabled sets the CollisionsEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#collisionsenabled
func (s *Scene) SetCollisionsEnabled(collisionsEnabled bool) *Scene {
	s.p.Set("collisionsEnabled", collisionsEnabled)
	return s
}

// ConstantlyUpdateMeshUnderPointer returns the ConstantlyUpdateMeshUnderPointer property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#constantlyupdatemeshunderpointer
func (s *Scene) ConstantlyUpdateMeshUnderPointer() bool {
	retVal := s.p.Get("constantlyUpdateMeshUnderPointer")
	return retVal.Bool()
}

// SetConstantlyUpdateMeshUnderPointer sets the ConstantlyUpdateMeshUnderPointer property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#constantlyupdatemeshunderpointer
func (s *Scene) SetConstantlyUpdateMeshUnderPointer(constantlyUpdateMeshUnderPointer bool) *Scene {
	s.p.Set("constantlyUpdateMeshUnderPointer", constantlyUpdateMeshUnderPointer)
	return s
}

// CustomLODSelector returns the CustomLODSelector property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#customlodselector
func (s *Scene) CustomLODSelector() js.Value {
	retVal := s.p.Get("customLODSelector")
	return retVal
}

// SetCustomLODSelector sets the CustomLODSelector property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#customlodselector
func (s *Scene) SetCustomLODSelector(customLODSelector func()) *Scene {
	s.p.Set("customLODSelector", js.FuncOf(func(this js.Value, args []js.Value) interface{} { customLODSelector(); return nil }))
	return s
}

// CustomRenderTargets returns the CustomRenderTargets property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#customrendertargets
func (s *Scene) CustomRenderTargets() []*RenderTargetTexture {
	retVal := s.p.Get("customRenderTargets")
	result := []*RenderTargetTexture{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, RenderTargetTextureFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// SetCustomRenderTargets sets the CustomRenderTargets property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#customrendertargets
func (s *Scene) SetCustomRenderTargets(customRenderTargets []*RenderTargetTexture) *Scene {
	s.p.Set("customRenderTargets", customRenderTargets)
	return s
}

// DebugLayer returns the DebugLayer property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#debuglayer
func (s *Scene) DebugLayer() *DebugLayer {
	retVal := s.p.Get("debugLayer")
	return DebugLayerFromJSObject(retVal, s.ctx)
}

// SetDebugLayer sets the DebugLayer property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#debuglayer
func (s *Scene) SetDebugLayer(debugLayer *DebugLayer) *Scene {
	s.p.Set("debugLayer", debugLayer.JSObject())
	return s
}

// DefaultCursor returns the DefaultCursor property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#defaultcursor
func (s *Scene) DefaultCursor() string {
	retVal := s.p.Get("defaultCursor")
	return retVal.String()
}

// SetDefaultCursor sets the DefaultCursor property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#defaultcursor
func (s *Scene) SetDefaultCursor(defaultCursor string) *Scene {
	s.p.Set("defaultCursor", defaultCursor)
	return s
}

// DefaultMaterial returns the DefaultMaterial property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#defaultmaterial
func (s *Scene) DefaultMaterial() *Material {
	retVal := s.p.Get("defaultMaterial")
	return MaterialFromJSObject(retVal, s.ctx)
}

// SetDefaultMaterial sets the DefaultMaterial property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#defaultmaterial
func (s *Scene) SetDefaultMaterial(defaultMaterial *Material) *Scene {
	s.p.Set("defaultMaterial", defaultMaterial.JSObject())
	return s
}

// DeltaTime returns the DeltaTime property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#deltatime
func (s *Scene) DeltaTime() float64 {
	retVal := s.p.Get("deltaTime")
	return retVal.Float()
}

// SetDeltaTime sets the DeltaTime property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#deltatime
func (s *Scene) SetDeltaTime(deltaTime float64) *Scene {
	s.p.Set("deltaTime", deltaTime)
	return s
}

// DisableOfflineSupportExceptionRules returns the DisableOfflineSupportExceptionRules property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#disableofflinesupportexceptionrules
func (s *Scene) DisableOfflineSupportExceptionRules() js.Value {
	retVal := s.p.Get("disableOfflineSupportExceptionRules")
	return retVal
}

// SetDisableOfflineSupportExceptionRules sets the DisableOfflineSupportExceptionRules property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#disableofflinesupportexceptionrules
func (s *Scene) SetDisableOfflineSupportExceptionRules(disableOfflineSupportExceptionRules js.Value) *Scene {
	s.p.Set("disableOfflineSupportExceptionRules", disableOfflineSupportExceptionRules)
	return s
}

// DispatchAllSubMeshesOfActiveMeshes returns the DispatchAllSubMeshesOfActiveMeshes property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#dispatchallsubmeshesofactivemeshes
func (s *Scene) DispatchAllSubMeshesOfActiveMeshes() bool {
	retVal := s.p.Get("dispatchAllSubMeshesOfActiveMeshes")
	return retVal.Bool()
}

// SetDispatchAllSubMeshesOfActiveMeshes sets the DispatchAllSubMeshesOfActiveMeshes property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#dispatchallsubmeshesofactivemeshes
func (s *Scene) SetDispatchAllSubMeshesOfActiveMeshes(dispatchAllSubMeshesOfActiveMeshes bool) *Scene {
	s.p.Set("dispatchAllSubMeshesOfActiveMeshes", dispatchAllSubMeshesOfActiveMeshes)
	return s
}

// DoNotHandleCursors returns the DoNotHandleCursors property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#donothandlecursors
func (s *Scene) DoNotHandleCursors() bool {
	retVal := s.p.Get("doNotHandleCursors")
	return retVal.Bool()
}

// SetDoNotHandleCursors sets the DoNotHandleCursors property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#donothandlecursors
func (s *Scene) SetDoNotHandleCursors(doNotHandleCursors bool) *Scene {
	s.p.Set("doNotHandleCursors", doNotHandleCursors)
	return s
}

// DoubleClickDelay returns the DoubleClickDelay property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#doubleclickdelay
func (s *Scene) DoubleClickDelay() float64 {
	retVal := s.p.Get("DoubleClickDelay")
	return retVal.Float()
}

// SetDoubleClickDelay sets the DoubleClickDelay property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#doubleclickdelay
func (s *Scene) SetDoubleClickDelay(DoubleClickDelay float64) *Scene {
	s.p.Set("DoubleClickDelay", DoubleClickDelay)
	return s
}

// DragMovementThreshold returns the DragMovementThreshold property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#dragmovementthreshold
func (s *Scene) DragMovementThreshold() float64 {
	retVal := s.p.Get("DragMovementThreshold")
	return retVal.Float()
}

// SetDragMovementThreshold sets the DragMovementThreshold property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#dragmovementthreshold
func (s *Scene) SetDragMovementThreshold(DragMovementThreshold float64) *Scene {
	s.p.Set("DragMovementThreshold", DragMovementThreshold)
	return s
}

// DumpNextRenderTargets returns the DumpNextRenderTargets property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#dumpnextrendertargets
func (s *Scene) DumpNextRenderTargets() bool {
	retVal := s.p.Get("dumpNextRenderTargets")
	return retVal.Bool()
}

// SetDumpNextRenderTargets sets the DumpNextRenderTargets property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#dumpnextrendertargets
func (s *Scene) SetDumpNextRenderTargets(dumpNextRenderTargets bool) *Scene {
	s.p.Set("dumpNextRenderTargets", dumpNextRenderTargets)
	return s
}

// EnvironmentBRDFTexture returns the EnvironmentBRDFTexture property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#environmentbrdftexture
func (s *Scene) EnvironmentBRDFTexture() *BaseTexture {
	retVal := s.p.Get("environmentBRDFTexture")
	return BaseTextureFromJSObject(retVal, s.ctx)
}

// SetEnvironmentBRDFTexture sets the EnvironmentBRDFTexture property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#environmentbrdftexture
func (s *Scene) SetEnvironmentBRDFTexture(environmentBRDFTexture *BaseTexture) *Scene {
	s.p.Set("environmentBRDFTexture", environmentBRDFTexture.JSObject())
	return s
}

// EnvironmentIntensity returns the EnvironmentIntensity property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#environmentintensity
func (s *Scene) EnvironmentIntensity() float64 {
	retVal := s.p.Get("environmentIntensity")
	return retVal.Float()
}

// SetEnvironmentIntensity sets the EnvironmentIntensity property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#environmentintensity
func (s *Scene) SetEnvironmentIntensity(environmentIntensity float64) *Scene {
	s.p.Set("environmentIntensity", environmentIntensity)
	return s
}

// EnvironmentTexture returns the EnvironmentTexture property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#environmenttexture
func (s *Scene) EnvironmentTexture() *BaseTexture {
	retVal := s.p.Get("environmentTexture")
	return BaseTextureFromJSObject(retVal, s.ctx)
}

// SetEnvironmentTexture sets the EnvironmentTexture property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#environmenttexture
func (s *Scene) SetEnvironmentTexture(environmentTexture *BaseTexture) *Scene {
	s.p.Set("environmentTexture", environmentTexture.JSObject())
	return s
}

// ExclusiveDoubleClickMode returns the ExclusiveDoubleClickMode property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#exclusivedoubleclickmode
func (s *Scene) ExclusiveDoubleClickMode() bool {
	retVal := s.p.Get("ExclusiveDoubleClickMode")
	return retVal.Bool()
}

// SetExclusiveDoubleClickMode sets the ExclusiveDoubleClickMode property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#exclusivedoubleclickmode
func (s *Scene) SetExclusiveDoubleClickMode(ExclusiveDoubleClickMode bool) *Scene {
	s.p.Set("ExclusiveDoubleClickMode", ExclusiveDoubleClickMode)
	return s
}

// FOGMODE_EXP returns the FOGMODE_EXP property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogmode_exp
func (s *Scene) FOGMODE_EXP() float64 {
	retVal := s.p.Get("FOGMODE_EXP")
	return retVal.Float()
}

// SetFOGMODE_EXP sets the FOGMODE_EXP property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogmode_exp
func (s *Scene) SetFOGMODE_EXP(FOGMODE_EXP float64) *Scene {
	s.p.Set("FOGMODE_EXP", FOGMODE_EXP)
	return s
}

// FOGMODE_EXP2 returns the FOGMODE_EXP2 property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogmode_exp2
func (s *Scene) FOGMODE_EXP2() float64 {
	retVal := s.p.Get("FOGMODE_EXP2")
	return retVal.Float()
}

// SetFOGMODE_EXP2 sets the FOGMODE_EXP2 property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogmode_exp2
func (s *Scene) SetFOGMODE_EXP2(FOGMODE_EXP2 float64) *Scene {
	s.p.Set("FOGMODE_EXP2", FOGMODE_EXP2)
	return s
}

// FOGMODE_LINEAR returns the FOGMODE_LINEAR property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogmode_linear
func (s *Scene) FOGMODE_LINEAR() float64 {
	retVal := s.p.Get("FOGMODE_LINEAR")
	return retVal.Float()
}

// SetFOGMODE_LINEAR sets the FOGMODE_LINEAR property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogmode_linear
func (s *Scene) SetFOGMODE_LINEAR(FOGMODE_LINEAR float64) *Scene {
	s.p.Set("FOGMODE_LINEAR", FOGMODE_LINEAR)
	return s
}

// FOGMODE_NONE returns the FOGMODE_NONE property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogmode_none
func (s *Scene) FOGMODE_NONE() float64 {
	retVal := s.p.Get("FOGMODE_NONE")
	return retVal.Float()
}

// SetFOGMODE_NONE sets the FOGMODE_NONE property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogmode_none
func (s *Scene) SetFOGMODE_NONE(FOGMODE_NONE float64) *Scene {
	s.p.Set("FOGMODE_NONE", FOGMODE_NONE)
	return s
}

// FogColor returns the FogColor property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogcolor
func (s *Scene) FogColor() *Color3 {
	retVal := s.p.Get("fogColor")
	return Color3FromJSObject(retVal, s.ctx)
}

// SetFogColor sets the FogColor property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogcolor
func (s *Scene) SetFogColor(fogColor *Color3) *Scene {
	s.p.Set("fogColor", fogColor.JSObject())
	return s
}

// FogDensity returns the FogDensity property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogdensity
func (s *Scene) FogDensity() float64 {
	retVal := s.p.Get("fogDensity")
	return retVal.Float()
}

// SetFogDensity sets the FogDensity property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogdensity
func (s *Scene) SetFogDensity(fogDensity float64) *Scene {
	s.p.Set("fogDensity", fogDensity)
	return s
}

// FogEnabled returns the FogEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogenabled
func (s *Scene) FogEnabled() bool {
	retVal := s.p.Get("fogEnabled")
	return retVal.Bool()
}

// SetFogEnabled sets the FogEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogenabled
func (s *Scene) SetFogEnabled(fogEnabled bool) *Scene {
	s.p.Set("fogEnabled", fogEnabled)
	return s
}

// FogEnd returns the FogEnd property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogend
func (s *Scene) FogEnd() float64 {
	retVal := s.p.Get("fogEnd")
	return retVal.Float()
}

// SetFogEnd sets the FogEnd property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogend
func (s *Scene) SetFogEnd(fogEnd float64) *Scene {
	s.p.Set("fogEnd", fogEnd)
	return s
}

// FogMode returns the FogMode property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogmode
func (s *Scene) FogMode() float64 {
	retVal := s.p.Get("fogMode")
	return retVal.Float()
}

// SetFogMode sets the FogMode property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogmode
func (s *Scene) SetFogMode(fogMode float64) *Scene {
	s.p.Set("fogMode", fogMode)
	return s
}

// FogStart returns the FogStart property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogstart
func (s *Scene) FogStart() float64 {
	retVal := s.p.Get("fogStart")
	return retVal.Float()
}

// SetFogStart sets the FogStart property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#fogstart
func (s *Scene) SetFogStart(fogStart float64) *Scene {
	s.p.Set("fogStart", fogStart)
	return s
}

// ForcePointsCloud returns the ForcePointsCloud property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#forcepointscloud
func (s *Scene) ForcePointsCloud() bool {
	retVal := s.p.Get("forcePointsCloud")
	return retVal.Bool()
}

// SetForcePointsCloud sets the ForcePointsCloud property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#forcepointscloud
func (s *Scene) SetForcePointsCloud(forcePointsCloud bool) *Scene {
	s.p.Set("forcePointsCloud", forcePointsCloud)
	return s
}

// ForceShowBoundingBoxes returns the ForceShowBoundingBoxes property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#forceshowboundingboxes
func (s *Scene) ForceShowBoundingBoxes() bool {
	retVal := s.p.Get("forceShowBoundingBoxes")
	return retVal.Bool()
}

// SetForceShowBoundingBoxes sets the ForceShowBoundingBoxes property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#forceshowboundingboxes
func (s *Scene) SetForceShowBoundingBoxes(forceShowBoundingBoxes bool) *Scene {
	s.p.Set("forceShowBoundingBoxes", forceShowBoundingBoxes)
	return s
}

// ForceWireframe returns the ForceWireframe property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#forcewireframe
func (s *Scene) ForceWireframe() bool {
	retVal := s.p.Get("forceWireframe")
	return retVal.Bool()
}

// SetForceWireframe sets the ForceWireframe property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#forcewireframe
func (s *Scene) SetForceWireframe(forceWireframe bool) *Scene {
	s.p.Set("forceWireframe", forceWireframe)
	return s
}

// FrustumPlanes returns the FrustumPlanes property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#frustumplanes
func (s *Scene) FrustumPlanes() []*Plane {
	retVal := s.p.Get("frustumPlanes")
	result := []*Plane{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, PlaneFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// SetFrustumPlanes sets the FrustumPlanes property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#frustumplanes
func (s *Scene) SetFrustumPlanes(frustumPlanes []*Plane) *Scene {
	s.p.Set("frustumPlanes", frustumPlanes)
	return s
}

// GamepadManager returns the GamepadManager property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#gamepadmanager
func (s *Scene) GamepadManager() *GamepadManager {
	retVal := s.p.Get("gamepadManager")
	return GamepadManagerFromJSObject(retVal, s.ctx)
}

// SetGamepadManager sets the GamepadManager property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#gamepadmanager
func (s *Scene) SetGamepadManager(gamepadManager *GamepadManager) *Scene {
	s.p.Set("gamepadManager", gamepadManager.JSObject())
	return s
}

// GeometryBufferRenderer returns the GeometryBufferRenderer property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#geometrybufferrenderer
func (s *Scene) GeometryBufferRenderer() *GeometryBufferRenderer {
	retVal := s.p.Get("geometryBufferRenderer")
	return GeometryBufferRendererFromJSObject(retVal, s.ctx)
}

// SetGeometryBufferRenderer sets the GeometryBufferRenderer property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#geometrybufferrenderer
func (s *Scene) SetGeometryBufferRenderer(geometryBufferRenderer *GeometryBufferRenderer) *Scene {
	s.p.Set("geometryBufferRenderer", geometryBufferRenderer.JSObject())
	return s
}

// GetActiveMeshCandidates returns the GetActiveMeshCandidates property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getactivemeshcandidates
func (s *Scene) GetActiveMeshCandidates() js.Value {
	retVal := s.p.Get("getActiveMeshCandidates")
	return retVal
}

// SetGetActiveMeshCandidates sets the GetActiveMeshCandidates property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getactivemeshcandidates
func (s *Scene) SetGetActiveMeshCandidates(getActiveMeshCandidates func()) *Scene {
	s.p.Set("getActiveMeshCandidates", js.FuncOf(func(this js.Value, args []js.Value) interface{} { getActiveMeshCandidates(); return nil }))
	return s
}

// GetActiveSubMeshCandidates returns the GetActiveSubMeshCandidates property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getactivesubmeshcandidates
func (s *Scene) GetActiveSubMeshCandidates() js.Value {
	retVal := s.p.Get("getActiveSubMeshCandidates")
	return retVal
}

// SetGetActiveSubMeshCandidates sets the GetActiveSubMeshCandidates property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getactivesubmeshcandidates
func (s *Scene) SetGetActiveSubMeshCandidates(getActiveSubMeshCandidates func()) *Scene {
	s.p.Set("getActiveSubMeshCandidates", js.FuncOf(func(this js.Value, args []js.Value) interface{} { getActiveSubMeshCandidates(); return nil }))
	return s
}

// GetCollidingSubMeshCandidates returns the GetCollidingSubMeshCandidates property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getcollidingsubmeshcandidates
func (s *Scene) GetCollidingSubMeshCandidates() js.Value {
	retVal := s.p.Get("getCollidingSubMeshCandidates")
	return retVal
}

// SetGetCollidingSubMeshCandidates sets the GetCollidingSubMeshCandidates property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getcollidingsubmeshcandidates
func (s *Scene) SetGetCollidingSubMeshCandidates(getCollidingSubMeshCandidates func()) *Scene {
	s.p.Set("getCollidingSubMeshCandidates", js.FuncOf(func(this js.Value, args []js.Value) interface{} { getCollidingSubMeshCandidates(); return nil }))
	return s
}

// GetDeterministicFrameTime returns the GetDeterministicFrameTime property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getdeterministicframetime
func (s *Scene) GetDeterministicFrameTime() js.Value {
	retVal := s.p.Get("getDeterministicFrameTime")
	return retVal
}

// SetGetDeterministicFrameTime sets the GetDeterministicFrameTime property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getdeterministicframetime
func (s *Scene) SetGetDeterministicFrameTime(getDeterministicFrameTime func()) *Scene {
	s.p.Set("getDeterministicFrameTime", js.FuncOf(func(this js.Value, args []js.Value) interface{} { getDeterministicFrameTime(); return nil }))
	return s
}

// GetIntersectingSubMeshCandidates returns the GetIntersectingSubMeshCandidates property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getintersectingsubmeshcandidates
func (s *Scene) GetIntersectingSubMeshCandidates() js.Value {
	retVal := s.p.Get("getIntersectingSubMeshCandidates")
	return retVal
}

// SetGetIntersectingSubMeshCandidates sets the GetIntersectingSubMeshCandidates property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#getintersectingsubmeshcandidates
func (s *Scene) SetGetIntersectingSubMeshCandidates(getIntersectingSubMeshCandidates func()) *Scene {
	s.p.Set("getIntersectingSubMeshCandidates", js.FuncOf(func(this js.Value, args []js.Value) interface{} { getIntersectingSubMeshCandidates(); return nil }))
	return s
}

// Gravity returns the Gravity property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#gravity
func (s *Scene) Gravity() *Vector3 {
	retVal := s.p.Get("gravity")
	return Vector3FromJSObject(retVal, s.ctx)
}

// SetGravity sets the Gravity property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#gravity
func (s *Scene) SetGravity(gravity *Vector3) *Scene {
	s.p.Set("gravity", gravity.JSObject())
	return s
}

// Headphone returns the Headphone property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#headphone
func (s *Scene) Headphone() bool {
	retVal := s.p.Get("headphone")
	return retVal.Bool()
}

// SetHeadphone sets the Headphone property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#headphone
func (s *Scene) SetHeadphone(headphone bool) *Scene {
	s.p.Set("headphone", headphone)
	return s
}

// HoverCursor returns the HoverCursor property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#hovercursor
func (s *Scene) HoverCursor() string {
	retVal := s.p.Get("hoverCursor")
	return retVal.String()
}

// SetHoverCursor sets the HoverCursor property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#hovercursor
func (s *Scene) SetHoverCursor(hoverCursor string) *Scene {
	s.p.Set("hoverCursor", hoverCursor)
	return s
}

// ImageProcessingConfiguration returns the ImageProcessingConfiguration property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#imageprocessingconfiguration
func (s *Scene) ImageProcessingConfiguration() *ImageProcessingConfiguration {
	retVal := s.p.Get("imageProcessingConfiguration")
	return ImageProcessingConfigurationFromJSObject(retVal, s.ctx)
}

// SetImageProcessingConfiguration sets the ImageProcessingConfiguration property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#imageprocessingconfiguration
func (s *Scene) SetImageProcessingConfiguration(imageProcessingConfiguration *ImageProcessingConfiguration) *Scene {
	s.p.Set("imageProcessingConfiguration", imageProcessingConfiguration.JSObject())
	return s
}

// ImportedMeshesFiles returns the ImportedMeshesFiles property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#importedmeshesfiles
func (s *Scene) ImportedMeshesFiles() []string {
	retVal := s.p.Get("importedMeshesFiles")
	result := []string{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, retVal.Index(ri).String())
	}
	return result
}

// SetImportedMeshesFiles sets the ImportedMeshesFiles property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#importedmeshesfiles
func (s *Scene) SetImportedMeshesFiles(importedMeshesFiles []string) *Scene {
	s.p.Set("importedMeshesFiles", importedMeshesFiles)
	return s
}

// IsDisposed returns the IsDisposed property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#isdisposed
func (s *Scene) IsDisposed() bool {
	retVal := s.p.Get("isDisposed")
	return retVal.Bool()
}

// SetIsDisposed sets the IsDisposed property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#isdisposed
func (s *Scene) SetIsDisposed(isDisposed bool) *Scene {
	s.p.Set("isDisposed", isDisposed)
	return s
}

// IsLoading returns the IsLoading property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#isloading
func (s *Scene) IsLoading() bool {
	retVal := s.p.Get("isLoading")
	return retVal.Bool()
}

// SetIsLoading sets the IsLoading property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#isloading
func (s *Scene) SetIsLoading(isLoading bool) *Scene {
	s.p.Set("isLoading", isLoading)
	return s
}

// LensFlaresEnabled returns the LensFlaresEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#lensflaresenabled
func (s *Scene) LensFlaresEnabled() bool {
	retVal := s.p.Get("lensFlaresEnabled")
	return retVal.Bool()
}

// SetLensFlaresEnabled sets the LensFlaresEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#lensflaresenabled
func (s *Scene) SetLensFlaresEnabled(lensFlaresEnabled bool) *Scene {
	s.p.Set("lensFlaresEnabled", lensFlaresEnabled)
	return s
}

// LightsEnabled returns the LightsEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#lightsenabled
func (s *Scene) LightsEnabled() bool {
	retVal := s.p.Get("lightsEnabled")
	return retVal.Bool()
}

// SetLightsEnabled sets the LightsEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#lightsenabled
func (s *Scene) SetLightsEnabled(lightsEnabled bool) *Scene {
	s.p.Set("lightsEnabled", lightsEnabled)
	return s
}

// LoadingPluginName returns the LoadingPluginName property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#loadingpluginname
func (s *Scene) LoadingPluginName() string {
	retVal := s.p.Get("loadingPluginName")
	return retVal.String()
}

// SetLoadingPluginName sets the LoadingPluginName property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#loadingpluginname
func (s *Scene) SetLoadingPluginName(loadingPluginName string) *Scene {
	s.p.Set("loadingPluginName", loadingPluginName)
	return s
}

// LongPressDelay returns the LongPressDelay property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#longpressdelay
func (s *Scene) LongPressDelay() float64 {
	retVal := s.p.Get("LongPressDelay")
	return retVal.Float()
}

// SetLongPressDelay sets the LongPressDelay property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#longpressdelay
func (s *Scene) SetLongPressDelay(LongPressDelay float64) *Scene {
	s.p.Set("LongPressDelay", LongPressDelay)
	return s
}

// MainSoundTrack returns the MainSoundTrack property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#mainsoundtrack
func (s *Scene) MainSoundTrack() *SoundTrack {
	retVal := s.p.Get("mainSoundTrack")
	return SoundTrackFromJSObject(retVal, s.ctx)
}

// SetMainSoundTrack sets the MainSoundTrack property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#mainsoundtrack
func (s *Scene) SetMainSoundTrack(mainSoundTrack *SoundTrack) *Scene {
	s.p.Set("mainSoundTrack", mainSoundTrack.JSObject())
	return s
}

// MaxDeltaTime returns the MaxDeltaTime property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#maxdeltatime
func (s *Scene) MaxDeltaTime() float64 {
	retVal := s.p.Get("MaxDeltaTime")
	return retVal.Float()
}

// SetMaxDeltaTime sets the MaxDeltaTime property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#maxdeltatime
func (s *Scene) SetMaxDeltaTime(MaxDeltaTime float64) *Scene {
	s.p.Set("MaxDeltaTime", MaxDeltaTime)
	return s
}

// MeshUnderPointer returns the MeshUnderPointer property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#meshunderpointer
func (s *Scene) MeshUnderPointer() *AbstractMesh {
	retVal := s.p.Get("meshUnderPointer")
	return AbstractMeshFromJSObject(retVal, s.ctx)
}

// SetMeshUnderPointer sets the MeshUnderPointer property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#meshunderpointer
func (s *Scene) SetMeshUnderPointer(meshUnderPointer *AbstractMesh) *Scene {
	s.p.Set("meshUnderPointer", meshUnderPointer.JSObject())
	return s
}

// Metadata returns the Metadata property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#metadata
func (s *Scene) Metadata() interface{} {
	retVal := s.p.Get("metadata")
	return retVal
}

// SetMetadata sets the Metadata property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#metadata
func (s *Scene) SetMetadata(metadata interface{}) *Scene {
	s.p.Set("metadata", metadata)
	return s
}

// MinDeltaTime returns the MinDeltaTime property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#mindeltatime
func (s *Scene) MinDeltaTime() float64 {
	retVal := s.p.Get("MinDeltaTime")
	return retVal.Float()
}

// SetMinDeltaTime sets the MinDeltaTime property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#mindeltatime
func (s *Scene) SetMinDeltaTime(MinDeltaTime float64) *Scene {
	s.p.Set("MinDeltaTime", MinDeltaTime)
	return s
}

// OfflineProvider returns the OfflineProvider property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#offlineprovider
func (s *Scene) OfflineProvider() *IOfflineProvider {
	retVal := s.p.Get("offlineProvider")
	return IOfflineProviderFromJSObject(retVal, s.ctx)
}

// SetOfflineProvider sets the OfflineProvider property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#offlineprovider
func (s *Scene) SetOfflineProvider(offlineProvider *IOfflineProvider) *Scene {
	s.p.Set("offlineProvider", offlineProvider.JSObject())
	return s
}

// OnActiveCameraChanged returns the OnActiveCameraChanged property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onactivecamerachanged
func (s *Scene) OnActiveCameraChanged() *Observable {
	retVal := s.p.Get("onActiveCameraChanged")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnActiveCameraChanged sets the OnActiveCameraChanged property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onactivecamerachanged
func (s *Scene) SetOnActiveCameraChanged(onActiveCameraChanged *Observable) *Scene {
	s.p.Set("onActiveCameraChanged", onActiveCameraChanged.JSObject())
	return s
}

// OnAfterActiveMeshesEvaluationObservable returns the OnAfterActiveMeshesEvaluationObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafteractivemeshesevaluationobservable
func (s *Scene) OnAfterActiveMeshesEvaluationObservable() *Observable {
	retVal := s.p.Get("onAfterActiveMeshesEvaluationObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnAfterActiveMeshesEvaluationObservable sets the OnAfterActiveMeshesEvaluationObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafteractivemeshesevaluationobservable
func (s *Scene) SetOnAfterActiveMeshesEvaluationObservable(onAfterActiveMeshesEvaluationObservable *Observable) *Scene {
	s.p.Set("onAfterActiveMeshesEvaluationObservable", onAfterActiveMeshesEvaluationObservable.JSObject())
	return s
}

// OnAfterAnimationsObservable returns the OnAfterAnimationsObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafteranimationsobservable
func (s *Scene) OnAfterAnimationsObservable() *Observable {
	retVal := s.p.Get("onAfterAnimationsObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnAfterAnimationsObservable sets the OnAfterAnimationsObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafteranimationsobservable
func (s *Scene) SetOnAfterAnimationsObservable(onAfterAnimationsObservable *Observable) *Scene {
	s.p.Set("onAfterAnimationsObservable", onAfterAnimationsObservable.JSObject())
	return s
}

// OnAfterCameraRenderObservable returns the OnAfterCameraRenderObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onaftercamerarenderobservable
func (s *Scene) OnAfterCameraRenderObservable() *Observable {
	retVal := s.p.Get("onAfterCameraRenderObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnAfterCameraRenderObservable sets the OnAfterCameraRenderObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onaftercamerarenderobservable
func (s *Scene) SetOnAfterCameraRenderObservable(onAfterCameraRenderObservable *Observable) *Scene {
	s.p.Set("onAfterCameraRenderObservable", onAfterCameraRenderObservable.JSObject())
	return s
}

// OnAfterDrawPhaseObservable returns the OnAfterDrawPhaseObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterdrawphaseobservable
func (s *Scene) OnAfterDrawPhaseObservable() *Observable {
	retVal := s.p.Get("onAfterDrawPhaseObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnAfterDrawPhaseObservable sets the OnAfterDrawPhaseObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterdrawphaseobservable
func (s *Scene) SetOnAfterDrawPhaseObservable(onAfterDrawPhaseObservable *Observable) *Scene {
	s.p.Set("onAfterDrawPhaseObservable", onAfterDrawPhaseObservable.JSObject())
	return s
}

// OnAfterParticlesRenderingObservable returns the OnAfterParticlesRenderingObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterparticlesrenderingobservable
func (s *Scene) OnAfterParticlesRenderingObservable() *Observable {
	retVal := s.p.Get("onAfterParticlesRenderingObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnAfterParticlesRenderingObservable sets the OnAfterParticlesRenderingObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterparticlesrenderingobservable
func (s *Scene) SetOnAfterParticlesRenderingObservable(onAfterParticlesRenderingObservable *Observable) *Scene {
	s.p.Set("onAfterParticlesRenderingObservable", onAfterParticlesRenderingObservable.JSObject())
	return s
}

// OnAfterPhysicsObservable returns the OnAfterPhysicsObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterphysicsobservable
func (s *Scene) OnAfterPhysicsObservable() *Observable {
	retVal := s.p.Get("onAfterPhysicsObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnAfterPhysicsObservable sets the OnAfterPhysicsObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterphysicsobservable
func (s *Scene) SetOnAfterPhysicsObservable(onAfterPhysicsObservable *Observable) *Scene {
	s.p.Set("onAfterPhysicsObservable", onAfterPhysicsObservable.JSObject())
	return s
}

// OnAfterRenderCameraObservable returns the OnAfterRenderCameraObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterrendercameraobservable
func (s *Scene) OnAfterRenderCameraObservable() *Observable {
	retVal := s.p.Get("onAfterRenderCameraObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnAfterRenderCameraObservable sets the OnAfterRenderCameraObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterrendercameraobservable
func (s *Scene) SetOnAfterRenderCameraObservable(onAfterRenderCameraObservable *Observable) *Scene {
	s.p.Set("onAfterRenderCameraObservable", onAfterRenderCameraObservable.JSObject())
	return s
}

// OnAfterRenderObservable returns the OnAfterRenderObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterrenderobservable
func (s *Scene) OnAfterRenderObservable() *Observable {
	retVal := s.p.Get("onAfterRenderObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnAfterRenderObservable sets the OnAfterRenderObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterrenderobservable
func (s *Scene) SetOnAfterRenderObservable(onAfterRenderObservable *Observable) *Scene {
	s.p.Set("onAfterRenderObservable", onAfterRenderObservable.JSObject())
	return s
}

// OnAfterRenderTargetsRenderObservable returns the OnAfterRenderTargetsRenderObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterrendertargetsrenderobservable
func (s *Scene) OnAfterRenderTargetsRenderObservable() *Observable {
	retVal := s.p.Get("onAfterRenderTargetsRenderObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnAfterRenderTargetsRenderObservable sets the OnAfterRenderTargetsRenderObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterrendertargetsrenderobservable
func (s *Scene) SetOnAfterRenderTargetsRenderObservable(onAfterRenderTargetsRenderObservable *Observable) *Scene {
	s.p.Set("onAfterRenderTargetsRenderObservable", onAfterRenderTargetsRenderObservable.JSObject())
	return s
}

// OnAfterRenderingGroupObservable returns the OnAfterRenderingGroupObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterrenderinggroupobservable
func (s *Scene) OnAfterRenderingGroupObservable() *Observable {
	retVal := s.p.Get("onAfterRenderingGroupObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnAfterRenderingGroupObservable sets the OnAfterRenderingGroupObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterrenderinggroupobservable
func (s *Scene) SetOnAfterRenderingGroupObservable(onAfterRenderingGroupObservable *Observable) *Scene {
	s.p.Set("onAfterRenderingGroupObservable", onAfterRenderingGroupObservable.JSObject())
	return s
}

// OnAfterSpritesRenderingObservable returns the OnAfterSpritesRenderingObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterspritesrenderingobservable
func (s *Scene) OnAfterSpritesRenderingObservable() *Observable {
	retVal := s.p.Get("onAfterSpritesRenderingObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnAfterSpritesRenderingObservable sets the OnAfterSpritesRenderingObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterspritesrenderingobservable
func (s *Scene) SetOnAfterSpritesRenderingObservable(onAfterSpritesRenderingObservable *Observable) *Scene {
	s.p.Set("onAfterSpritesRenderingObservable", onAfterSpritesRenderingObservable.JSObject())
	return s
}

// OnAfterStepObservable returns the OnAfterStepObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterstepobservable
func (s *Scene) OnAfterStepObservable() *Observable {
	retVal := s.p.Get("onAfterStepObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnAfterStepObservable sets the OnAfterStepObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onafterstepobservable
func (s *Scene) SetOnAfterStepObservable(onAfterStepObservable *Observable) *Scene {
	s.p.Set("onAfterStepObservable", onAfterStepObservable.JSObject())
	return s
}

// OnBeforeActiveMeshesEvaluationObservable returns the OnBeforeActiveMeshesEvaluationObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforeactivemeshesevaluationobservable
func (s *Scene) OnBeforeActiveMeshesEvaluationObservable() *Observable {
	retVal := s.p.Get("onBeforeActiveMeshesEvaluationObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnBeforeActiveMeshesEvaluationObservable sets the OnBeforeActiveMeshesEvaluationObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforeactivemeshesevaluationobservable
func (s *Scene) SetOnBeforeActiveMeshesEvaluationObservable(onBeforeActiveMeshesEvaluationObservable *Observable) *Scene {
	s.p.Set("onBeforeActiveMeshesEvaluationObservable", onBeforeActiveMeshesEvaluationObservable.JSObject())
	return s
}

// OnBeforeAnimationsObservable returns the OnBeforeAnimationsObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforeanimationsobservable
func (s *Scene) OnBeforeAnimationsObservable() *Observable {
	retVal := s.p.Get("onBeforeAnimationsObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnBeforeAnimationsObservable sets the OnBeforeAnimationsObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforeanimationsobservable
func (s *Scene) SetOnBeforeAnimationsObservable(onBeforeAnimationsObservable *Observable) *Scene {
	s.p.Set("onBeforeAnimationsObservable", onBeforeAnimationsObservable.JSObject())
	return s
}

// OnBeforeCameraRenderObservable returns the OnBeforeCameraRenderObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforecamerarenderobservable
func (s *Scene) OnBeforeCameraRenderObservable() *Observable {
	retVal := s.p.Get("onBeforeCameraRenderObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnBeforeCameraRenderObservable sets the OnBeforeCameraRenderObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforecamerarenderobservable
func (s *Scene) SetOnBeforeCameraRenderObservable(onBeforeCameraRenderObservable *Observable) *Scene {
	s.p.Set("onBeforeCameraRenderObservable", onBeforeCameraRenderObservable.JSObject())
	return s
}

// OnBeforeDrawPhaseObservable returns the OnBeforeDrawPhaseObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforedrawphaseobservable
func (s *Scene) OnBeforeDrawPhaseObservable() *Observable {
	retVal := s.p.Get("onBeforeDrawPhaseObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnBeforeDrawPhaseObservable sets the OnBeforeDrawPhaseObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforedrawphaseobservable
func (s *Scene) SetOnBeforeDrawPhaseObservable(onBeforeDrawPhaseObservable *Observable) *Scene {
	s.p.Set("onBeforeDrawPhaseObservable", onBeforeDrawPhaseObservable.JSObject())
	return s
}

// OnBeforeParticlesRenderingObservable returns the OnBeforeParticlesRenderingObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforeparticlesrenderingobservable
func (s *Scene) OnBeforeParticlesRenderingObservable() *Observable {
	retVal := s.p.Get("onBeforeParticlesRenderingObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnBeforeParticlesRenderingObservable sets the OnBeforeParticlesRenderingObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforeparticlesrenderingobservable
func (s *Scene) SetOnBeforeParticlesRenderingObservable(onBeforeParticlesRenderingObservable *Observable) *Scene {
	s.p.Set("onBeforeParticlesRenderingObservable", onBeforeParticlesRenderingObservable.JSObject())
	return s
}

// OnBeforePhysicsObservable returns the OnBeforePhysicsObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforephysicsobservable
func (s *Scene) OnBeforePhysicsObservable() *Observable {
	retVal := s.p.Get("onBeforePhysicsObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnBeforePhysicsObservable sets the OnBeforePhysicsObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforephysicsobservable
func (s *Scene) SetOnBeforePhysicsObservable(onBeforePhysicsObservable *Observable) *Scene {
	s.p.Set("onBeforePhysicsObservable", onBeforePhysicsObservable.JSObject())
	return s
}

// OnBeforeRenderObservable returns the OnBeforeRenderObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforerenderobservable
func (s *Scene) OnBeforeRenderObservable() *Observable {
	retVal := s.p.Get("onBeforeRenderObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnBeforeRenderObservable sets the OnBeforeRenderObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforerenderobservable
func (s *Scene) SetOnBeforeRenderObservable(onBeforeRenderObservable *Observable) *Scene {
	s.p.Set("onBeforeRenderObservable", onBeforeRenderObservable.JSObject())
	return s
}

// OnBeforeRenderTargetsRenderObservable returns the OnBeforeRenderTargetsRenderObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforerendertargetsrenderobservable
func (s *Scene) OnBeforeRenderTargetsRenderObservable() *Observable {
	retVal := s.p.Get("onBeforeRenderTargetsRenderObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnBeforeRenderTargetsRenderObservable sets the OnBeforeRenderTargetsRenderObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforerendertargetsrenderobservable
func (s *Scene) SetOnBeforeRenderTargetsRenderObservable(onBeforeRenderTargetsRenderObservable *Observable) *Scene {
	s.p.Set("onBeforeRenderTargetsRenderObservable", onBeforeRenderTargetsRenderObservable.JSObject())
	return s
}

// OnBeforeRenderingGroupObservable returns the OnBeforeRenderingGroupObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforerenderinggroupobservable
func (s *Scene) OnBeforeRenderingGroupObservable() *Observable {
	retVal := s.p.Get("onBeforeRenderingGroupObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnBeforeRenderingGroupObservable sets the OnBeforeRenderingGroupObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforerenderinggroupobservable
func (s *Scene) SetOnBeforeRenderingGroupObservable(onBeforeRenderingGroupObservable *Observable) *Scene {
	s.p.Set("onBeforeRenderingGroupObservable", onBeforeRenderingGroupObservable.JSObject())
	return s
}

// OnBeforeSpritesRenderingObservable returns the OnBeforeSpritesRenderingObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforespritesrenderingobservable
func (s *Scene) OnBeforeSpritesRenderingObservable() *Observable {
	retVal := s.p.Get("onBeforeSpritesRenderingObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnBeforeSpritesRenderingObservable sets the OnBeforeSpritesRenderingObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforespritesrenderingobservable
func (s *Scene) SetOnBeforeSpritesRenderingObservable(onBeforeSpritesRenderingObservable *Observable) *Scene {
	s.p.Set("onBeforeSpritesRenderingObservable", onBeforeSpritesRenderingObservable.JSObject())
	return s
}

// OnBeforeStepObservable returns the OnBeforeStepObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforestepobservable
func (s *Scene) OnBeforeStepObservable() *Observable {
	retVal := s.p.Get("onBeforeStepObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnBeforeStepObservable sets the OnBeforeStepObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onbeforestepobservable
func (s *Scene) SetOnBeforeStepObservable(onBeforeStepObservable *Observable) *Scene {
	s.p.Set("onBeforeStepObservable", onBeforeStepObservable.JSObject())
	return s
}

// OnCameraRemovedObservable returns the OnCameraRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#oncameraremovedobservable
func (s *Scene) OnCameraRemovedObservable() *Observable {
	retVal := s.p.Get("onCameraRemovedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnCameraRemovedObservable sets the OnCameraRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#oncameraremovedobservable
func (s *Scene) SetOnCameraRemovedObservable(onCameraRemovedObservable *Observable) *Scene {
	s.p.Set("onCameraRemovedObservable", onCameraRemovedObservable.JSObject())
	return s
}

// OnDataLoadedObservable returns the OnDataLoadedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ondataloadedobservable
func (s *Scene) OnDataLoadedObservable() *Observable {
	retVal := s.p.Get("onDataLoadedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnDataLoadedObservable sets the OnDataLoadedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ondataloadedobservable
func (s *Scene) SetOnDataLoadedObservable(onDataLoadedObservable *Observable) *Scene {
	s.p.Set("onDataLoadedObservable", onDataLoadedObservable.JSObject())
	return s
}

// OnDispose returns the OnDispose property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ondispose
func (s *Scene) OnDispose() js.Value {
	retVal := s.p.Get("onDispose")
	return retVal
}

// SetOnDispose sets the OnDispose property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ondispose
func (s *Scene) SetOnDispose(onDispose func()) *Scene {
	s.p.Set("onDispose", js.FuncOf(func(this js.Value, args []js.Value) interface{} { onDispose(); return nil }))
	return s
}

// OnDisposeObservable returns the OnDisposeObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ondisposeobservable
func (s *Scene) OnDisposeObservable() *Observable {
	retVal := s.p.Get("onDisposeObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnDisposeObservable sets the OnDisposeObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ondisposeobservable
func (s *Scene) SetOnDisposeObservable(onDisposeObservable *Observable) *Scene {
	s.p.Set("onDisposeObservable", onDisposeObservable.JSObject())
	return s
}

// OnGeometryRemovedObservable returns the OnGeometryRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ongeometryremovedobservable
func (s *Scene) OnGeometryRemovedObservable() *Observable {
	retVal := s.p.Get("onGeometryRemovedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnGeometryRemovedObservable sets the OnGeometryRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ongeometryremovedobservable
func (s *Scene) SetOnGeometryRemovedObservable(onGeometryRemovedObservable *Observable) *Scene {
	s.p.Set("onGeometryRemovedObservable", onGeometryRemovedObservable.JSObject())
	return s
}

// OnKeyboardObservable returns the OnKeyboardObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onkeyboardobservable
func (s *Scene) OnKeyboardObservable() *Observable {
	retVal := s.p.Get("onKeyboardObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnKeyboardObservable sets the OnKeyboardObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onkeyboardobservable
func (s *Scene) SetOnKeyboardObservable(onKeyboardObservable *Observable) *Scene {
	s.p.Set("onKeyboardObservable", onKeyboardObservable.JSObject())
	return s
}

// OnLightRemovedObservable returns the OnLightRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onlightremovedobservable
func (s *Scene) OnLightRemovedObservable() *Observable {
	retVal := s.p.Get("onLightRemovedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnLightRemovedObservable sets the OnLightRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onlightremovedobservable
func (s *Scene) SetOnLightRemovedObservable(onLightRemovedObservable *Observable) *Scene {
	s.p.Set("onLightRemovedObservable", onLightRemovedObservable.JSObject())
	return s
}

// OnMaterialRemovedObservable returns the OnMaterialRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onmaterialremovedobservable
func (s *Scene) OnMaterialRemovedObservable() *Observable {
	retVal := s.p.Get("onMaterialRemovedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnMaterialRemovedObservable sets the OnMaterialRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onmaterialremovedobservable
func (s *Scene) SetOnMaterialRemovedObservable(onMaterialRemovedObservable *Observable) *Scene {
	s.p.Set("onMaterialRemovedObservable", onMaterialRemovedObservable.JSObject())
	return s
}

// OnMeshImportedObservable returns the OnMeshImportedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onmeshimportedobservable
func (s *Scene) OnMeshImportedObservable() *Observable {
	retVal := s.p.Get("onMeshImportedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnMeshImportedObservable sets the OnMeshImportedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onmeshimportedobservable
func (s *Scene) SetOnMeshImportedObservable(onMeshImportedObservable *Observable) *Scene {
	s.p.Set("onMeshImportedObservable", onMeshImportedObservable.JSObject())
	return s
}

// OnMeshRemovedObservable returns the OnMeshRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onmeshremovedobservable
func (s *Scene) OnMeshRemovedObservable() *Observable {
	retVal := s.p.Get("onMeshRemovedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnMeshRemovedObservable sets the OnMeshRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onmeshremovedobservable
func (s *Scene) SetOnMeshRemovedObservable(onMeshRemovedObservable *Observable) *Scene {
	s.p.Set("onMeshRemovedObservable", onMeshRemovedObservable.JSObject())
	return s
}

// OnNewCameraAddedObservable returns the OnNewCameraAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewcameraaddedobservable
func (s *Scene) OnNewCameraAddedObservable() *Observable {
	retVal := s.p.Get("onNewCameraAddedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnNewCameraAddedObservable sets the OnNewCameraAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewcameraaddedobservable
func (s *Scene) SetOnNewCameraAddedObservable(onNewCameraAddedObservable *Observable) *Scene {
	s.p.Set("onNewCameraAddedObservable", onNewCameraAddedObservable.JSObject())
	return s
}

// OnNewGeometryAddedObservable returns the OnNewGeometryAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewgeometryaddedobservable
func (s *Scene) OnNewGeometryAddedObservable() *Observable {
	retVal := s.p.Get("onNewGeometryAddedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnNewGeometryAddedObservable sets the OnNewGeometryAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewgeometryaddedobservable
func (s *Scene) SetOnNewGeometryAddedObservable(onNewGeometryAddedObservable *Observable) *Scene {
	s.p.Set("onNewGeometryAddedObservable", onNewGeometryAddedObservable.JSObject())
	return s
}

// OnNewLightAddedObservable returns the OnNewLightAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewlightaddedobservable
func (s *Scene) OnNewLightAddedObservable() *Observable {
	retVal := s.p.Get("onNewLightAddedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnNewLightAddedObservable sets the OnNewLightAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewlightaddedobservable
func (s *Scene) SetOnNewLightAddedObservable(onNewLightAddedObservable *Observable) *Scene {
	s.p.Set("onNewLightAddedObservable", onNewLightAddedObservable.JSObject())
	return s
}

// OnNewMaterialAddedObservable returns the OnNewMaterialAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewmaterialaddedobservable
func (s *Scene) OnNewMaterialAddedObservable() *Observable {
	retVal := s.p.Get("onNewMaterialAddedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnNewMaterialAddedObservable sets the OnNewMaterialAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewmaterialaddedobservable
func (s *Scene) SetOnNewMaterialAddedObservable(onNewMaterialAddedObservable *Observable) *Scene {
	s.p.Set("onNewMaterialAddedObservable", onNewMaterialAddedObservable.JSObject())
	return s
}

// OnNewMeshAddedObservable returns the OnNewMeshAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewmeshaddedobservable
func (s *Scene) OnNewMeshAddedObservable() *Observable {
	retVal := s.p.Get("onNewMeshAddedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnNewMeshAddedObservable sets the OnNewMeshAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewmeshaddedobservable
func (s *Scene) SetOnNewMeshAddedObservable(onNewMeshAddedObservable *Observable) *Scene {
	s.p.Set("onNewMeshAddedObservable", onNewMeshAddedObservable.JSObject())
	return s
}

// OnNewSkeletonAddedObservable returns the OnNewSkeletonAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewskeletonaddedobservable
func (s *Scene) OnNewSkeletonAddedObservable() *Observable {
	retVal := s.p.Get("onNewSkeletonAddedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnNewSkeletonAddedObservable sets the OnNewSkeletonAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewskeletonaddedobservable
func (s *Scene) SetOnNewSkeletonAddedObservable(onNewSkeletonAddedObservable *Observable) *Scene {
	s.p.Set("onNewSkeletonAddedObservable", onNewSkeletonAddedObservable.JSObject())
	return s
}

// OnNewTextureAddedObservable returns the OnNewTextureAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewtextureaddedobservable
func (s *Scene) OnNewTextureAddedObservable() *Observable {
	retVal := s.p.Get("onNewTextureAddedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnNewTextureAddedObservable sets the OnNewTextureAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewtextureaddedobservable
func (s *Scene) SetOnNewTextureAddedObservable(onNewTextureAddedObservable *Observable) *Scene {
	s.p.Set("onNewTextureAddedObservable", onNewTextureAddedObservable.JSObject())
	return s
}

// OnNewTransformNodeAddedObservable returns the OnNewTransformNodeAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewtransformnodeaddedobservable
func (s *Scene) OnNewTransformNodeAddedObservable() *Observable {
	retVal := s.p.Get("onNewTransformNodeAddedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnNewTransformNodeAddedObservable sets the OnNewTransformNodeAddedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onnewtransformnodeaddedobservable
func (s *Scene) SetOnNewTransformNodeAddedObservable(onNewTransformNodeAddedObservable *Observable) *Scene {
	s.p.Set("onNewTransformNodeAddedObservable", onNewTransformNodeAddedObservable.JSObject())
	return s
}

// OnPointerDown returns the OnPointerDown property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onpointerdown
func (s *Scene) OnPointerDown() js.Value {
	retVal := s.p.Get("onPointerDown")
	return retVal
}

// SetOnPointerDown sets the OnPointerDown property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onpointerdown
func (s *Scene) SetOnPointerDown(onPointerDown func()) *Scene {
	s.p.Set("onPointerDown", js.FuncOf(func(this js.Value, args []js.Value) interface{} { onPointerDown(); return nil }))
	return s
}

// OnPointerMove returns the OnPointerMove property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onpointermove
func (s *Scene) OnPointerMove() js.Value {
	retVal := s.p.Get("onPointerMove")
	return retVal
}

// SetOnPointerMove sets the OnPointerMove property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onpointermove
func (s *Scene) SetOnPointerMove(onPointerMove func()) *Scene {
	s.p.Set("onPointerMove", js.FuncOf(func(this js.Value, args []js.Value) interface{} { onPointerMove(); return nil }))
	return s
}

// OnPointerObservable returns the OnPointerObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onpointerobservable
func (s *Scene) OnPointerObservable() *Observable {
	retVal := s.p.Get("onPointerObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnPointerObservable sets the OnPointerObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onpointerobservable
func (s *Scene) SetOnPointerObservable(onPointerObservable *Observable) *Scene {
	s.p.Set("onPointerObservable", onPointerObservable.JSObject())
	return s
}

// OnPointerPick returns the OnPointerPick property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onpointerpick
func (s *Scene) OnPointerPick() js.Value {
	retVal := s.p.Get("onPointerPick")
	return retVal
}

// SetOnPointerPick sets the OnPointerPick property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onpointerpick
func (s *Scene) SetOnPointerPick(onPointerPick func()) *Scene {
	s.p.Set("onPointerPick", js.FuncOf(func(this js.Value, args []js.Value) interface{} { onPointerPick(); return nil }))
	return s
}

// OnPointerUp returns the OnPointerUp property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onpointerup
func (s *Scene) OnPointerUp() js.Value {
	retVal := s.p.Get("onPointerUp")
	return retVal
}

// SetOnPointerUp sets the OnPointerUp property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onpointerup
func (s *Scene) SetOnPointerUp(onPointerUp func()) *Scene {
	s.p.Set("onPointerUp", js.FuncOf(func(this js.Value, args []js.Value) interface{} { onPointerUp(); return nil }))
	return s
}

// OnPreKeyboardObservable returns the OnPreKeyboardObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onprekeyboardobservable
func (s *Scene) OnPreKeyboardObservable() *Observable {
	retVal := s.p.Get("onPreKeyboardObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnPreKeyboardObservable sets the OnPreKeyboardObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onprekeyboardobservable
func (s *Scene) SetOnPreKeyboardObservable(onPreKeyboardObservable *Observable) *Scene {
	s.p.Set("onPreKeyboardObservable", onPreKeyboardObservable.JSObject())
	return s
}

// OnPrePointerObservable returns the OnPrePointerObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onprepointerobservable
func (s *Scene) OnPrePointerObservable() *Observable {
	retVal := s.p.Get("onPrePointerObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnPrePointerObservable sets the OnPrePointerObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onprepointerobservable
func (s *Scene) SetOnPrePointerObservable(onPrePointerObservable *Observable) *Scene {
	s.p.Set("onPrePointerObservable", onPrePointerObservable.JSObject())
	return s
}

// OnReadyObservable returns the OnReadyObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onreadyobservable
func (s *Scene) OnReadyObservable() *Observable {
	retVal := s.p.Get("onReadyObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnReadyObservable sets the OnReadyObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onreadyobservable
func (s *Scene) SetOnReadyObservable(onReadyObservable *Observable) *Scene {
	s.p.Set("onReadyObservable", onReadyObservable.JSObject())
	return s
}

// OnSkeletonRemovedObservable returns the OnSkeletonRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onskeletonremovedobservable
func (s *Scene) OnSkeletonRemovedObservable() *Observable {
	retVal := s.p.Get("onSkeletonRemovedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnSkeletonRemovedObservable sets the OnSkeletonRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#onskeletonremovedobservable
func (s *Scene) SetOnSkeletonRemovedObservable(onSkeletonRemovedObservable *Observable) *Scene {
	s.p.Set("onSkeletonRemovedObservable", onSkeletonRemovedObservable.JSObject())
	return s
}

// OnTextureRemovedObservable returns the OnTextureRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ontextureremovedobservable
func (s *Scene) OnTextureRemovedObservable() *Observable {
	retVal := s.p.Get("onTextureRemovedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnTextureRemovedObservable sets the OnTextureRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ontextureremovedobservable
func (s *Scene) SetOnTextureRemovedObservable(onTextureRemovedObservable *Observable) *Scene {
	s.p.Set("onTextureRemovedObservable", onTextureRemovedObservable.JSObject())
	return s
}

// OnTransformNodeRemovedObservable returns the OnTransformNodeRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ontransformnoderemovedobservable
func (s *Scene) OnTransformNodeRemovedObservable() *Observable {
	retVal := s.p.Get("onTransformNodeRemovedObservable")
	return ObservableFromJSObject(retVal, s.ctx)
}

// SetOnTransformNodeRemovedObservable sets the OnTransformNodeRemovedObservable property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#ontransformnoderemovedobservable
func (s *Scene) SetOnTransformNodeRemovedObservable(onTransformNodeRemovedObservable *Observable) *Scene {
	s.p.Set("onTransformNodeRemovedObservable", onTransformNodeRemovedObservable.JSObject())
	return s
}

// ParticlesEnabled returns the ParticlesEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#particlesenabled
func (s *Scene) ParticlesEnabled() bool {
	retVal := s.p.Get("particlesEnabled")
	return retVal.Bool()
}

// SetParticlesEnabled sets the ParticlesEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#particlesenabled
func (s *Scene) SetParticlesEnabled(particlesEnabled bool) *Scene {
	s.p.Set("particlesEnabled", particlesEnabled)
	return s
}

// PointerDownPredicate returns the PointerDownPredicate property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#pointerdownpredicate
func (s *Scene) PointerDownPredicate() js.Value {
	retVal := s.p.Get("pointerDownPredicate")
	return retVal
}

// SetPointerDownPredicate sets the PointerDownPredicate property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#pointerdownpredicate
func (s *Scene) SetPointerDownPredicate(pointerDownPredicate func()) *Scene {
	s.p.Set("pointerDownPredicate", js.FuncOf(func(this js.Value, args []js.Value) interface{} { pointerDownPredicate(); return nil }))
	return s
}

// PointerMovePredicate returns the PointerMovePredicate property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#pointermovepredicate
func (s *Scene) PointerMovePredicate() js.Value {
	retVal := s.p.Get("pointerMovePredicate")
	return retVal
}

// SetPointerMovePredicate sets the PointerMovePredicate property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#pointermovepredicate
func (s *Scene) SetPointerMovePredicate(pointerMovePredicate func()) *Scene {
	s.p.Set("pointerMovePredicate", js.FuncOf(func(this js.Value, args []js.Value) interface{} { pointerMovePredicate(); return nil }))
	return s
}

// PointerUpPredicate returns the PointerUpPredicate property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#pointeruppredicate
func (s *Scene) PointerUpPredicate() js.Value {
	retVal := s.p.Get("pointerUpPredicate")
	return retVal
}

// SetPointerUpPredicate sets the PointerUpPredicate property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#pointeruppredicate
func (s *Scene) SetPointerUpPredicate(pointerUpPredicate func()) *Scene {
	s.p.Set("pointerUpPredicate", js.FuncOf(func(this js.Value, args []js.Value) interface{} { pointerUpPredicate(); return nil }))
	return s
}

// PointerX returns the PointerX property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#pointerx
func (s *Scene) PointerX() float64 {
	retVal := s.p.Get("pointerX")
	return retVal.Float()
}

// SetPointerX sets the PointerX property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#pointerx
func (s *Scene) SetPointerX(pointerX float64) *Scene {
	s.p.Set("pointerX", pointerX)
	return s
}

// PointerY returns the PointerY property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#pointery
func (s *Scene) PointerY() float64 {
	retVal := s.p.Get("pointerY")
	return retVal.Float()
}

// SetPointerY sets the PointerY property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#pointery
func (s *Scene) SetPointerY(pointerY float64) *Scene {
	s.p.Set("pointerY", pointerY)
	return s
}

// PostProcessManager returns the PostProcessManager property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#postprocessmanager
func (s *Scene) PostProcessManager() *PostProcessManager {
	retVal := s.p.Get("postProcessManager")
	return PostProcessManagerFromJSObject(retVal, s.ctx)
}

// SetPostProcessManager sets the PostProcessManager property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#postprocessmanager
func (s *Scene) SetPostProcessManager(postProcessManager *PostProcessManager) *Scene {
	s.p.Set("postProcessManager", postProcessManager.JSObject())
	return s
}

// PostProcessRenderPipelineManager returns the PostProcessRenderPipelineManager property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#postprocessrenderpipelinemanager
func (s *Scene) PostProcessRenderPipelineManager() *PostProcessRenderPipelineManager {
	retVal := s.p.Get("postProcessRenderPipelineManager")
	return PostProcessRenderPipelineManagerFromJSObject(retVal, s.ctx)
}

// SetPostProcessRenderPipelineManager sets the PostProcessRenderPipelineManager property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#postprocessrenderpipelinemanager
func (s *Scene) SetPostProcessRenderPipelineManager(postProcessRenderPipelineManager *PostProcessRenderPipelineManager) *Scene {
	s.p.Set("postProcessRenderPipelineManager", postProcessRenderPipelineManager.JSObject())
	return s
}

// PostProcesses returns the PostProcesses property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#postprocesses
func (s *Scene) PostProcesses() []*PostProcess {
	retVal := s.p.Get("postProcesses")
	result := []*PostProcess{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, PostProcessFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// SetPostProcesses sets the PostProcesses property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#postprocesses
func (s *Scene) SetPostProcesses(postProcesses []*PostProcess) *Scene {
	s.p.Set("postProcesses", postProcesses)
	return s
}

// PostProcessesEnabled returns the PostProcessesEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#postprocessesenabled
func (s *Scene) PostProcessesEnabled() bool {
	retVal := s.p.Get("postProcessesEnabled")
	return retVal.Bool()
}

// SetPostProcessesEnabled sets the PostProcessesEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#postprocessesenabled
func (s *Scene) SetPostProcessesEnabled(postProcessesEnabled bool) *Scene {
	s.p.Set("postProcessesEnabled", postProcessesEnabled)
	return s
}

// PreventDefaultOnPointerDown returns the PreventDefaultOnPointerDown property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#preventdefaultonpointerdown
func (s *Scene) PreventDefaultOnPointerDown() bool {
	retVal := s.p.Get("preventDefaultOnPointerDown")
	return retVal.Bool()
}

// SetPreventDefaultOnPointerDown sets the PreventDefaultOnPointerDown property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#preventdefaultonpointerdown
func (s *Scene) SetPreventDefaultOnPointerDown(preventDefaultOnPointerDown bool) *Scene {
	s.p.Set("preventDefaultOnPointerDown", preventDefaultOnPointerDown)
	return s
}

// PreventDefaultOnPointerUp returns the PreventDefaultOnPointerUp property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#preventdefaultonpointerup
func (s *Scene) PreventDefaultOnPointerUp() bool {
	retVal := s.p.Get("preventDefaultOnPointerUp")
	return retVal.Bool()
}

// SetPreventDefaultOnPointerUp sets the PreventDefaultOnPointerUp property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#preventdefaultonpointerup
func (s *Scene) SetPreventDefaultOnPointerUp(preventDefaultOnPointerUp bool) *Scene {
	s.p.Set("preventDefaultOnPointerUp", preventDefaultOnPointerUp)
	return s
}

// ProbesEnabled returns the ProbesEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#probesenabled
func (s *Scene) ProbesEnabled() bool {
	retVal := s.p.Get("probesEnabled")
	return retVal.Bool()
}

// SetProbesEnabled sets the ProbesEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#probesenabled
func (s *Scene) SetProbesEnabled(probesEnabled bool) *Scene {
	s.p.Set("probesEnabled", probesEnabled)
	return s
}

// ProceduralTexturesEnabled returns the ProceduralTexturesEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#proceduraltexturesenabled
func (s *Scene) ProceduralTexturesEnabled() bool {
	retVal := s.p.Get("proceduralTexturesEnabled")
	return retVal.Bool()
}

// SetProceduralTexturesEnabled sets the ProceduralTexturesEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#proceduraltexturesenabled
func (s *Scene) SetProceduralTexturesEnabled(proceduralTexturesEnabled bool) *Scene {
	s.p.Set("proceduralTexturesEnabled", proceduralTexturesEnabled)
	return s
}

// RenderTargetsEnabled returns the RenderTargetsEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#rendertargetsenabled
func (s *Scene) RenderTargetsEnabled() bool {
	retVal := s.p.Get("renderTargetsEnabled")
	return retVal.Bool()
}

// SetRenderTargetsEnabled sets the RenderTargetsEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#rendertargetsenabled
func (s *Scene) SetRenderTargetsEnabled(renderTargetsEnabled bool) *Scene {
	s.p.Set("renderTargetsEnabled", renderTargetsEnabled)
	return s
}

// RequireLightSorting returns the RequireLightSorting property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#requirelightsorting
func (s *Scene) RequireLightSorting() bool {
	retVal := s.p.Get("requireLightSorting")
	return retVal.Bool()
}

// SetRequireLightSorting sets the RequireLightSorting property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#requirelightsorting
func (s *Scene) SetRequireLightSorting(requireLightSorting bool) *Scene {
	s.p.Set("requireLightSorting", requireLightSorting)
	return s
}

// ReservedDataStore returns the ReservedDataStore property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#reserveddatastore
func (s *Scene) ReservedDataStore() interface{} {
	retVal := s.p.Get("reservedDataStore")
	return retVal
}

// SetReservedDataStore sets the ReservedDataStore property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#reserveddatastore
func (s *Scene) SetReservedDataStore(reservedDataStore interface{}) *Scene {
	s.p.Set("reservedDataStore", reservedDataStore)
	return s
}

// SelectionOctree returns the SelectionOctree property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#selectionoctree
func (s *Scene) SelectionOctree() *Octree {
	retVal := s.p.Get("selectionOctree")
	return OctreeFromJSObject(retVal, s.ctx)
}

// SetSelectionOctree sets the SelectionOctree property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#selectionoctree
func (s *Scene) SetSelectionOctree(selectionOctree *Octree) *Scene {
	s.p.Set("selectionOctree", selectionOctree.JSObject())
	return s
}

// ShadowsEnabled returns the ShadowsEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#shadowsenabled
func (s *Scene) ShadowsEnabled() bool {
	retVal := s.p.Get("shadowsEnabled")
	return retVal.Bool()
}

// SetShadowsEnabled sets the ShadowsEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#shadowsenabled
func (s *Scene) SetShadowsEnabled(shadowsEnabled bool) *Scene {
	s.p.Set("shadowsEnabled", shadowsEnabled)
	return s
}

// SimplificationQueue returns the SimplificationQueue property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#simplificationqueue
func (s *Scene) SimplificationQueue() *SimplificationQueue {
	retVal := s.p.Get("simplificationQueue")
	return SimplificationQueueFromJSObject(retVal, s.ctx)
}

// SetSimplificationQueue sets the SimplificationQueue property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#simplificationqueue
func (s *Scene) SetSimplificationQueue(simplificationQueue *SimplificationQueue) *Scene {
	s.p.Set("simplificationQueue", simplificationQueue.JSObject())
	return s
}

// SkeletonsEnabled returns the SkeletonsEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#skeletonsenabled
func (s *Scene) SkeletonsEnabled() bool {
	retVal := s.p.Get("skeletonsEnabled")
	return retVal.Bool()
}

// SetSkeletonsEnabled sets the SkeletonsEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#skeletonsenabled
func (s *Scene) SetSkeletonsEnabled(skeletonsEnabled bool) *Scene {
	s.p.Set("skeletonsEnabled", skeletonsEnabled)
	return s
}

// SoundTracks returns the SoundTracks property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#soundtracks
func (s *Scene) SoundTracks() []*SoundTrack {
	retVal := s.p.Get("soundTracks")
	result := []*SoundTrack{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, SoundTrackFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// SetSoundTracks sets the SoundTracks property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#soundtracks
func (s *Scene) SetSoundTracks(soundTracks []*SoundTrack) *Scene {
	s.p.Set("soundTracks", soundTracks)
	return s
}

// SpriteManagers returns the SpriteManagers property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#spritemanagers
func (s *Scene) SpriteManagers() []*ISpriteManager {
	retVal := s.p.Get("spriteManagers")
	result := []*ISpriteManager{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, ISpriteManagerFromJSObject(retVal.Index(ri), s.ctx))
	}
	return result
}

// SetSpriteManagers sets the SpriteManagers property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#spritemanagers
func (s *Scene) SetSpriteManagers(spriteManagers []*ISpriteManager) *Scene {
	s.p.Set("spriteManagers", spriteManagers)
	return s
}

// SpritesEnabled returns the SpritesEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#spritesenabled
func (s *Scene) SpritesEnabled() bool {
	retVal := s.p.Get("spritesEnabled")
	return retVal.Bool()
}

// SetSpritesEnabled sets the SpritesEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#spritesenabled
func (s *Scene) SetSpritesEnabled(spritesEnabled bool) *Scene {
	s.p.Set("spritesEnabled", spritesEnabled)
	return s
}

// TexturesEnabled returns the TexturesEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#texturesenabled
func (s *Scene) TexturesEnabled() bool {
	retVal := s.p.Get("texturesEnabled")
	return retVal.Bool()
}

// SetTexturesEnabled sets the TexturesEnabled property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#texturesenabled
func (s *Scene) SetTexturesEnabled(texturesEnabled bool) *Scene {
	s.p.Set("texturesEnabled", texturesEnabled)
	return s
}

// TotalActiveIndicesPerfCounter returns the TotalActiveIndicesPerfCounter property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#totalactiveindicesperfcounter
func (s *Scene) TotalActiveIndicesPerfCounter() *PerfCounter {
	retVal := s.p.Get("totalActiveIndicesPerfCounter")
	return PerfCounterFromJSObject(retVal, s.ctx)
}

// SetTotalActiveIndicesPerfCounter sets the TotalActiveIndicesPerfCounter property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#totalactiveindicesperfcounter
func (s *Scene) SetTotalActiveIndicesPerfCounter(totalActiveIndicesPerfCounter *PerfCounter) *Scene {
	s.p.Set("totalActiveIndicesPerfCounter", totalActiveIndicesPerfCounter.JSObject())
	return s
}

// TotalVerticesPerfCounter returns the TotalVerticesPerfCounter property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#totalverticesperfcounter
func (s *Scene) TotalVerticesPerfCounter() *PerfCounter {
	retVal := s.p.Get("totalVerticesPerfCounter")
	return PerfCounterFromJSObject(retVal, s.ctx)
}

// SetTotalVerticesPerfCounter sets the TotalVerticesPerfCounter property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#totalverticesperfcounter
func (s *Scene) SetTotalVerticesPerfCounter(totalVerticesPerfCounter *PerfCounter) *Scene {
	s.p.Set("totalVerticesPerfCounter", totalVerticesPerfCounter.JSObject())
	return s
}

// Uid returns the Uid property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#uid
func (s *Scene) Uid() string {
	retVal := s.p.Get("uid")
	return retVal.String()
}

// SetUid sets the Uid property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#uid
func (s *Scene) SetUid(uid string) *Scene {
	s.p.Set("uid", uid)
	return s
}

// UnTranslatedPointer returns the UnTranslatedPointer property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#untranslatedpointer
func (s *Scene) UnTranslatedPointer() *Vector2 {
	retVal := s.p.Get("unTranslatedPointer")
	return Vector2FromJSObject(retVal, s.ctx)
}

// SetUnTranslatedPointer sets the UnTranslatedPointer property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#untranslatedpointer
func (s *Scene) SetUnTranslatedPointer(unTranslatedPointer *Vector2) *Scene {
	s.p.Set("unTranslatedPointer", unTranslatedPointer.JSObject())
	return s
}

// UseConstantAnimationDeltaTime returns the UseConstantAnimationDeltaTime property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#useconstantanimationdeltatime
func (s *Scene) UseConstantAnimationDeltaTime() bool {
	retVal := s.p.Get("useConstantAnimationDeltaTime")
	return retVal.Bool()
}

// SetUseConstantAnimationDeltaTime sets the UseConstantAnimationDeltaTime property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#useconstantanimationdeltatime
func (s *Scene) SetUseConstantAnimationDeltaTime(useConstantAnimationDeltaTime bool) *Scene {
	s.p.Set("useConstantAnimationDeltaTime", useConstantAnimationDeltaTime)
	return s
}

// UseDelayedTextureLoading returns the UseDelayedTextureLoading property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#usedelayedtextureloading
func (s *Scene) UseDelayedTextureLoading() bool {
	retVal := s.p.Get("useDelayedTextureLoading")
	return retVal.Bool()
}

// SetUseDelayedTextureLoading sets the UseDelayedTextureLoading property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#usedelayedtextureloading
func (s *Scene) SetUseDelayedTextureLoading(useDelayedTextureLoading bool) *Scene {
	s.p.Set("useDelayedTextureLoading", useDelayedTextureLoading)
	return s
}

// UseRightHandedSystem returns the UseRightHandedSystem property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#userighthandedsystem
func (s *Scene) UseRightHandedSystem() bool {
	retVal := s.p.Get("useRightHandedSystem")
	return retVal.Bool()
}

// SetUseRightHandedSystem sets the UseRightHandedSystem property of class Scene.
//
// https://doc.babylonjs.com/api/classes/babylon.scene#userighthandedsystem
func (s *Scene) SetUseRightHandedSystem(useRightHandedSystem bool) *Scene {
	s.p.Set("useRightHandedSystem", useRightHandedSystem)
	return s
}

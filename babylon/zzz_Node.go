// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// Node represents a babylon.js Node.
// Node is the basic class for all scene objects (Mesh, Light, Camera.)
type Node struct {
	p   js.Value
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (n *Node) JSObject() js.Value { return n.p }

// Node returns a Node JavaScript class.
func (ba *Babylon) Node() *Node {
	p := ba.ctx.Get("Node")
	return NodeFromJSObject(p, ba.ctx)
}

// NodeFromJSObject returns a wrapped Node JavaScript class.
func NodeFromJSObject(p js.Value, ctx js.Value) *Node {
	return &Node{p: p, ctx: ctx}
}

// NodeArrayToJSArray returns a JavaScript Array for the wrapped array.
func NodeArrayToJSArray(array []*Node) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewNodeOpts contains optional parameters for NewNode.
type NewNodeOpts struct {
	Scene *Scene
}

// NewNode returns a new Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node
func (ba *Babylon) NewNode(name string, opts *NewNodeOpts) *Node {
	if opts == nil {
		opts = &NewNodeOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, name)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}

	p := ba.ctx.Get("Node").New(args...)
	return NodeFromJSObject(p, ba.ctx)
}

// NodeAddBehaviorOpts contains optional parameters for Node.AddBehavior.
type NodeAddBehaviorOpts struct {
	AttachImmediately *bool
}

// AddBehavior calls the AddBehavior method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#addbehavior
func (n *Node) AddBehavior(behavior js.Value, opts *NodeAddBehaviorOpts) *Node {
	if opts == nil {
		opts = &NodeAddBehaviorOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, behavior)

	if opts.AttachImmediately == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AttachImmediately)
	}

	retVal := n.p.Call("addBehavior", args...)
	return NodeFromJSObject(retVal, n.ctx)
}

// AddNodeConstructor calls the AddNodeConstructor method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#addnodeconstructor
func (n *Node) AddNodeConstructor(jsType string, constructorFunc js.Value) {

	args := make([]interface{}, 0, 2+0)

	args = append(args, jsType)
	args = append(args, constructorFunc)

	n.p.Call("AddNodeConstructor", args...)
}

// NodeBeginAnimationOpts contains optional parameters for Node.BeginAnimation.
type NodeBeginAnimationOpts struct {
	Loop           *bool
	SpeedRatio     *float64
	OnAnimationEnd JSFunc
}

// BeginAnimation calls the BeginAnimation method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#beginanimation
func (n *Node) BeginAnimation(name string, opts *NodeBeginAnimationOpts) *Animatable {
	if opts == nil {
		opts = &NodeBeginAnimationOpts{}
	}

	args := make([]interface{}, 0, 1+3)

	args = append(args, name)

	if opts.Loop == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Loop)
	}
	if opts.SpeedRatio == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SpeedRatio)
	}
	if opts.OnAnimationEnd == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(opts.OnAnimationEnd) /* never freed! */)
	}

	retVal := n.p.Call("beginAnimation", args...)
	return AnimatableFromJSObject(retVal, n.ctx)
}

// NodeComputeWorldMatrixOpts contains optional parameters for Node.ComputeWorldMatrix.
type NodeComputeWorldMatrixOpts struct {
	Force *bool
}

// ComputeWorldMatrix calls the ComputeWorldMatrix method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#computeworldmatrix
func (n *Node) ComputeWorldMatrix(opts *NodeComputeWorldMatrixOpts) *Matrix {
	if opts == nil {
		opts = &NodeComputeWorldMatrixOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.Force == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Force)
	}

	retVal := n.p.Call("computeWorldMatrix", args...)
	return MatrixFromJSObject(retVal, n.ctx)
}

// NodeConstructOpts contains optional parameters for Node.Construct.
type NodeConstructOpts struct {
	Options *interface{}
}

// Construct calls the Construct method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#construct
func (n *Node) Construct(jsType string, name string, scene *Scene, opts *NodeConstructOpts) js.Value {
	if opts == nil {
		opts = &NodeConstructOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	args = append(args, jsType)
	args = append(args, name)
	args = append(args, scene.JSObject())

	if opts.Options == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Options)
	}

	retVal := n.p.Call("Construct", args...)
	return retVal
}

// CreateAnimationRange calls the CreateAnimationRange method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#createanimationrange
func (n *Node) CreateAnimationRange(name string, from float64, to float64) {

	args := make([]interface{}, 0, 3+0)

	args = append(args, name)
	args = append(args, from)
	args = append(args, to)

	n.p.Call("createAnimationRange", args...)
}

// NodeDeleteAnimationRangeOpts contains optional parameters for Node.DeleteAnimationRange.
type NodeDeleteAnimationRangeOpts struct {
	DeleteFrames *bool
}

// DeleteAnimationRange calls the DeleteAnimationRange method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#deleteanimationrange
func (n *Node) DeleteAnimationRange(name string, opts *NodeDeleteAnimationRangeOpts) {
	if opts == nil {
		opts = &NodeDeleteAnimationRangeOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, name)

	if opts.DeleteFrames == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DeleteFrames)
	}

	n.p.Call("deleteAnimationRange", args...)
}

// NodeDisposeOpts contains optional parameters for Node.Dispose.
type NodeDisposeOpts struct {
	DoNotRecurse               *bool
	DisposeMaterialAndTextures *bool
}

// Dispose calls the Dispose method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#dispose
func (n *Node) Dispose(opts *NodeDisposeOpts) {
	if opts == nil {
		opts = &NodeDisposeOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.DoNotRecurse == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotRecurse)
	}
	if opts.DisposeMaterialAndTextures == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DisposeMaterialAndTextures)
	}

	n.p.Call("dispose", args...)
}

// GetAnimationByName calls the GetAnimationByName method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#getanimationbyname
func (n *Node) GetAnimationByName(name string) *Animation {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := n.p.Call("getAnimationByName", args...)
	return AnimationFromJSObject(retVal, n.ctx)
}

// GetAnimationRange calls the GetAnimationRange method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#getanimationrange
func (n *Node) GetAnimationRange(name string) *AnimationRange {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := n.p.Call("getAnimationRange", args...)
	return AnimationRangeFromJSObject(retVal, n.ctx)
}

// GetAnimationRanges calls the GetAnimationRanges method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#getanimationranges
func (n *Node) GetAnimationRanges() []*AnimationRange {

	retVal := n.p.Call("getAnimationRanges")
	result := []*AnimationRange{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, AnimationRangeFromJSObject(retVal.Index(ri), n.ctx))
	}
	return result
}

// GetBehaviorByName calls the GetBehaviorByName method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#getbehaviorbyname
func (n *Node) GetBehaviorByName(name string) js.Value {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := n.p.Call("getBehaviorByName", args...)
	return retVal
}

// NodeGetChildMeshesOpts contains optional parameters for Node.GetChildMeshes.
type NodeGetChildMeshesOpts struct {
	DirectDescendantsOnly *bool
	Predicate             JSFunc
}

// GetChildMeshes calls the GetChildMeshes method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#getchildmeshes
func (n *Node) GetChildMeshes(opts *NodeGetChildMeshesOpts) []*AbstractMesh {
	if opts == nil {
		opts = &NodeGetChildMeshesOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.DirectDescendantsOnly == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DirectDescendantsOnly)
	}
	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(opts.Predicate) /* never freed! */)
	}

	retVal := n.p.Call("getChildMeshes", args...)
	result := []*AbstractMesh{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, AbstractMeshFromJSObject(retVal.Index(ri), n.ctx))
	}
	return result
}

// NodeGetChildrenOpts contains optional parameters for Node.GetChildren.
type NodeGetChildrenOpts struct {
	Predicate             JSFunc
	DirectDescendantsOnly *bool
}

// GetChildren calls the GetChildren method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#getchildren
func (n *Node) GetChildren(opts *NodeGetChildrenOpts) []*Node {
	if opts == nil {
		opts = &NodeGetChildrenOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(opts.Predicate) /* never freed! */)
	}
	if opts.DirectDescendantsOnly == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DirectDescendantsOnly)
	}

	retVal := n.p.Call("getChildren", args...)
	result := []*Node{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, NodeFromJSObject(retVal.Index(ri), n.ctx))
	}
	return result
}

// GetClassName calls the GetClassName method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#getclassname
func (n *Node) GetClassName() string {

	retVal := n.p.Call("getClassName")
	return retVal.String()
}

// NodeGetDescendantsOpts contains optional parameters for Node.GetDescendants.
type NodeGetDescendantsOpts struct {
	DirectDescendantsOnly *bool
	Predicate             JSFunc
}

// GetDescendants calls the GetDescendants method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#getdescendants
func (n *Node) GetDescendants(opts *NodeGetDescendantsOpts) []*Node {
	if opts == nil {
		opts = &NodeGetDescendantsOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.DirectDescendantsOnly == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DirectDescendantsOnly)
	}
	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(opts.Predicate) /* never freed! */)
	}

	retVal := n.p.Call("getDescendants", args...)
	result := []*Node{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, NodeFromJSObject(retVal.Index(ri), n.ctx))
	}
	return result
}

// GetEngine calls the GetEngine method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#getengine
func (n *Node) GetEngine() *Engine {

	retVal := n.p.Call("getEngine")
	return EngineFromJSObject(retVal, n.ctx)
}

// NodeGetHierarchyBoundingVectorsOpts contains optional parameters for Node.GetHierarchyBoundingVectors.
type NodeGetHierarchyBoundingVectorsOpts struct {
	IncludeDescendants *bool
	Predicate          JSFunc
}

// GetHierarchyBoundingVectors calls the GetHierarchyBoundingVectors method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#gethierarchyboundingvectors
func (n *Node) GetHierarchyBoundingVectors(opts *NodeGetHierarchyBoundingVectorsOpts) js.Value {
	if opts == nil {
		opts = &NodeGetHierarchyBoundingVectorsOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.IncludeDescendants == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IncludeDescendants)
	}
	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(opts.Predicate) /* never freed! */)
	}

	retVal := n.p.Call("getHierarchyBoundingVectors", args...)
	return retVal
}

// GetScene calls the GetScene method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#getscene
func (n *Node) GetScene() *Scene {

	retVal := n.p.Call("getScene")
	return SceneFromJSObject(retVal, n.ctx)
}

// GetWorldMatrix calls the GetWorldMatrix method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#getworldmatrix
func (n *Node) GetWorldMatrix() *Matrix {

	retVal := n.p.Call("getWorldMatrix")
	return MatrixFromJSObject(retVal, n.ctx)
}

// IsDescendantOf calls the IsDescendantOf method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#isdescendantof
func (n *Node) IsDescendantOf(ancestor *Node) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, ancestor.JSObject())

	retVal := n.p.Call("isDescendantOf", args...)
	return retVal.Bool()
}

// IsDisposed calls the IsDisposed method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#isdisposed
func (n *Node) IsDisposed() bool {

	retVal := n.p.Call("isDisposed")
	return retVal.Bool()
}

// NodeIsEnabledOpts contains optional parameters for Node.IsEnabled.
type NodeIsEnabledOpts struct {
	CheckAncestors *bool
}

// IsEnabled calls the IsEnabled method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#isenabled
func (n *Node) IsEnabled(opts *NodeIsEnabledOpts) bool {
	if opts == nil {
		opts = &NodeIsEnabledOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.CheckAncestors == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CheckAncestors)
	}

	retVal := n.p.Call("isEnabled", args...)
	return retVal.Bool()
}

// NodeIsReadyOpts contains optional parameters for Node.IsReady.
type NodeIsReadyOpts struct {
	CompleteCheck *bool
}

// IsReady calls the IsReady method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#isready
func (n *Node) IsReady(opts *NodeIsReadyOpts) bool {
	if opts == nil {
		opts = &NodeIsReadyOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.CompleteCheck == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CompleteCheck)
	}

	retVal := n.p.Call("isReady", args...)
	return retVal.Bool()
}

// ParseAnimationRanges calls the ParseAnimationRanges method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#parseanimationranges
func (n *Node) ParseAnimationRanges(node *Node, parsedNode interface{}, scene *Scene) {

	args := make([]interface{}, 0, 3+0)

	args = append(args, node.JSObject())
	args = append(args, parsedNode)
	args = append(args, scene.JSObject())

	n.p.Call("ParseAnimationRanges", args...)
}

// RemoveBehavior calls the RemoveBehavior method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#removebehavior
func (n *Node) RemoveBehavior(behavior js.Value) *Node {

	args := make([]interface{}, 0, 1+0)

	args = append(args, behavior)

	retVal := n.p.Call("removeBehavior", args...)
	return NodeFromJSObject(retVal, n.ctx)
}

// SerializeAnimationRanges calls the SerializeAnimationRanges method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#serializeanimationranges
func (n *Node) SerializeAnimationRanges() interface{} {

	retVal := n.p.Call("serializeAnimationRanges")
	return retVal
}

// SetEnabled calls the SetEnabled method on the Node object.
//
// https://doc.babylonjs.com/api/classes/babylon.node#setenabled
func (n *Node) SetEnabled(value bool) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, value)

	n.p.Call("setEnabled", args...)
}

// AnimationPropertiesOverride returns the AnimationPropertiesOverride property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#animationpropertiesoverride
func (n *Node) AnimationPropertiesOverride() *AnimationPropertiesOverride {
	retVal := n.p.Get("animationPropertiesOverride")
	return AnimationPropertiesOverrideFromJSObject(retVal, n.ctx)
}

// SetAnimationPropertiesOverride sets the AnimationPropertiesOverride property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#animationpropertiesoverride
func (n *Node) SetAnimationPropertiesOverride(animationPropertiesOverride *AnimationPropertiesOverride) *Node {
	n.p.Set("animationPropertiesOverride", animationPropertiesOverride.JSObject())
	return n
}

// Animations returns the Animations property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#animations
func (n *Node) Animations() []*Animation {
	retVal := n.p.Get("animations")
	result := []*Animation{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, AnimationFromJSObject(retVal.Index(ri), n.ctx))
	}
	return result
}

// SetAnimations sets the Animations property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#animations
func (n *Node) SetAnimations(animations []*Animation) *Node {
	n.p.Set("animations", animations)
	return n
}

// Behaviors returns the Behaviors property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#behaviors
func (n *Node) Behaviors() js.Value {
	retVal := n.p.Get("behaviors")
	return retVal
}

// SetBehaviors sets the Behaviors property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#behaviors
func (n *Node) SetBehaviors(behaviors js.Value) *Node {
	n.p.Set("behaviors", behaviors)
	return n
}

// DoNotSerialize returns the DoNotSerialize property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#donotserialize
func (n *Node) DoNotSerialize() bool {
	retVal := n.p.Get("doNotSerialize")
	return retVal.Bool()
}

// SetDoNotSerialize sets the DoNotSerialize property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#donotserialize
func (n *Node) SetDoNotSerialize(doNotSerialize bool) *Node {
	n.p.Set("doNotSerialize", doNotSerialize)
	return n
}

// Id returns the Id property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#id
func (n *Node) Id() string {
	retVal := n.p.Get("id")
	return retVal.String()
}

// SetId sets the Id property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#id
func (n *Node) SetId(id string) *Node {
	n.p.Set("id", id)
	return n
}

// InspectableCustomProperties returns the InspectableCustomProperties property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#inspectablecustomproperties
func (n *Node) InspectableCustomProperties() []*IInspectable {
	retVal := n.p.Get("inspectableCustomProperties")
	result := []*IInspectable{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, IInspectableFromJSObject(retVal.Index(ri), n.ctx))
	}
	return result
}

// SetInspectableCustomProperties sets the InspectableCustomProperties property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#inspectablecustomproperties
func (n *Node) SetInspectableCustomProperties(inspectableCustomProperties []*IInspectable) *Node {
	n.p.Set("inspectableCustomProperties", inspectableCustomProperties)
	return n
}

// Metadata returns the Metadata property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#metadata
func (n *Node) Metadata() interface{} {
	retVal := n.p.Get("metadata")
	return retVal
}

// SetMetadata sets the Metadata property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#metadata
func (n *Node) SetMetadata(metadata interface{}) *Node {
	n.p.Set("metadata", metadata)
	return n
}

// Name returns the Name property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#name
func (n *Node) Name() string {
	retVal := n.p.Get("name")
	return retVal.String()
}

// SetName sets the Name property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#name
func (n *Node) SetName(name string) *Node {
	n.p.Set("name", name)
	return n
}

// OnDispose returns the OnDispose property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#ondispose
func (n *Node) OnDispose() js.Value {
	retVal := n.p.Get("onDispose")
	return retVal
}

// SetOnDispose sets the OnDispose property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#ondispose
func (n *Node) SetOnDispose(onDispose JSFunc) *Node {
	n.p.Set("onDispose", js.FuncOf(onDispose))
	return n
}

// OnDisposeObservable returns the OnDisposeObservable property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#ondisposeobservable
func (n *Node) OnDisposeObservable() *Observable {
	retVal := n.p.Get("onDisposeObservable")
	return ObservableFromJSObject(retVal, n.ctx)
}

// SetOnDisposeObservable sets the OnDisposeObservable property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#ondisposeobservable
func (n *Node) SetOnDisposeObservable(onDisposeObservable *Observable) *Node {
	n.p.Set("onDisposeObservable", onDisposeObservable.JSObject())
	return n
}

// OnReady returns the OnReady property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#onready
func (n *Node) OnReady() js.Value {
	retVal := n.p.Get("onReady")
	return retVal
}

// SetOnReady sets the OnReady property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#onready
func (n *Node) SetOnReady(onReady JSFunc) *Node {
	n.p.Set("onReady", js.FuncOf(onReady))
	return n
}

// Parent returns the Parent property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#parent
func (n *Node) Parent() *Node {
	retVal := n.p.Get("parent")
	return NodeFromJSObject(retVal, n.ctx)
}

// SetParent sets the Parent property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#parent
func (n *Node) SetParent(parent *Node) *Node {
	n.p.Set("parent", parent.JSObject())
	return n
}

// ReservedDataStore returns the ReservedDataStore property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#reserveddatastore
func (n *Node) ReservedDataStore() interface{} {
	retVal := n.p.Get("reservedDataStore")
	return retVal
}

// SetReservedDataStore sets the ReservedDataStore property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#reserveddatastore
func (n *Node) SetReservedDataStore(reservedDataStore interface{}) *Node {
	n.p.Set("reservedDataStore", reservedDataStore)
	return n
}

// State returns the State property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#state
func (n *Node) State() string {
	retVal := n.p.Get("state")
	return retVal.String()
}

// SetState sets the State property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#state
func (n *Node) SetState(state string) *Node {
	n.p.Set("state", state)
	return n
}

// UniqueId returns the UniqueId property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#uniqueid
func (n *Node) UniqueId() float64 {
	retVal := n.p.Get("uniqueId")
	return retVal.Float()
}

// SetUniqueId sets the UniqueId property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#uniqueid
func (n *Node) SetUniqueId(uniqueId float64) *Node {
	n.p.Set("uniqueId", uniqueId)
	return n
}

// WorldMatrixFromCache returns the WorldMatrixFromCache property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#worldmatrixfromcache
func (n *Node) WorldMatrixFromCache() *Matrix {
	retVal := n.p.Get("worldMatrixFromCache")
	return MatrixFromJSObject(retVal, n.ctx)
}

// SetWorldMatrixFromCache sets the WorldMatrixFromCache property of class Node.
//
// https://doc.babylonjs.com/api/classes/babylon.node#worldmatrixfromcache
func (n *Node) SetWorldMatrixFromCache(worldMatrixFromCache *Matrix) *Node {
	n.p.Set("worldMatrixFromCache", worldMatrixFromCache.JSObject())
	return n
}

// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// BoundingSphere represents a babylon.js BoundingSphere.
// Class used to store bounding sphere information
type BoundingSphere struct {
	p   js.Value
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (b *BoundingSphere) JSObject() js.Value { return b.p }

// BoundingSphere returns a BoundingSphere JavaScript class.
func (ba *Babylon) BoundingSphere() *BoundingSphere {
	p := ba.ctx.Get("BoundingSphere")
	return BoundingSphereFromJSObject(p, ba.ctx)
}

// BoundingSphereFromJSObject returns a wrapped BoundingSphere JavaScript class.
func BoundingSphereFromJSObject(p js.Value, ctx js.Value) *BoundingSphere {
	return &BoundingSphere{p: p, ctx: ctx}
}

// BoundingSphereArrayToJSArray returns a JavaScript Array for the wrapped array.
func BoundingSphereArrayToJSArray(array []*BoundingSphere) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewBoundingSphereOpts contains optional parameters for NewBoundingSphere.
type NewBoundingSphereOpts struct {
	WorldMatrix *Matrix
}

// NewBoundingSphere returns a new BoundingSphere object.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#constructor
func (ba *Babylon) NewBoundingSphere(min *Vector3, max *Vector3, opts *NewBoundingSphereOpts) *BoundingSphere {
	if opts == nil {
		opts = &NewBoundingSphereOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, min.JSObject())
	args = append(args, max.JSObject())

	if opts.WorldMatrix == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.WorldMatrix.JSObject())
	}

	p := ba.ctx.Get("BoundingSphere").New(args...)
	return BoundingSphereFromJSObject(p, ba.ctx)
}

// GetWorldMatrix calls the GetWorldMatrix method on the BoundingSphere object.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#getworldmatrix
func (b *BoundingSphere) GetWorldMatrix() *Matrix {

	retVal := b.p.Call("getWorldMatrix")
	return MatrixFromJSObject(retVal, b.ctx)
}

// Intersects calls the Intersects method on the BoundingSphere object.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#intersects
func (b *BoundingSphere) Intersects(sphere0 *BoundingSphere, sphere1 *BoundingSphere) bool {

	args := make([]interface{}, 0, 2+0)

	if sphere0 == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, sphere0.JSObject())
	}

	if sphere1 == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, sphere1.JSObject())
	}

	retVal := b.p.Call("Intersects", args...)
	return retVal.Bool()
}

// IntersectsPoint calls the IntersectsPoint method on the BoundingSphere object.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#intersectspoint
func (b *BoundingSphere) IntersectsPoint(point *Vector3) bool {

	args := make([]interface{}, 0, 1+0)

	if point == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, point.JSObject())
	}

	retVal := b.p.Call("intersectsPoint", args...)
	return retVal.Bool()
}

// IsCenterInFrustum calls the IsCenterInFrustum method on the BoundingSphere object.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#iscenterinfrustum
func (b *BoundingSphere) IsCenterInFrustum(frustumPlanes []*Plane) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, PlaneArrayToJSArray(frustumPlanes))

	retVal := b.p.Call("isCenterInFrustum", args...)
	return retVal.Bool()
}

// IsInFrustum calls the IsInFrustum method on the BoundingSphere object.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#isinfrustum
func (b *BoundingSphere) IsInFrustum(frustumPlanes []*Plane) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, PlaneArrayToJSArray(frustumPlanes))

	retVal := b.p.Call("isInFrustum", args...)
	return retVal.Bool()
}

// BoundingSphereReConstructOpts contains optional parameters for BoundingSphere.ReConstruct.
type BoundingSphereReConstructOpts struct {
	WorldMatrix *Matrix
}

// ReConstruct calls the ReConstruct method on the BoundingSphere object.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#reconstruct
func (b *BoundingSphere) ReConstruct(min *Vector3, max *Vector3, opts *BoundingSphereReConstructOpts) {
	if opts == nil {
		opts = &BoundingSphereReConstructOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	if min == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, min.JSObject())
	}

	if max == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, max.JSObject())
	}

	if opts.WorldMatrix == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.WorldMatrix.JSObject())
	}

	b.p.Call("reConstruct", args...)
}

// Scale calls the Scale method on the BoundingSphere object.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#scale
func (b *BoundingSphere) Scale(factor float64) *BoundingSphere {

	args := make([]interface{}, 0, 1+0)

	args = append(args, factor)

	retVal := b.p.Call("scale", args...)
	return BoundingSphereFromJSObject(retVal, b.ctx)
}

// Center returns the Center property of class BoundingSphere.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#center
func (b *BoundingSphere) Center() *Vector3 {
	retVal := b.p.Get("center")
	return Vector3FromJSObject(retVal, b.ctx)
}

// SetCenter sets the Center property of class BoundingSphere.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#center
func (b *BoundingSphere) SetCenter(center *Vector3) *BoundingSphere {
	b.p.Set("center", center.JSObject())
	return b
}

// CenterWorld returns the CenterWorld property of class BoundingSphere.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#centerworld
func (b *BoundingSphere) CenterWorld() *Vector3 {
	retVal := b.p.Get("centerWorld")
	return Vector3FromJSObject(retVal, b.ctx)
}

// SetCenterWorld sets the CenterWorld property of class BoundingSphere.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#centerworld
func (b *BoundingSphere) SetCenterWorld(centerWorld *Vector3) *BoundingSphere {
	b.p.Set("centerWorld", centerWorld.JSObject())
	return b
}

// Maximum returns the Maximum property of class BoundingSphere.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#maximum
func (b *BoundingSphere) Maximum() *Vector3 {
	retVal := b.p.Get("maximum")
	return Vector3FromJSObject(retVal, b.ctx)
}

// SetMaximum sets the Maximum property of class BoundingSphere.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#maximum
func (b *BoundingSphere) SetMaximum(maximum *Vector3) *BoundingSphere {
	b.p.Set("maximum", maximum.JSObject())
	return b
}

// Minimum returns the Minimum property of class BoundingSphere.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#minimum
func (b *BoundingSphere) Minimum() *Vector3 {
	retVal := b.p.Get("minimum")
	return Vector3FromJSObject(retVal, b.ctx)
}

// SetMinimum sets the Minimum property of class BoundingSphere.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#minimum
func (b *BoundingSphere) SetMinimum(minimum *Vector3) *BoundingSphere {
	b.p.Set("minimum", minimum.JSObject())
	return b
}

// Radius returns the Radius property of class BoundingSphere.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#radius
func (b *BoundingSphere) Radius() float64 {
	retVal := b.p.Get("radius")
	return retVal.Float()
}

// SetRadius sets the Radius property of class BoundingSphere.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#radius
func (b *BoundingSphere) SetRadius(radius float64) *BoundingSphere {
	b.p.Set("radius", radius)
	return b
}

// RadiusWorld returns the RadiusWorld property of class BoundingSphere.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#radiusworld
func (b *BoundingSphere) RadiusWorld() float64 {
	retVal := b.p.Get("radiusWorld")
	return retVal.Float()
}

// SetRadiusWorld sets the RadiusWorld property of class BoundingSphere.
//
// https://doc.babylonjs.com/api/classes/babylon.boundingsphere#radiusworld
func (b *BoundingSphere) SetRadiusWorld(radiusWorld float64) *BoundingSphere {
	b.p.Set("radiusWorld", radiusWorld)
	return b
}

// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// SmartArrayNoDuplicate represents a babylon.js SmartArrayNoDuplicate.
// Defines an GC Friendly array where the backfield array do not shrink to prevent over allocations.
// The data in this array can only be present once
type SmartArrayNoDuplicate struct {
	*SmartArray
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (s *SmartArrayNoDuplicate) JSObject() js.Value { return s.p }

// SmartArrayNoDuplicate returns a SmartArrayNoDuplicate JavaScript class.
func (ba *Babylon) SmartArrayNoDuplicate() *SmartArrayNoDuplicate {
	p := ba.ctx.Get("SmartArrayNoDuplicate")
	return SmartArrayNoDuplicateFromJSObject(p, ba.ctx)
}

// SmartArrayNoDuplicateFromJSObject returns a wrapped SmartArrayNoDuplicate JavaScript class.
func SmartArrayNoDuplicateFromJSObject(p js.Value, ctx js.Value) *SmartArrayNoDuplicate {
	return &SmartArrayNoDuplicate{SmartArray: SmartArrayFromJSObject(p, ctx), ctx: ctx}
}

// NewSmartArrayNoDuplicate returns a new SmartArrayNoDuplicate object.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate
func (ba *Babylon) NewSmartArrayNoDuplicate(capacity float64) *SmartArrayNoDuplicate {

	args := make([]interface{}, 0, 1+0)

	args = append(args, capacity)

	p := ba.ctx.Get("SmartArrayNoDuplicate").New(args...)
	return SmartArrayNoDuplicateFromJSObject(p, ba.ctx)
}

// Concat calls the Concat method on the SmartArrayNoDuplicate object.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate#concat
func (s *SmartArrayNoDuplicate) Concat(array interface{}) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, array)

	s.p.Call("concat", args...)
}

// ConcatWithNoDuplicate calls the ConcatWithNoDuplicate method on the SmartArrayNoDuplicate object.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate#concatwithnoduplicate
func (s *SmartArrayNoDuplicate) ConcatWithNoDuplicate(array interface{}) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, array)

	s.p.Call("concatWithNoDuplicate", args...)
}

// Contains calls the Contains method on the SmartArrayNoDuplicate object.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate#contains
func (s *SmartArrayNoDuplicate) Contains(value *T) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, value.JSObject())

	retVal := s.p.Call("contains", args...)
	return retVal.Bool()
}

// Dispose calls the Dispose method on the SmartArrayNoDuplicate object.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate#dispose
func (s *SmartArrayNoDuplicate) Dispose() {

	args := make([]interface{}, 0, 0+0)

	s.p.Call("dispose", args...)
}

// ForEach calls the ForEach method on the SmartArrayNoDuplicate object.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate#foreach
func (s *SmartArrayNoDuplicate) ForEach(jsFunc func()) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, jsFunc)

	s.p.Call("forEach", args...)
}

// IndexOf calls the IndexOf method on the SmartArrayNoDuplicate object.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate#indexof
func (s *SmartArrayNoDuplicate) IndexOf(value *T) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, value.JSObject())

	retVal := s.p.Call("indexOf", args...)
	return retVal.Float()
}

// Push calls the Push method on the SmartArrayNoDuplicate object.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate#push
func (s *SmartArrayNoDuplicate) Push(value *T) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, value.JSObject())

	s.p.Call("push", args...)
}

// PushNoDuplicate calls the PushNoDuplicate method on the SmartArrayNoDuplicate object.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate#pushnoduplicate
func (s *SmartArrayNoDuplicate) PushNoDuplicate(value *T) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, value.JSObject())

	retVal := s.p.Call("pushNoDuplicate", args...)
	return retVal.Bool()
}

// Reset calls the Reset method on the SmartArrayNoDuplicate object.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate#reset
func (s *SmartArrayNoDuplicate) Reset() {

	args := make([]interface{}, 0, 0+0)

	s.p.Call("reset", args...)
}

// Sort calls the Sort method on the SmartArrayNoDuplicate object.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate#sort
func (s *SmartArrayNoDuplicate) Sort(compareFn func()) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, compareFn)

	s.p.Call("sort", args...)
}

/*

// Data returns the Data property of class SmartArrayNoDuplicate.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate#data
func (s *SmartArrayNoDuplicate) Data(data []T) *SmartArrayNoDuplicate {
	p := ba.ctx.Get("SmartArrayNoDuplicate").New(data.JSObject())
	return SmartArrayNoDuplicateFromJSObject(p, ba.ctx)
}

// SetData sets the Data property of class SmartArrayNoDuplicate.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate#data
func (s *SmartArrayNoDuplicate) SetData(data []T) *SmartArrayNoDuplicate {
	p := ba.ctx.Get("SmartArrayNoDuplicate").New(data.JSObject())
	return SmartArrayNoDuplicateFromJSObject(p, ba.ctx)
}

// Length returns the Length property of class SmartArrayNoDuplicate.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate#length
func (s *SmartArrayNoDuplicate) Length(length float64) *SmartArrayNoDuplicate {
	p := ba.ctx.Get("SmartArrayNoDuplicate").New(length)
	return SmartArrayNoDuplicateFromJSObject(p, ba.ctx)
}

// SetLength sets the Length property of class SmartArrayNoDuplicate.
//
// https://doc.babylonjs.com/api/classes/babylon.smartarraynoduplicate#length
func (s *SmartArrayNoDuplicate) SetLength(length float64) *SmartArrayNoDuplicate {
	p := ba.ctx.Get("SmartArrayNoDuplicate").New(length)
	return SmartArrayNoDuplicateFromJSObject(p, ba.ctx)
}

*/

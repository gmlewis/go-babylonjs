// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// ProceduralTexture represents a babylon.js ProceduralTexture.
// Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler&#39; images.
// This is the base class of any Procedural texture and contains most of the shareable code.
//
// See: http://doc.babylonjs.com/how_to/how_to_use_procedural_textures
type ProceduralTexture struct {
	*Texture
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (p *ProceduralTexture) JSObject() js.Value { return p.p }

// ProceduralTexture returns a ProceduralTexture JavaScript class.
func (ba *Babylon) ProceduralTexture() *ProceduralTexture {
	p := ba.ctx.Get("ProceduralTexture")
	return ProceduralTextureFromJSObject(p, ba.ctx)
}

// ProceduralTextureFromJSObject returns a wrapped ProceduralTexture JavaScript class.
func ProceduralTextureFromJSObject(p js.Value, ctx js.Value) *ProceduralTexture {
	return &ProceduralTexture{Texture: TextureFromJSObject(p, ctx), ctx: ctx}
}

// ProceduralTextureArrayToJSArray returns a JavaScript Array for the wrapped array.
func ProceduralTextureArrayToJSArray(array []*ProceduralTexture) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewProceduralTextureOpts contains optional parameters for NewProceduralTexture.
type NewProceduralTextureOpts struct {
	FallbackTexture *Texture
	GenerateMipMaps *bool
	IsCube          *bool
}

// NewProceduralTexture returns a new ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture
func (ba *Babylon) NewProceduralTexture(name string, size interface{}, fragment interface{}, scene *Scene, opts *NewProceduralTextureOpts) *ProceduralTexture {
	if opts == nil {
		opts = &NewProceduralTextureOpts{}
	}

	args := make([]interface{}, 0, 4+3)

	args = append(args, name)
	args = append(args, size)
	args = append(args, fragment)
	args = append(args, scene.JSObject())

	if opts.FallbackTexture == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.FallbackTexture.JSObject())
	}
	if opts.GenerateMipMaps == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.GenerateMipMaps)
	}
	if opts.IsCube == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IsCube)
	}

	p := ba.ctx.Get("ProceduralTexture").New(args...)
	return ProceduralTextureFromJSObject(p, ba.ctx)
}

// Clone calls the Clone method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#clone
func (p *ProceduralTexture) Clone() *ProceduralTexture {

	retVal := p.p.Call("clone")
	return ProceduralTextureFromJSObject(retVal, p.ctx)
}

// Dispose calls the Dispose method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#dispose
func (p *ProceduralTexture) Dispose() {

	p.p.Call("dispose")
}

// GetContent calls the GetContent method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#getcontent
func (p *ProceduralTexture) GetContent() js.Value {

	retVal := p.p.Call("getContent")
	return retVal
}

// GetEffect calls the GetEffect method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#geteffect
func (p *ProceduralTexture) GetEffect() *Effect {

	retVal := p.p.Call("getEffect")
	return EffectFromJSObject(retVal, p.ctx)
}

// GetRenderSize calls the GetRenderSize method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#getrendersize
func (p *ProceduralTexture) GetRenderSize() float64 {

	retVal := p.p.Call("getRenderSize")
	return retVal.Float()
}

// IsReady calls the IsReady method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#isready
func (p *ProceduralTexture) IsReady() bool {

	retVal := p.p.Call("isReady")
	return retVal.Bool()
}

// ProceduralTextureRenderOpts contains optional parameters for ProceduralTexture.Render.
type ProceduralTextureRenderOpts struct {
	UseCameraPostProcess *bool
}

// Render calls the Render method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#render
func (p *ProceduralTexture) Render(opts *ProceduralTextureRenderOpts) {
	if opts == nil {
		opts = &ProceduralTextureRenderOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.UseCameraPostProcess == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UseCameraPostProcess)
	}

	p.p.Call("render", args...)
}

// Reset calls the Reset method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#reset
func (p *ProceduralTexture) Reset() {

	p.p.Call("reset")
}

// ResetRefreshCounter calls the ResetRefreshCounter method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#resetrefreshcounter
func (p *ProceduralTexture) ResetRefreshCounter() {

	p.p.Call("resetRefreshCounter")
}

// Resize calls the Resize method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#resize
func (p *ProceduralTexture) Resize(size float64, generateMipMaps bool) {

	args := make([]interface{}, 0, 2+0)

	args = append(args, size)
	args = append(args, generateMipMaps)

	p.p.Call("resize", args...)
}

// SetColor3 calls the SetColor3 method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#setcolor3
func (p *ProceduralTexture) SetColor3(name string, value *Color3) *ProceduralTexture {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value.JSObject())

	retVal := p.p.Call("setColor3", args...)
	return ProceduralTextureFromJSObject(retVal, p.ctx)
}

// SetColor4 calls the SetColor4 method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#setcolor4
func (p *ProceduralTexture) SetColor4(name string, value *Color4) *ProceduralTexture {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value.JSObject())

	retVal := p.p.Call("setColor4", args...)
	return ProceduralTextureFromJSObject(retVal, p.ctx)
}

// SetFloat calls the SetFloat method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#setfloat
func (p *ProceduralTexture) SetFloat(name string, value float64) *ProceduralTexture {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value)

	retVal := p.p.Call("setFloat", args...)
	return ProceduralTextureFromJSObject(retVal, p.ctx)
}

// SetFloats calls the SetFloats method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#setfloats
func (p *ProceduralTexture) SetFloats(name string, value []float64) *ProceduralTexture {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value)

	retVal := p.p.Call("setFloats", args...)
	return ProceduralTextureFromJSObject(retVal, p.ctx)
}

// SetFragment calls the SetFragment method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#setfragment
func (p *ProceduralTexture) SetFragment(fragment interface{}) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, fragment)

	p.p.Call("setFragment", args...)
}

// SetInt calls the SetInt method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#setint
func (p *ProceduralTexture) SetInt(name string, value float64) *ProceduralTexture {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value)

	retVal := p.p.Call("setInt", args...)
	return ProceduralTextureFromJSObject(retVal, p.ctx)
}

// SetMatrix calls the SetMatrix method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#setmatrix
func (p *ProceduralTexture) SetMatrix(name string, value *Matrix) *ProceduralTexture {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value.JSObject())

	retVal := p.p.Call("setMatrix", args...)
	return ProceduralTextureFromJSObject(retVal, p.ctx)
}

// SetTexture calls the SetTexture method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#settexture
func (p *ProceduralTexture) SetTexture(name string, texture *Texture) *ProceduralTexture {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, texture.JSObject())

	retVal := p.p.Call("setTexture", args...)
	return ProceduralTextureFromJSObject(retVal, p.ctx)
}

// SetVector2 calls the SetVector2 method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#setvector2
func (p *ProceduralTexture) SetVector2(name string, value *Vector2) *ProceduralTexture {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value.JSObject())

	retVal := p.p.Call("setVector2", args...)
	return ProceduralTextureFromJSObject(retVal, p.ctx)
}

// SetVector3 calls the SetVector3 method on the ProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#setvector3
func (p *ProceduralTexture) SetVector3(name string, value *Vector3) *ProceduralTexture {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value.JSObject())

	retVal := p.p.Call("setVector3", args...)
	return ProceduralTextureFromJSObject(retVal, p.ctx)
}

// AutoClear returns the AutoClear property of class ProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#autoclear
func (p *ProceduralTexture) AutoClear() bool {
	retVal := p.p.Get("autoClear")
	return retVal.Bool()
}

// SetAutoClear sets the AutoClear property of class ProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#autoclear
func (p *ProceduralTexture) SetAutoClear(autoClear bool) *ProceduralTexture {
	p.p.Set("autoClear", autoClear)
	return p
}

// IsCube returns the IsCube property of class ProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#iscube
func (p *ProceduralTexture) IsCube() bool {
	retVal := p.p.Get("isCube")
	return retVal.Bool()
}

// SetIsCube sets the IsCube property of class ProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#iscube
func (p *ProceduralTexture) SetIsCube(isCube bool) *ProceduralTexture {
	p.p.Set("isCube", isCube)
	return p
}

// IsEnabled returns the IsEnabled property of class ProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#isenabled
func (p *ProceduralTexture) IsEnabled() bool {
	retVal := p.p.Get("isEnabled")
	return retVal.Bool()
}

// SetIsEnabled sets the IsEnabled property of class ProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#isenabled
func (p *ProceduralTexture) SetIsEnabled(isEnabled bool) *ProceduralTexture {
	p.p.Set("isEnabled", isEnabled)
	return p
}

// OnGenerated returns the OnGenerated property of class ProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#ongenerated
func (p *ProceduralTexture) OnGenerated() js.Value {
	retVal := p.p.Get("onGenerated")
	return retVal
}

// SetOnGenerated sets the OnGenerated property of class ProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#ongenerated
func (p *ProceduralTexture) SetOnGenerated(onGenerated JSFunc) *ProceduralTexture {
	p.p.Set("onGenerated", js.FuncOf(onGenerated))
	return p
}

// OnGeneratedObservable returns the OnGeneratedObservable property of class ProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#ongeneratedobservable
func (p *ProceduralTexture) OnGeneratedObservable() *Observable {
	retVal := p.p.Get("onGeneratedObservable")
	return ObservableFromJSObject(retVal, p.ctx)
}

// SetOnGeneratedObservable sets the OnGeneratedObservable property of class ProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#ongeneratedobservable
func (p *ProceduralTexture) SetOnGeneratedObservable(onGeneratedObservable *Observable) *ProceduralTexture {
	p.p.Set("onGeneratedObservable", onGeneratedObservable.JSObject())
	return p
}

// RefreshRate returns the RefreshRate property of class ProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#refreshrate
func (p *ProceduralTexture) RefreshRate() float64 {
	retVal := p.p.Get("refreshRate")
	return retVal.Float()
}

// SetRefreshRate sets the RefreshRate property of class ProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.proceduraltexture#refreshrate
func (p *ProceduralTexture) SetRefreshRate(refreshRate float64) *ProceduralTexture {
	p.p.Set("refreshRate", refreshRate)
	return p
}

// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// HighlightLayer represents a babylon.js HighlightLayer.
// The highlight layer Helps adding a glow effect around a mesh.
//
// Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove
// glowy meshes to your scene.
type HighlightLayer struct {
	*EffectLayer
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (h *HighlightLayer) JSObject() js.Value { return h.p }

// HighlightLayer returns a HighlightLayer JavaScript class.
func (ba *Babylon) HighlightLayer() *HighlightLayer {
	p := ba.ctx.Get("HighlightLayer")
	return HighlightLayerFromJSObject(p, ba.ctx)
}

// HighlightLayerFromJSObject returns a wrapped HighlightLayer JavaScript class.
func HighlightLayerFromJSObject(p js.Value, ctx js.Value) *HighlightLayer {
	return &HighlightLayer{EffectLayer: EffectLayerFromJSObject(p, ctx), ctx: ctx}
}

// HighlightLayerArrayToJSArray returns a JavaScript Array for the wrapped array.
func HighlightLayerArrayToJSArray(array []*HighlightLayer) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewHighlightLayerOpts contains optional parameters for NewHighlightLayer.
type NewHighlightLayerOpts struct {
	Options *IHighlightLayerOptions
}

// NewHighlightLayer returns a new HighlightLayer object.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer
func (ba *Babylon) NewHighlightLayer(name string, scene *Scene, opts *NewHighlightLayerOpts) *HighlightLayer {
	if opts == nil {
		opts = &NewHighlightLayerOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, name)
	args = append(args, scene.JSObject())

	if opts.Options == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Options.JSObject())
	}

	p := ba.ctx.Get("HighlightLayer").New(args...)
	return HighlightLayerFromJSObject(p, ba.ctx)
}

// AddExcludedMesh calls the AddExcludedMesh method on the HighlightLayer object.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#addexcludedmesh
func (h *HighlightLayer) AddExcludedMesh(mesh *Mesh) {

	args := make([]interface{}, 0, 1+0)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	h.p.Call("addExcludedMesh", args...)
}

// HighlightLayerAddMeshOpts contains optional parameters for HighlightLayer.AddMesh.
type HighlightLayerAddMeshOpts struct {
	GlowEmissiveOnly *bool
}

// AddMesh calls the AddMesh method on the HighlightLayer object.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#addmesh
func (h *HighlightLayer) AddMesh(mesh *Mesh, color *Color3, opts *HighlightLayerAddMeshOpts) {
	if opts == nil {
		opts = &HighlightLayerAddMeshOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if color == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, color.JSObject())
	}

	if opts.GlowEmissiveOnly == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.GlowEmissiveOnly)
	}

	h.p.Call("addMesh", args...)
}

// Dispose calls the Dispose method on the HighlightLayer object.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#dispose
func (h *HighlightLayer) Dispose() {

	h.p.Call("dispose")
}

// GetClassName calls the GetClassName method on the HighlightLayer object.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#getclassname
func (h *HighlightLayer) GetClassName() string {

	retVal := h.p.Call("getClassName")
	return retVal.String()
}

// GetEffectName calls the GetEffectName method on the HighlightLayer object.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#geteffectname
func (h *HighlightLayer) GetEffectName() string {

	retVal := h.p.Call("getEffectName")
	return retVal.String()
}

// HasMesh calls the HasMesh method on the HighlightLayer object.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#hasmesh
func (h *HighlightLayer) HasMesh(mesh *AbstractMesh) bool {

	args := make([]interface{}, 0, 1+0)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	retVal := h.p.Call("hasMesh", args...)
	return retVal.Bool()
}

// IsReady calls the IsReady method on the HighlightLayer object.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#isready
func (h *HighlightLayer) IsReady(subMesh *SubMesh, useInstances bool) bool {

	args := make([]interface{}, 0, 2+0)

	if subMesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, subMesh.JSObject())
	}

	args = append(args, useInstances)

	retVal := h.p.Call("isReady", args...)
	return retVal.Bool()
}

// NeedStencil calls the NeedStencil method on the HighlightLayer object.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#needstencil
func (h *HighlightLayer) NeedStencil() bool {

	retVal := h.p.Call("needStencil")
	return retVal.Bool()
}

// Parse calls the Parse method on the HighlightLayer object.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#parse
func (h *HighlightLayer) Parse(parsedHightlightLayer JSObject, scene *Scene, rootUrl string) *HighlightLayer {

	args := make([]interface{}, 0, 3+0)

	if parsedHightlightLayer == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, parsedHightlightLayer.JSObject())
	}

	if scene == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, scene.JSObject())
	}

	args = append(args, rootUrl)

	retVal := h.p.Call("Parse", args...)
	return HighlightLayerFromJSObject(retVal, h.ctx)
}

// RemoveExcludedMesh calls the RemoveExcludedMesh method on the HighlightLayer object.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#removeexcludedmesh
func (h *HighlightLayer) RemoveExcludedMesh(mesh *Mesh) {

	args := make([]interface{}, 0, 1+0)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	h.p.Call("removeExcludedMesh", args...)
}

// RemoveMesh calls the RemoveMesh method on the HighlightLayer object.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#removemesh
func (h *HighlightLayer) RemoveMesh(mesh *Mesh) {

	args := make([]interface{}, 0, 1+0)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	h.p.Call("removeMesh", args...)
}

// Serialize calls the Serialize method on the HighlightLayer object.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#serialize
func (h *HighlightLayer) Serialize() js.Value {

	retVal := h.p.Call("serialize")
	return retVal
}

// ShouldRender calls the ShouldRender method on the HighlightLayer object.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#shouldrender
func (h *HighlightLayer) ShouldRender() bool {

	retVal := h.p.Call("shouldRender")
	return retVal.Bool()
}

// BlurHorizontalSize returns the BlurHorizontalSize property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#blurhorizontalsize
func (h *HighlightLayer) BlurHorizontalSize() float64 {
	retVal := h.p.Get("blurHorizontalSize")
	return retVal.Float()
}

// SetBlurHorizontalSize sets the BlurHorizontalSize property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#blurhorizontalsize
func (h *HighlightLayer) SetBlurHorizontalSize(blurHorizontalSize float64) *HighlightLayer {
	h.p.Set("blurHorizontalSize", blurHorizontalSize)
	return h
}

// BlurVerticalSize returns the BlurVerticalSize property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#blurverticalsize
func (h *HighlightLayer) BlurVerticalSize() float64 {
	retVal := h.p.Get("blurVerticalSize")
	return retVal.Float()
}

// SetBlurVerticalSize sets the BlurVerticalSize property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#blurverticalsize
func (h *HighlightLayer) SetBlurVerticalSize(blurVerticalSize float64) *HighlightLayer {
	h.p.Set("blurVerticalSize", blurVerticalSize)
	return h
}

// EffectName returns the EffectName property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#effectname
func (h *HighlightLayer) EffectName() string {
	retVal := h.p.Get("EffectName")
	return retVal.String()
}

// SetEffectName sets the EffectName property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#effectname
func (h *HighlightLayer) SetEffectName(EffectName string) *HighlightLayer {
	h.p.Set("EffectName", EffectName)
	return h
}

// GlowingMeshStencilReference returns the GlowingMeshStencilReference property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#glowingmeshstencilreference
func (h *HighlightLayer) GlowingMeshStencilReference() float64 {
	retVal := h.p.Get("GlowingMeshStencilReference")
	return retVal.Float()
}

// SetGlowingMeshStencilReference sets the GlowingMeshStencilReference property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#glowingmeshstencilreference
func (h *HighlightLayer) SetGlowingMeshStencilReference(GlowingMeshStencilReference float64) *HighlightLayer {
	h.p.Set("GlowingMeshStencilReference", GlowingMeshStencilReference)
	return h
}

// InnerGlow returns the InnerGlow property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#innerglow
func (h *HighlightLayer) InnerGlow() bool {
	retVal := h.p.Get("innerGlow")
	return retVal.Bool()
}

// SetInnerGlow sets the InnerGlow property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#innerglow
func (h *HighlightLayer) SetInnerGlow(innerGlow bool) *HighlightLayer {
	h.p.Set("innerGlow", innerGlow)
	return h
}

// Name returns the Name property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#name
func (h *HighlightLayer) Name() string {
	retVal := h.p.Get("name")
	return retVal.String()
}

// SetName sets the Name property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#name
func (h *HighlightLayer) SetName(name string) *HighlightLayer {
	h.p.Set("name", name)
	return h
}

// NeutralColor returns the NeutralColor property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#neutralcolor
func (h *HighlightLayer) NeutralColor() *Color4 {
	retVal := h.p.Get("NeutralColor")
	return Color4FromJSObject(retVal, h.ctx)
}

// SetNeutralColor sets the NeutralColor property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#neutralcolor
func (h *HighlightLayer) SetNeutralColor(NeutralColor *Color4) *HighlightLayer {
	h.p.Set("NeutralColor", NeutralColor.JSObject())
	return h
}

// NormalMeshStencilReference returns the NormalMeshStencilReference property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#normalmeshstencilreference
func (h *HighlightLayer) NormalMeshStencilReference() float64 {
	retVal := h.p.Get("NormalMeshStencilReference")
	return retVal.Float()
}

// SetNormalMeshStencilReference sets the NormalMeshStencilReference property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#normalmeshstencilreference
func (h *HighlightLayer) SetNormalMeshStencilReference(NormalMeshStencilReference float64) *HighlightLayer {
	h.p.Set("NormalMeshStencilReference", NormalMeshStencilReference)
	return h
}

// OnAfterBlurObservable returns the OnAfterBlurObservable property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#onafterblurobservable
func (h *HighlightLayer) OnAfterBlurObservable() *Observable {
	retVal := h.p.Get("onAfterBlurObservable")
	return ObservableFromJSObject(retVal, h.ctx)
}

// SetOnAfterBlurObservable sets the OnAfterBlurObservable property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#onafterblurobservable
func (h *HighlightLayer) SetOnAfterBlurObservable(onAfterBlurObservable *Observable) *HighlightLayer {
	h.p.Set("onAfterBlurObservable", onAfterBlurObservable.JSObject())
	return h
}

// OnBeforeBlurObservable returns the OnBeforeBlurObservable property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#onbeforeblurobservable
func (h *HighlightLayer) OnBeforeBlurObservable() *Observable {
	retVal := h.p.Get("onBeforeBlurObservable")
	return ObservableFromJSObject(retVal, h.ctx)
}

// SetOnBeforeBlurObservable sets the OnBeforeBlurObservable property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#onbeforeblurobservable
func (h *HighlightLayer) SetOnBeforeBlurObservable(onBeforeBlurObservable *Observable) *HighlightLayer {
	h.p.Set("onBeforeBlurObservable", onBeforeBlurObservable.JSObject())
	return h
}

// OuterGlow returns the OuterGlow property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#outerglow
func (h *HighlightLayer) OuterGlow() bool {
	retVal := h.p.Get("outerGlow")
	return retVal.Bool()
}

// SetOuterGlow sets the OuterGlow property of class HighlightLayer.
//
// https://doc.babylonjs.com/api/classes/babylon.highlightlayer#outerglow
func (h *HighlightLayer) SetOuterGlow(outerGlow bool) *HighlightLayer {
	h.p.Set("outerGlow", outerGlow)
	return h
}

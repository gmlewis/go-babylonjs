// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// EventState represents a babylon.js EventState.
// A class serves as a medium between the observable and its observers
type EventState struct {
	p   js.Value
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (e *EventState) JSObject() js.Value { return e.p }

// EventState returns a EventState JavaScript class.
func (ba *Babylon) EventState() *EventState {
	p := ba.ctx.Get("EventState")
	return EventStateFromJSObject(p, ba.ctx)
}

// EventStateFromJSObject returns a wrapped EventState JavaScript class.
func EventStateFromJSObject(p js.Value, ctx js.Value) *EventState {
	return &EventState{p: p, ctx: ctx}
}

// EventStateArrayToJSArray returns a JavaScript Array for the wrapped array.
func EventStateArrayToJSArray(array []*EventState) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewEventStateOpts contains optional parameters for NewEventState.
type NewEventStateOpts struct {
	SkipNextObservers *bool
	Target            interface{}
	CurrentTarget     interface{}
}

// NewEventState returns a new EventState object.
//
// https://doc.babylonjs.com/api/classes/babylon.eventstate#constructor
func (ba *Babylon) NewEventState(mask float64, opts *NewEventStateOpts) *EventState {
	if opts == nil {
		opts = &NewEventStateOpts{}
	}

	args := make([]interface{}, 0, 1+3)

	args = append(args, mask)

	if opts.SkipNextObservers == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SkipNextObservers)
	}
	if opts.Target == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Target)
	}
	if opts.CurrentTarget == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.CurrentTarget)
	}

	p := ba.ctx.Get("EventState").New(args...)
	return EventStateFromJSObject(p, ba.ctx)
}

// EventStateInitalizeOpts contains optional parameters for EventState.Initalize.
type EventStateInitalizeOpts struct {
	SkipNextObservers *bool
	Target            interface{}
	CurrentTarget     interface{}
}

// Initalize calls the Initalize method on the EventState object.
//
// https://doc.babylonjs.com/api/classes/babylon.eventstate#initalize
func (e *EventState) Initalize(mask float64, opts *EventStateInitalizeOpts) *EventState {
	if opts == nil {
		opts = &EventStateInitalizeOpts{}
	}

	args := make([]interface{}, 0, 1+3)

	args = append(args, mask)

	if opts.SkipNextObservers == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SkipNextObservers)
	}
	if opts.Target == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Target)
	}
	if opts.CurrentTarget == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.CurrentTarget)
	}

	retVal := e.p.Call("initalize", args...)
	return EventStateFromJSObject(retVal, e.ctx)
}

// CurrentTarget returns the CurrentTarget property of class EventState.
//
// https://doc.babylonjs.com/api/classes/babylon.eventstate#currenttarget
func (e *EventState) CurrentTarget() js.Value {
	retVal := e.p.Get("currentTarget")
	return retVal
}

// SetCurrentTarget sets the CurrentTarget property of class EventState.
//
// https://doc.babylonjs.com/api/classes/babylon.eventstate#currenttarget
func (e *EventState) SetCurrentTarget(currentTarget JSObject) *EventState {
	e.p.Set("currentTarget", currentTarget.JSObject())
	return e
}

// LastReturnValue returns the LastReturnValue property of class EventState.
//
// https://doc.babylonjs.com/api/classes/babylon.eventstate#lastreturnvalue
func (e *EventState) LastReturnValue() js.Value {
	retVal := e.p.Get("lastReturnValue")
	return retVal
}

// SetLastReturnValue sets the LastReturnValue property of class EventState.
//
// https://doc.babylonjs.com/api/classes/babylon.eventstate#lastreturnvalue
func (e *EventState) SetLastReturnValue(lastReturnValue JSObject) *EventState {
	e.p.Set("lastReturnValue", lastReturnValue.JSObject())
	return e
}

// Mask returns the Mask property of class EventState.
//
// https://doc.babylonjs.com/api/classes/babylon.eventstate#mask
func (e *EventState) Mask() float64 {
	retVal := e.p.Get("mask")
	return retVal.Float()
}

// SetMask sets the Mask property of class EventState.
//
// https://doc.babylonjs.com/api/classes/babylon.eventstate#mask
func (e *EventState) SetMask(mask float64) *EventState {
	e.p.Set("mask", mask)
	return e
}

// SkipNextObservers returns the SkipNextObservers property of class EventState.
//
// https://doc.babylonjs.com/api/classes/babylon.eventstate#skipnextobservers
func (e *EventState) SkipNextObservers() bool {
	retVal := e.p.Get("skipNextObservers")
	return retVal.Bool()
}

// SetSkipNextObservers sets the SkipNextObservers property of class EventState.
//
// https://doc.babylonjs.com/api/classes/babylon.eventstate#skipnextobservers
func (e *EventState) SetSkipNextObservers(skipNextObservers bool) *EventState {
	e.p.Set("skipNextObservers", skipNextObservers)
	return e
}

// Target returns the Target property of class EventState.
//
// https://doc.babylonjs.com/api/classes/babylon.eventstate#target
func (e *EventState) Target() js.Value {
	retVal := e.p.Get("target")
	return retVal
}

// SetTarget sets the Target property of class EventState.
//
// https://doc.babylonjs.com/api/classes/babylon.eventstate#target
func (e *EventState) SetTarget(target JSObject) *EventState {
	e.p.Set("target", target.JSObject())
	return e
}

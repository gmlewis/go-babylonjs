// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// TrailMesh represents a babylon.js TrailMesh.
// Class used to create a trail following a mesh
type TrailMesh struct {
	*Mesh
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (t *TrailMesh) JSObject() js.Value { return t.p }

// TrailMesh returns a TrailMesh JavaScript class.
func (ba *Babylon) TrailMesh() *TrailMesh {
	p := ba.ctx.Get("TrailMesh")
	return TrailMeshFromJSObject(p, ba.ctx)
}

// TrailMeshFromJSObject returns a wrapped TrailMesh JavaScript class.
func TrailMeshFromJSObject(p js.Value, ctx js.Value) *TrailMesh {
	return &TrailMesh{Mesh: MeshFromJSObject(p, ctx), ctx: ctx}
}

// TrailMeshArrayToJSArray returns a JavaScript Array for the wrapped array.
func TrailMeshArrayToJSArray(array []*TrailMesh) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewTrailMeshOpts contains optional parameters for NewTrailMesh.
type NewTrailMeshOpts struct {
	Diameter  *float64
	Length    *float64
	AutoStart *bool
}

// NewTrailMesh returns a new TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh
func (ba *Babylon) NewTrailMesh(name string, generator *AbstractMesh, scene *Scene, opts *NewTrailMeshOpts) *TrailMesh {
	if opts == nil {
		opts = &NewTrailMeshOpts{}
	}

	args := make([]interface{}, 0, 3+3)

	args = append(args, name)
	args = append(args, generator.JSObject())
	args = append(args, scene.JSObject())

	if opts.Diameter == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Diameter)
	}
	if opts.Length == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Length)
	}
	if opts.AutoStart == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AutoStart)
	}

	p := ba.ctx.Get("TrailMesh").New(args...)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// AddLODLevel calls the AddLODLevel method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#addlodlevel
func (t *TrailMesh) AddLODLevel(distance float64, mesh *Mesh) *Mesh {

	args := make([]interface{}, 0, 2+0)

	args = append(args, distance)
	args = append(args, mesh.JSObject())

	retVal := t.p.Call("addLODLevel", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshApplyDisplacementMapOpts contains optional parameters for TrailMesh.ApplyDisplacementMap.
type TrailMeshApplyDisplacementMapOpts struct {
	OnSuccess   func()
	UvOffset    *Vector2
	UvScale     *Vector2
	ForceUpdate *bool
}

// ApplyDisplacementMap calls the ApplyDisplacementMap method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#applydisplacementmap
func (t *TrailMesh) ApplyDisplacementMap(url string, minHeight float64, maxHeight float64, opts *TrailMeshApplyDisplacementMapOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshApplyDisplacementMapOpts{}
	}

	args := make([]interface{}, 0, 3+4)

	args = append(args, url)
	args = append(args, minHeight)
	args = append(args, maxHeight)

	if opts.OnSuccess == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.OnSuccess)
	}
	if opts.UvOffset == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.UvOffset.JSObject())
	}
	if opts.UvScale == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.UvScale.JSObject())
	}
	if opts.ForceUpdate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceUpdate)
	}

	retVal := t.p.Call("applyDisplacementMap", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshApplyDisplacementMapFromBufferOpts contains optional parameters for TrailMesh.ApplyDisplacementMapFromBuffer.
type TrailMeshApplyDisplacementMapFromBufferOpts struct {
	UvOffset    *Vector2
	UvScale     *Vector2
	ForceUpdate *bool
}

// ApplyDisplacementMapFromBuffer calls the ApplyDisplacementMapFromBuffer method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#applydisplacementmapfrombuffer
func (t *TrailMesh) ApplyDisplacementMapFromBuffer(buffer js.Value, heightMapWidth float64, heightMapHeight float64, minHeight float64, maxHeight float64, opts *TrailMeshApplyDisplacementMapFromBufferOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshApplyDisplacementMapFromBufferOpts{}
	}

	args := make([]interface{}, 0, 5+3)

	args = append(args, buffer)
	args = append(args, heightMapWidth)
	args = append(args, heightMapHeight)
	args = append(args, minHeight)
	args = append(args, maxHeight)

	if opts.UvOffset == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.UvOffset.JSObject())
	}
	if opts.UvScale == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.UvScale.JSObject())
	}
	if opts.ForceUpdate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceUpdate)
	}

	retVal := t.p.Call("applyDisplacementMapFromBuffer", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// ApplySkeleton calls the ApplySkeleton method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#applyskeleton
func (t *TrailMesh) ApplySkeleton(skeleton *Skeleton) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, skeleton.JSObject())

	retVal := t.p.Call("applySkeleton", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// BakeCurrentTransformIntoVertices calls the BakeCurrentTransformIntoVertices method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#bakecurrenttransformintovertices
func (t *TrailMesh) BakeCurrentTransformIntoVertices() *Mesh {

	retVal := t.p.Call("bakeCurrentTransformIntoVertices")
	return MeshFromJSObject(retVal, t.ctx)
}

// BakeTransformIntoVertices calls the BakeTransformIntoVertices method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#baketransformintovertices
func (t *TrailMesh) BakeTransformIntoVertices(transform *Matrix) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, transform.JSObject())

	retVal := t.p.Call("bakeTransformIntoVertices", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// Center calls the Center method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#center
func (t *TrailMesh) Center(meshesOrMinMaxVector js.Value) *Vector3 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, meshesOrMinMaxVector)

	retVal := t.p.Call("Center", args...)
	return Vector3FromJSObject(retVal, t.ctx)
}

// CleanMatrixWeights calls the CleanMatrixWeights method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#cleanmatrixweights
func (t *TrailMesh) CleanMatrixWeights() {

	t.p.Call("cleanMatrixWeights")
}

// Clone calls the Clone method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#clone
func (t *TrailMesh) Clone(name string, newGenerator *AbstractMesh) *TrailMesh {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, newGenerator.JSObject())

	retVal := t.p.Call("clone", args...)
	return TrailMeshFromJSObject(retVal, t.ctx)
}

// ConvertToFlatShadedMesh calls the ConvertToFlatShadedMesh method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#converttoflatshadedmesh
func (t *TrailMesh) ConvertToFlatShadedMesh() *Mesh {

	retVal := t.p.Call("convertToFlatShadedMesh")
	return MeshFromJSObject(retVal, t.ctx)
}

// ConvertToUnIndexedMesh calls the ConvertToUnIndexedMesh method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#converttounindexedmesh
func (t *TrailMesh) ConvertToUnIndexedMesh() *Mesh {

	retVal := t.p.Call("convertToUnIndexedMesh")
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateBoxOpts contains optional parameters for TrailMesh.CreateBox.
type TrailMeshCreateBoxOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateBox calls the CreateBox method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createbox
func (t *TrailMesh) CreateBox(name string, size float64, opts *TrailMeshCreateBoxOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshCreateBoxOpts{}
	}

	args := make([]interface{}, 0, 2+3)

	args = append(args, name)
	args = append(args, size)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := t.p.Call("CreateBox", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateCylinderOpts contains optional parameters for TrailMesh.CreateCylinder.
type TrailMeshCreateCylinderOpts struct {
	Scene           *Scene
	Updatable       *interface{}
	SideOrientation *float64
}

// CreateCylinder calls the CreateCylinder method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createcylinder
func (t *TrailMesh) CreateCylinder(name string, height float64, diameterTop float64, diameterBottom float64, tessellation float64, subdivisions interface{}, opts *TrailMeshCreateCylinderOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshCreateCylinderOpts{}
	}

	args := make([]interface{}, 0, 6+3)

	args = append(args, name)
	args = append(args, height)
	args = append(args, diameterTop)
	args = append(args, diameterBottom)
	args = append(args, tessellation)
	args = append(args, subdivisions)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := t.p.Call("CreateCylinder", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateDashedLinesOpts contains optional parameters for TrailMesh.CreateDashedLines.
type TrailMeshCreateDashedLinesOpts struct {
	Scene     *Scene
	Updatable *bool
	Instance  *LinesMesh
}

// CreateDashedLines calls the CreateDashedLines method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createdashedlines
func (t *TrailMesh) CreateDashedLines(name string, points *Vector3, dashSize float64, gapSize float64, dashNb float64, opts *TrailMeshCreateDashedLinesOpts) *LinesMesh {
	if opts == nil {
		opts = &TrailMeshCreateDashedLinesOpts{}
	}

	args := make([]interface{}, 0, 5+3)

	args = append(args, name)
	args = append(args, points.JSObject())
	args = append(args, dashSize)
	args = append(args, gapSize)
	args = append(args, dashNb)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := t.p.Call("CreateDashedLines", args...)
	return LinesMeshFromJSObject(retVal, t.ctx)
}

// CreateDecal calls the CreateDecal method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createdecal
func (t *TrailMesh) CreateDecal(name string, sourceMesh *AbstractMesh, position *Vector3, normal *Vector3, size *Vector3, angle float64) *Mesh {

	args := make([]interface{}, 0, 6+0)

	args = append(args, name)
	args = append(args, sourceMesh.JSObject())
	args = append(args, position.JSObject())
	args = append(args, normal.JSObject())
	args = append(args, size.JSObject())
	args = append(args, angle)

	retVal := t.p.Call("CreateDecal", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateDiscOpts contains optional parameters for TrailMesh.CreateDisc.
type TrailMeshCreateDiscOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateDisc calls the CreateDisc method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createdisc
func (t *TrailMesh) CreateDisc(name string, radius float64, tessellation float64, opts *TrailMeshCreateDiscOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshCreateDiscOpts{}
	}

	args := make([]interface{}, 0, 3+3)

	args = append(args, name)
	args = append(args, radius)
	args = append(args, tessellation)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := t.p.Call("CreateDisc", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateGroundOpts contains optional parameters for TrailMesh.CreateGround.
type TrailMeshCreateGroundOpts struct {
	Scene     *Scene
	Updatable *bool
}

// CreateGround calls the CreateGround method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createground
func (t *TrailMesh) CreateGround(name string, width float64, height float64, subdivisions float64, opts *TrailMeshCreateGroundOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshCreateGroundOpts{}
	}

	args := make([]interface{}, 0, 4+2)

	args = append(args, name)
	args = append(args, width)
	args = append(args, height)
	args = append(args, subdivisions)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}

	retVal := t.p.Call("CreateGround", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateGroundFromHeightMapOpts contains optional parameters for TrailMesh.CreateGroundFromHeightMap.
type TrailMeshCreateGroundFromHeightMapOpts struct {
	Updatable   *bool
	OnReady     func()
	AlphaFilter *float64
}

// CreateGroundFromHeightMap calls the CreateGroundFromHeightMap method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#creategroundfromheightmap
func (t *TrailMesh) CreateGroundFromHeightMap(name string, url string, width float64, height float64, subdivisions float64, minHeight float64, maxHeight float64, scene *Scene, opts *TrailMeshCreateGroundFromHeightMapOpts) *GroundMesh {
	if opts == nil {
		opts = &TrailMeshCreateGroundFromHeightMapOpts{}
	}

	args := make([]interface{}, 0, 8+3)

	args = append(args, name)
	args = append(args, url)
	args = append(args, width)
	args = append(args, height)
	args = append(args, subdivisions)
	args = append(args, minHeight)
	args = append(args, maxHeight)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.OnReady == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.OnReady)
	}
	if opts.AlphaFilter == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AlphaFilter)
	}

	retVal := t.p.Call("CreateGroundFromHeightMap", args...)
	return GroundMeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateHemisphereOpts contains optional parameters for TrailMesh.CreateHemisphere.
type TrailMeshCreateHemisphereOpts struct {
	Scene *Scene
}

// CreateHemisphere calls the CreateHemisphere method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createhemisphere
func (t *TrailMesh) CreateHemisphere(name string, segments float64, diameter float64, opts *TrailMeshCreateHemisphereOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshCreateHemisphereOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	args = append(args, name)
	args = append(args, segments)
	args = append(args, diameter)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}

	retVal := t.p.Call("CreateHemisphere", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// CreateIcoSphere calls the CreateIcoSphere method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createicosphere
func (t *TrailMesh) CreateIcoSphere(name string, options js.Value, scene *Scene) *Mesh {

	args := make([]interface{}, 0, 3+0)

	args = append(args, name)
	args = append(args, options)
	args = append(args, scene.JSObject())

	retVal := t.p.Call("CreateIcoSphere", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// CreateInstance calls the CreateInstance method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createinstance
func (t *TrailMesh) CreateInstance(name string) *InstancedMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := t.p.Call("createInstance", args...)
	return InstancedMeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateLatheOpts contains optional parameters for TrailMesh.CreateLathe.
type TrailMeshCreateLatheOpts struct {
	Updatable       *bool
	SideOrientation *float64
}

// CreateLathe calls the CreateLathe method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createlathe
func (t *TrailMesh) CreateLathe(name string, shape *Vector3, radius float64, tessellation float64, scene *Scene, opts *TrailMeshCreateLatheOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshCreateLatheOpts{}
	}

	args := make([]interface{}, 0, 5+2)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, radius)
	args = append(args, tessellation)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := t.p.Call("CreateLathe", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateLinesOpts contains optional parameters for TrailMesh.CreateLines.
type TrailMeshCreateLinesOpts struct {
	Scene     *Scene
	Updatable *bool
	Instance  *LinesMesh
}

// CreateLines calls the CreateLines method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createlines
func (t *TrailMesh) CreateLines(name string, points *Vector3, opts *TrailMeshCreateLinesOpts) *LinesMesh {
	if opts == nil {
		opts = &TrailMeshCreateLinesOpts{}
	}

	args := make([]interface{}, 0, 2+3)

	args = append(args, name)
	args = append(args, points.JSObject())

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := t.p.Call("CreateLines", args...)
	return LinesMeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreatePlaneOpts contains optional parameters for TrailMesh.CreatePlane.
type TrailMeshCreatePlaneOpts struct {
	Updatable       *bool
	SideOrientation *float64
}

// CreatePlane calls the CreatePlane method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createplane
func (t *TrailMesh) CreatePlane(name string, size float64, scene *Scene, opts *TrailMeshCreatePlaneOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshCreatePlaneOpts{}
	}

	args := make([]interface{}, 0, 3+2)

	args = append(args, name)
	args = append(args, size)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := t.p.Call("CreatePlane", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreatePolygonOpts contains optional parameters for TrailMesh.CreatePolygon.
type TrailMeshCreatePolygonOpts struct {
	Holes           *Vector3
	Updatable       *bool
	SideOrientation *float64
	EarcutInjection *interface{}
}

// CreatePolygon calls the CreatePolygon method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createpolygon
func (t *TrailMesh) CreatePolygon(name string, shape *Vector3, scene *Scene, opts *TrailMeshCreatePolygonOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshCreatePolygonOpts{}
	}

	args := make([]interface{}, 0, 3+4)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, scene.JSObject())

	if opts.Holes == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Holes.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.EarcutInjection == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.EarcutInjection)
	}

	retVal := t.p.Call("CreatePolygon", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// CreatePolyhedron calls the CreatePolyhedron method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createpolyhedron
func (t *TrailMesh) CreatePolyhedron(name string, options js.Value, scene *Scene) *Mesh {

	args := make([]interface{}, 0, 3+0)

	args = append(args, name)
	args = append(args, options)
	args = append(args, scene.JSObject())

	retVal := t.p.Call("CreatePolyhedron", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateRibbonOpts contains optional parameters for TrailMesh.CreateRibbon.
type TrailMeshCreateRibbonOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
	Instance        *Mesh
}

// CreateRibbon calls the CreateRibbon method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createribbon
func (t *TrailMesh) CreateRibbon(name string, pathArray *Vector3, closeArray bool, closePath bool, offset float64, opts *TrailMeshCreateRibbonOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshCreateRibbonOpts{}
	}

	args := make([]interface{}, 0, 5+4)

	args = append(args, name)
	args = append(args, pathArray.JSObject())
	args = append(args, closeArray)
	args = append(args, closePath)
	args = append(args, offset)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := t.p.Call("CreateRibbon", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateSphereOpts contains optional parameters for TrailMesh.CreateSphere.
type TrailMeshCreateSphereOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateSphere calls the CreateSphere method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createsphere
func (t *TrailMesh) CreateSphere(name string, segments float64, diameter float64, opts *TrailMeshCreateSphereOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshCreateSphereOpts{}
	}

	args := make([]interface{}, 0, 3+3)

	args = append(args, name)
	args = append(args, segments)
	args = append(args, diameter)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := t.p.Call("CreateSphere", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateTiledGroundOpts contains optional parameters for TrailMesh.CreateTiledGround.
type TrailMeshCreateTiledGroundOpts struct {
	Updatable *bool
}

// CreateTiledGround calls the CreateTiledGround method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createtiledground
func (t *TrailMesh) CreateTiledGround(name string, xmin float64, zmin float64, xmax float64, zmax float64, subdivisions js.Value, precision js.Value, scene *Scene, opts *TrailMeshCreateTiledGroundOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshCreateTiledGroundOpts{}
	}

	args := make([]interface{}, 0, 8+1)

	args = append(args, name)
	args = append(args, xmin)
	args = append(args, zmin)
	args = append(args, xmax)
	args = append(args, zmax)
	args = append(args, subdivisions)
	args = append(args, precision)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}

	retVal := t.p.Call("CreateTiledGround", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateTorusOpts contains optional parameters for TrailMesh.CreateTorus.
type TrailMeshCreateTorusOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateTorus calls the CreateTorus method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createtorus
func (t *TrailMesh) CreateTorus(name string, diameter float64, thickness float64, tessellation float64, opts *TrailMeshCreateTorusOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshCreateTorusOpts{}
	}

	args := make([]interface{}, 0, 4+3)

	args = append(args, name)
	args = append(args, diameter)
	args = append(args, thickness)
	args = append(args, tessellation)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := t.p.Call("CreateTorus", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateTorusKnotOpts contains optional parameters for TrailMesh.CreateTorusKnot.
type TrailMeshCreateTorusKnotOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateTorusKnot calls the CreateTorusKnot method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createtorusknot
func (t *TrailMesh) CreateTorusKnot(name string, radius float64, tube float64, radialSegments float64, tubularSegments float64, p float64, q float64, opts *TrailMeshCreateTorusKnotOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshCreateTorusKnotOpts{}
	}

	args := make([]interface{}, 0, 7+3)

	args = append(args, name)
	args = append(args, radius)
	args = append(args, tube)
	args = append(args, radialSegments)
	args = append(args, tubularSegments)
	args = append(args, p)
	args = append(args, q)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := t.p.Call("CreateTorusKnot", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshCreateTubeOpts contains optional parameters for TrailMesh.CreateTube.
type TrailMeshCreateTubeOpts struct {
	Updatable       *bool
	SideOrientation *float64
	Instance        *Mesh
}

// CreateTube calls the CreateTube method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#createtube
func (t *TrailMesh) CreateTube(name string, path *Vector3, radius float64, tessellation float64, radiusFunction func(), cap float64, scene *Scene, opts *TrailMeshCreateTubeOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshCreateTubeOpts{}
	}

	args := make([]interface{}, 0, 7+3)

	args = append(args, name)
	args = append(args, path.JSObject())
	args = append(args, radius)
	args = append(args, tessellation)
	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { radiusFunction(); return nil }))
	args = append(args, cap)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := t.p.Call("CreateTube", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshDisposeOpts contains optional parameters for TrailMesh.Dispose.
type TrailMeshDisposeOpts struct {
	DoNotRecurse               *bool
	DisposeMaterialAndTextures *bool
}

// Dispose calls the Dispose method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#dispose
func (t *TrailMesh) Dispose(opts *TrailMeshDisposeOpts) {
	if opts == nil {
		opts = &TrailMeshDisposeOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.DoNotRecurse == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotRecurse)
	}
	if opts.DisposeMaterialAndTextures == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DisposeMaterialAndTextures)
	}

	t.p.Call("dispose", args...)
}

// TrailMeshExtrudePolygonOpts contains optional parameters for TrailMesh.ExtrudePolygon.
type TrailMeshExtrudePolygonOpts struct {
	Holes           *Vector3
	Updatable       *bool
	SideOrientation *float64
	EarcutInjection *interface{}
}

// ExtrudePolygon calls the ExtrudePolygon method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#extrudepolygon
func (t *TrailMesh) ExtrudePolygon(name string, shape *Vector3, depth float64, scene *Scene, opts *TrailMeshExtrudePolygonOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshExtrudePolygonOpts{}
	}

	args := make([]interface{}, 0, 4+4)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, depth)
	args = append(args, scene.JSObject())

	if opts.Holes == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Holes.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.EarcutInjection == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.EarcutInjection)
	}

	retVal := t.p.Call("ExtrudePolygon", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshExtrudeShapeOpts contains optional parameters for TrailMesh.ExtrudeShape.
type TrailMeshExtrudeShapeOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
	Instance        *Mesh
}

// ExtrudeShape calls the ExtrudeShape method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#extrudeshape
func (t *TrailMesh) ExtrudeShape(name string, shape *Vector3, path *Vector3, scale float64, rotation float64, cap float64, opts *TrailMeshExtrudeShapeOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshExtrudeShapeOpts{}
	}

	args := make([]interface{}, 0, 6+4)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, path.JSObject())
	args = append(args, scale)
	args = append(args, rotation)
	args = append(args, cap)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := t.p.Call("ExtrudeShape", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshExtrudeShapeCustomOpts contains optional parameters for TrailMesh.ExtrudeShapeCustom.
type TrailMeshExtrudeShapeCustomOpts struct {
	Updatable       *bool
	SideOrientation *float64
	Instance        *Mesh
}

// ExtrudeShapeCustom calls the ExtrudeShapeCustom method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#extrudeshapecustom
func (t *TrailMesh) ExtrudeShapeCustom(name string, shape *Vector3, path *Vector3, scaleFunction func(), rotationFunction func(), ribbonCloseArray bool, ribbonClosePath bool, cap float64, scene *Scene, opts *TrailMeshExtrudeShapeCustomOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshExtrudeShapeCustomOpts{}
	}

	args := make([]interface{}, 0, 9+3)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, path.JSObject())
	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { scaleFunction(); return nil }))
	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { rotationFunction(); return nil }))
	args = append(args, ribbonCloseArray)
	args = append(args, ribbonClosePath)
	args = append(args, cap)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := t.p.Call("ExtrudeShapeCustom", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshFlipFacesOpts contains optional parameters for TrailMesh.FlipFaces.
type TrailMeshFlipFacesOpts struct {
	FlipNormals *bool
}

// FlipFaces calls the FlipFaces method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#flipfaces
func (t *TrailMesh) FlipFaces(opts *TrailMeshFlipFacesOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshFlipFacesOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.FlipNormals == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FlipNormals)
	}

	retVal := t.p.Call("flipFaces", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// ForceSharedVertices calls the ForceSharedVertices method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#forcesharedvertices
func (t *TrailMesh) ForceSharedVertices() {

	t.p.Call("forceSharedVertices")
}

// FreezeNormals calls the FreezeNormals method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#freezenormals
func (t *TrailMesh) FreezeNormals() *Mesh {

	retVal := t.p.Call("freezeNormals")
	return MeshFromJSObject(retVal, t.ctx)
}

// GetAnimatables calls the GetAnimatables method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#getanimatables
func (t *TrailMesh) GetAnimatables() *IAnimatable {

	retVal := t.p.Call("getAnimatables")
	return IAnimatableFromJSObject(retVal, t.ctx)
}

// GetClassName calls the GetClassName method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#getclassname
func (t *TrailMesh) GetClassName() string {

	retVal := t.p.Call("getClassName")
	return retVal.String()
}

// GetEmittedParticleSystems calls the GetEmittedParticleSystems method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#getemittedparticlesystems
func (t *TrailMesh) GetEmittedParticleSystems() *IParticleSystem {

	retVal := t.p.Call("getEmittedParticleSystems")
	return IParticleSystemFromJSObject(retVal, t.ctx)
}

// GetHierarchyEmittedParticleSystems calls the GetHierarchyEmittedParticleSystems method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#gethierarchyemittedparticlesystems
func (t *TrailMesh) GetHierarchyEmittedParticleSystems() *IParticleSystem {

	retVal := t.p.Call("getHierarchyEmittedParticleSystems")
	return IParticleSystemFromJSObject(retVal, t.ctx)
}

// TrailMeshGetIndicesOpts contains optional parameters for TrailMesh.GetIndices.
type TrailMeshGetIndicesOpts struct {
	CopyWhenShared *bool
	ForceCopy      *bool
}

// GetIndices calls the GetIndices method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#getindices
func (t *TrailMesh) GetIndices(opts *TrailMeshGetIndicesOpts) js.Value {
	if opts == nil {
		opts = &TrailMeshGetIndicesOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.CopyWhenShared == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CopyWhenShared)
	}
	if opts.ForceCopy == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceCopy)
	}

	retVal := t.p.Call("getIndices", args...)
	return retVal
}

// TrailMeshGetLODOpts contains optional parameters for TrailMesh.GetLOD.
type TrailMeshGetLODOpts struct {
	BoundingSphere *BoundingSphere
}

// GetLOD calls the GetLOD method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#getlod
func (t *TrailMesh) GetLOD(camera *Camera, opts *TrailMeshGetLODOpts) *AbstractMesh {
	if opts == nil {
		opts = &TrailMeshGetLODOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, camera.JSObject())

	if opts.BoundingSphere == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.BoundingSphere.JSObject())
	}

	retVal := t.p.Call("getLOD", args...)
	return AbstractMeshFromJSObject(retVal, t.ctx)
}

// GetLODLevelAtDistance calls the GetLODLevelAtDistance method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#getlodlevelatdistance
func (t *TrailMesh) GetLODLevelAtDistance(distance float64) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, distance)

	retVal := t.p.Call("getLODLevelAtDistance", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// GetLODLevels calls the GetLODLevels method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#getlodlevels
func (t *TrailMesh) GetLODLevels() *MeshLODLevel {

	retVal := t.p.Call("getLODLevels")
	return MeshLODLevelFromJSObject(retVal, t.ctx)
}

// GetTotalIndices calls the GetTotalIndices method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#gettotalindices
func (t *TrailMesh) GetTotalIndices() float64 {

	retVal := t.p.Call("getTotalIndices")
	return retVal.Float()
}

// GetTotalVertices calls the GetTotalVertices method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#gettotalvertices
func (t *TrailMesh) GetTotalVertices() float64 {

	retVal := t.p.Call("getTotalVertices")
	return retVal.Float()
}

// GetVertexBuffer calls the GetVertexBuffer method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#getvertexbuffer
func (t *TrailMesh) GetVertexBuffer(kind string) *VertexBuffer {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	retVal := t.p.Call("getVertexBuffer", args...)
	return VertexBufferFromJSObject(retVal, t.ctx)
}

// TrailMeshGetVerticesDataOpts contains optional parameters for TrailMesh.GetVerticesData.
type TrailMeshGetVerticesDataOpts struct {
	CopyWhenShared *bool
	ForceCopy      *bool
}

// GetVerticesData calls the GetVerticesData method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#getverticesdata
func (t *TrailMesh) GetVerticesData(kind string, opts *TrailMeshGetVerticesDataOpts) js.Value {
	if opts == nil {
		opts = &TrailMeshGetVerticesDataOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, kind)

	if opts.CopyWhenShared == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CopyWhenShared)
	}
	if opts.ForceCopy == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceCopy)
	}

	retVal := t.p.Call("getVerticesData", args...)
	return retVal
}

// GetVerticesDataKinds calls the GetVerticesDataKinds method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#getverticesdatakinds
func (t *TrailMesh) GetVerticesDataKinds() string {

	retVal := t.p.Call("getVerticesDataKinds")
	return retVal.String()
}

// IncreaseVertices calls the IncreaseVertices method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#increasevertices
func (t *TrailMesh) IncreaseVertices(numberPerEdge float64) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, numberPerEdge)

	t.p.Call("increaseVertices", args...)
}

// TrailMeshInstantiateHierarchyOpts contains optional parameters for TrailMesh.InstantiateHierarchy.
type TrailMeshInstantiateHierarchyOpts struct {
	NewParent        *TransformNode
	Options          map[string]interface{}
	OnNewNodeCreated func()
}

// InstantiateHierarchy calls the InstantiateHierarchy method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#instantiatehierarchy
func (t *TrailMesh) InstantiateHierarchy(opts *TrailMeshInstantiateHierarchyOpts) *TransformNode {
	if opts == nil {
		opts = &TrailMeshInstantiateHierarchyOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.NewParent == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.NewParent.JSObject())
	}
	if opts.Options == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Options)
	}
	if opts.OnNewNodeCreated == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.OnNewNodeCreated)
	}

	retVal := t.p.Call("instantiateHierarchy", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// IsInFrustum calls the IsInFrustum method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#isinfrustum
func (t *TrailMesh) IsInFrustum(frustumPlanes *Plane) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, frustumPlanes.JSObject())

	retVal := t.p.Call("isInFrustum", args...)
	return retVal.Bool()
}

// TrailMeshIsReadyOpts contains optional parameters for TrailMesh.IsReady.
type TrailMeshIsReadyOpts struct {
	CompleteCheck        *bool
	ForceInstanceSupport *bool
}

// IsReady calls the IsReady method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#isready
func (t *TrailMesh) IsReady(opts *TrailMeshIsReadyOpts) bool {
	if opts == nil {
		opts = &TrailMeshIsReadyOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.CompleteCheck == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CompleteCheck)
	}
	if opts.ForceInstanceSupport == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceInstanceSupport)
	}

	retVal := t.p.Call("isReady", args...)
	return retVal.Bool()
}

// IsVertexBufferUpdatable calls the IsVertexBufferUpdatable method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#isvertexbufferupdatable
func (t *TrailMesh) IsVertexBufferUpdatable(kind string) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	retVal := t.p.Call("isVertexBufferUpdatable", args...)
	return retVal.Bool()
}

// IsVerticesDataPresent calls the IsVerticesDataPresent method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#isverticesdatapresent
func (t *TrailMesh) IsVerticesDataPresent(kind string) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	retVal := t.p.Call("isVerticesDataPresent", args...)
	return retVal.Bool()
}

// MakeGeometryUnique calls the MakeGeometryUnique method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#makegeometryunique
func (t *TrailMesh) MakeGeometryUnique() *Mesh {

	retVal := t.p.Call("makeGeometryUnique")
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshMarkVerticesDataAsUpdatableOpts contains optional parameters for TrailMesh.MarkVerticesDataAsUpdatable.
type TrailMeshMarkVerticesDataAsUpdatableOpts struct {
	Updatable *bool
}

// MarkVerticesDataAsUpdatable calls the MarkVerticesDataAsUpdatable method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#markverticesdataasupdatable
func (t *TrailMesh) MarkVerticesDataAsUpdatable(kind string, opts *TrailMeshMarkVerticesDataAsUpdatableOpts) {
	if opts == nil {
		opts = &TrailMeshMarkVerticesDataAsUpdatableOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, kind)

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}

	t.p.Call("markVerticesDataAsUpdatable", args...)
}

// TrailMeshMergeMeshesOpts contains optional parameters for TrailMesh.MergeMeshes.
type TrailMeshMergeMeshesOpts struct {
	DisposeSource          *bool
	Allow32BitsIndices     *bool
	MeshSubclass           *Mesh
	SubdivideWithSubMeshes *bool
	MultiMultiMaterials    *bool
}

// MergeMeshes calls the MergeMeshes method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#mergemeshes
func (t *TrailMesh) MergeMeshes(meshes []*Mesh, opts *TrailMeshMergeMeshesOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshMergeMeshesOpts{}
	}

	args := make([]interface{}, 0, 1+5)

	args = append(args, MeshArrayToJSArray(meshes))

	if opts.DisposeSource == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DisposeSource)
	}
	if opts.Allow32BitsIndices == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Allow32BitsIndices)
	}
	if opts.MeshSubclass == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.MeshSubclass.JSObject())
	}
	if opts.SubdivideWithSubMeshes == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SubdivideWithSubMeshes)
	}
	if opts.MultiMultiMaterials == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MultiMultiMaterials)
	}

	retVal := t.p.Call("MergeMeshes", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// MinMax calls the MinMax method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#minmax
func (t *TrailMesh) MinMax(meshes *AbstractMesh) js.Value {

	args := make([]interface{}, 0, 1+0)

	args = append(args, meshes.JSObject())

	retVal := t.p.Call("MinMax", args...)
	return retVal
}

// TrailMeshOptimizeIndicesOpts contains optional parameters for TrailMesh.OptimizeIndices.
type TrailMeshOptimizeIndicesOpts struct {
	SuccessCallback func()
}

// OptimizeIndices calls the OptimizeIndices method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#optimizeindices
func (t *TrailMesh) OptimizeIndices(opts *TrailMeshOptimizeIndicesOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshOptimizeIndicesOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.SuccessCallback == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.SuccessCallback)
	}

	retVal := t.p.Call("optimizeIndices", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// Parse calls the Parse method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#parse
func (t *TrailMesh) Parse(parsedMesh interface{}, scene *Scene) *TrailMesh {

	args := make([]interface{}, 0, 2+0)

	args = append(args, parsedMesh)
	args = append(args, scene.JSObject())

	retVal := t.p.Call("Parse", args...)
	return TrailMeshFromJSObject(retVal, t.ctx)
}

// TrailMeshRefreshBoundingInfoOpts contains optional parameters for TrailMesh.RefreshBoundingInfo.
type TrailMeshRefreshBoundingInfoOpts struct {
	ApplySkeleton *bool
}

// RefreshBoundingInfo calls the RefreshBoundingInfo method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#refreshboundinginfo
func (t *TrailMesh) RefreshBoundingInfo(opts *TrailMeshRefreshBoundingInfoOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshRefreshBoundingInfoOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.ApplySkeleton == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ApplySkeleton)
	}

	retVal := t.p.Call("refreshBoundingInfo", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// RegisterAfterRender calls the RegisterAfterRender method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#registerafterrender
func (t *TrailMesh) RegisterAfterRender(jsFunc func()) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	retVal := t.p.Call("registerAfterRender", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// RegisterBeforeRender calls the RegisterBeforeRender method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#registerbeforerender
func (t *TrailMesh) RegisterBeforeRender(jsFunc func()) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	retVal := t.p.Call("registerBeforeRender", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// RegisterInstancedBuffer calls the RegisterInstancedBuffer method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#registerinstancedbuffer
func (t *TrailMesh) RegisterInstancedBuffer(kind string, stride float64) {

	args := make([]interface{}, 0, 2+0)

	args = append(args, kind)
	args = append(args, stride)

	t.p.Call("registerInstancedBuffer", args...)
}

// RemoveLODLevel calls the RemoveLODLevel method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#removelodlevel
func (t *TrailMesh) RemoveLODLevel(mesh *Mesh) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, mesh.JSObject())

	retVal := t.p.Call("removeLODLevel", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// RemoveVerticesData calls the RemoveVerticesData method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#removeverticesdata
func (t *TrailMesh) RemoveVerticesData(kind string) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	t.p.Call("removeVerticesData", args...)
}

// TrailMeshRenderOpts contains optional parameters for TrailMesh.Render.
type TrailMeshRenderOpts struct {
	EffectiveMeshReplacement *AbstractMesh
}

// Render calls the Render method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#render
func (t *TrailMesh) Render(subMesh *SubMesh, enableAlphaMode bool, opts *TrailMeshRenderOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshRenderOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, subMesh.JSObject())
	args = append(args, enableAlphaMode)

	if opts.EffectiveMeshReplacement == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.EffectiveMeshReplacement.JSObject())
	}

	retVal := t.p.Call("render", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// Serialize calls the Serialize method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#serialize
func (t *TrailMesh) Serialize(serializationObject interface{}) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, serializationObject)

	t.p.Call("serialize", args...)
}

// TrailMeshSetIndicesOpts contains optional parameters for TrailMesh.SetIndices.
type TrailMeshSetIndicesOpts struct {
	TotalVertices *float64
	Updatable     *bool
}

// SetIndices calls the SetIndices method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#setindices
func (t *TrailMesh) SetIndices(indices js.Value, opts *TrailMeshSetIndicesOpts) *AbstractMesh {
	if opts == nil {
		opts = &TrailMeshSetIndicesOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, indices)

	if opts.TotalVertices == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.TotalVertices)
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}

	retVal := t.p.Call("setIndices", args...)
	return AbstractMeshFromJSObject(retVal, t.ctx)
}

// SetMaterialByID calls the SetMaterialByID method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#setmaterialbyid
func (t *TrailMesh) SetMaterialByID(id string) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := t.p.Call("setMaterialByID", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// SetNormalsForCPUSkinning calls the SetNormalsForCPUSkinning method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#setnormalsforcpuskinning
func (t *TrailMesh) SetNormalsForCPUSkinning() js.Value {

	retVal := t.p.Call("setNormalsForCPUSkinning")
	return retVal
}

// SetPositionsForCPUSkinning calls the SetPositionsForCPUSkinning method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#setpositionsforcpuskinning
func (t *TrailMesh) SetPositionsForCPUSkinning() js.Value {

	retVal := t.p.Call("setPositionsForCPUSkinning")
	return retVal
}

// SetVerticesBuffer calls the SetVerticesBuffer method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#setverticesbuffer
func (t *TrailMesh) SetVerticesBuffer(buffer *VertexBuffer) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, buffer.JSObject())

	retVal := t.p.Call("setVerticesBuffer", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshSetVerticesDataOpts contains optional parameters for TrailMesh.SetVerticesData.
type TrailMeshSetVerticesDataOpts struct {
	Updatable *bool
	Stride    *float64
}

// SetVerticesData calls the SetVerticesData method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#setverticesdata
func (t *TrailMesh) SetVerticesData(kind string, data js.Value, opts *TrailMeshSetVerticesDataOpts) *AbstractMesh {
	if opts == nil {
		opts = &TrailMeshSetVerticesDataOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, kind)
	args = append(args, data)

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.Stride == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Stride)
	}

	retVal := t.p.Call("setVerticesData", args...)
	return AbstractMeshFromJSObject(retVal, t.ctx)
}

// TrailMeshSimplifyOpts contains optional parameters for TrailMesh.Simplify.
type TrailMeshSimplifyOpts struct {
	ParallelProcessing *bool
	SimplificationType js.Value
	SuccessCallback    func()
}

// Simplify calls the Simplify method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#simplify
func (t *TrailMesh) Simplify(settings []*ISimplificationSettings, opts *TrailMeshSimplifyOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshSimplifyOpts{}
	}

	args := make([]interface{}, 0, 1+3)

	args = append(args, ISimplificationSettingsArrayToJSArray(settings))

	if opts.ParallelProcessing == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ParallelProcessing)
	}
	args = append(args, opts.SimplificationType)
	if opts.SuccessCallback == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.SuccessCallback)
	}

	retVal := t.p.Call("simplify", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// Start calls the Start method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#start
func (t *TrailMesh) Start() {

	t.p.Call("start")
}

// Stop calls the Stop method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#stop
func (t *TrailMesh) Stop() {

	t.p.Call("stop")
}

// Subdivide calls the Subdivide method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#subdivide
func (t *TrailMesh) Subdivide(count float64) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, count)

	t.p.Call("subdivide", args...)
}

// SynchronizeInstances calls the SynchronizeInstances method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#synchronizeinstances
func (t *TrailMesh) SynchronizeInstances() *Mesh {

	retVal := t.p.Call("synchronizeInstances")
	return MeshFromJSObject(retVal, t.ctx)
}

// ToLeftHanded calls the ToLeftHanded method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#tolefthanded
func (t *TrailMesh) ToLeftHanded() *Mesh {

	retVal := t.p.Call("toLeftHanded")
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshToStringOpts contains optional parameters for TrailMesh.ToString.
type TrailMeshToStringOpts struct {
	FullDetails *bool
}

// ToString calls the ToString method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#tostring
func (t *TrailMesh) ToString(opts *TrailMeshToStringOpts) string {
	if opts == nil {
		opts = &TrailMeshToStringOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.FullDetails == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FullDetails)
	}

	retVal := t.p.Call("toString", args...)
	return retVal.String()
}

// UnfreezeNormals calls the UnfreezeNormals method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#unfreezenormals
func (t *TrailMesh) UnfreezeNormals() *Mesh {

	retVal := t.p.Call("unfreezeNormals")
	return MeshFromJSObject(retVal, t.ctx)
}

// UnregisterAfterRender calls the UnregisterAfterRender method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#unregisterafterrender
func (t *TrailMesh) UnregisterAfterRender(jsFunc func()) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	retVal := t.p.Call("unregisterAfterRender", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// UnregisterBeforeRender calls the UnregisterBeforeRender method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#unregisterbeforerender
func (t *TrailMesh) UnregisterBeforeRender(jsFunc func()) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	retVal := t.p.Call("unregisterBeforeRender", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// Update calls the Update method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#update
func (t *TrailMesh) Update() {

	t.p.Call("update")
}

// TrailMeshUpdateIndicesOpts contains optional parameters for TrailMesh.UpdateIndices.
type TrailMeshUpdateIndicesOpts struct {
	Offset        *float64
	GpuMemoryOnly *bool
}

// UpdateIndices calls the UpdateIndices method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#updateindices
func (t *TrailMesh) UpdateIndices(indices js.Value, opts *TrailMeshUpdateIndicesOpts) *AbstractMesh {
	if opts == nil {
		opts = &TrailMeshUpdateIndicesOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, indices)

	if opts.Offset == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Offset)
	}
	if opts.GpuMemoryOnly == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.GpuMemoryOnly)
	}

	retVal := t.p.Call("updateIndices", args...)
	return AbstractMeshFromJSObject(retVal, t.ctx)
}

// TrailMeshUpdateMeshPositionsOpts contains optional parameters for TrailMesh.UpdateMeshPositions.
type TrailMeshUpdateMeshPositionsOpts struct {
	ComputeNormals *bool
}

// UpdateMeshPositions calls the UpdateMeshPositions method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#updatemeshpositions
func (t *TrailMesh) UpdateMeshPositions(positionFunction func(), opts *TrailMeshUpdateMeshPositionsOpts) *Mesh {
	if opts == nil {
		opts = &TrailMeshUpdateMeshPositionsOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { positionFunction(); return nil }))

	if opts.ComputeNormals == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ComputeNormals)
	}

	retVal := t.p.Call("updateMeshPositions", args...)
	return MeshFromJSObject(retVal, t.ctx)
}

// TrailMeshUpdateVerticesDataOpts contains optional parameters for TrailMesh.UpdateVerticesData.
type TrailMeshUpdateVerticesDataOpts struct {
	UpdateExtends *bool
	MakeItUnique  *bool
}

// UpdateVerticesData calls the UpdateVerticesData method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#updateverticesdata
func (t *TrailMesh) UpdateVerticesData(kind string, data js.Value, opts *TrailMeshUpdateVerticesDataOpts) *AbstractMesh {
	if opts == nil {
		opts = &TrailMeshUpdateVerticesDataOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, kind)
	args = append(args, data)

	if opts.UpdateExtends == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UpdateExtends)
	}
	if opts.MakeItUnique == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MakeItUnique)
	}

	retVal := t.p.Call("updateVerticesData", args...)
	return AbstractMeshFromJSObject(retVal, t.ctx)
}

// ValidateSkinning calls the ValidateSkinning method on the TrailMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#validateskinning
func (t *TrailMesh) ValidateSkinning() js.Value {

	retVal := t.p.Call("validateSkinning")
	return retVal
}

/*

// AreNormalsFrozen returns the AreNormalsFrozen property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#arenormalsfrozen
func (t *TrailMesh) AreNormalsFrozen(areNormalsFrozen bool) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(areNormalsFrozen)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetAreNormalsFrozen sets the AreNormalsFrozen property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#arenormalsfrozen
func (t *TrailMesh) SetAreNormalsFrozen(areNormalsFrozen bool) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(areNormalsFrozen)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// BACKSIDE returns the BACKSIDE property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#backside
func (t *TrailMesh) BACKSIDE(BACKSIDE float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(BACKSIDE)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetBACKSIDE sets the BACKSIDE property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#backside
func (t *TrailMesh) SetBACKSIDE(BACKSIDE float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(BACKSIDE)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// BOTTOM returns the BOTTOM property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#bottom
func (t *TrailMesh) BOTTOM(BOTTOM float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(BOTTOM)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetBOTTOM sets the BOTTOM property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#bottom
func (t *TrailMesh) SetBOTTOM(BOTTOM float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(BOTTOM)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// CAP_ALL returns the CAP_ALL property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#cap_all
func (t *TrailMesh) CAP_ALL(CAP_ALL float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(CAP_ALL)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetCAP_ALL sets the CAP_ALL property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#cap_all
func (t *TrailMesh) SetCAP_ALL(CAP_ALL float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(CAP_ALL)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// CAP_END returns the CAP_END property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#cap_end
func (t *TrailMesh) CAP_END(CAP_END float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(CAP_END)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetCAP_END sets the CAP_END property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#cap_end
func (t *TrailMesh) SetCAP_END(CAP_END float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(CAP_END)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// CAP_START returns the CAP_START property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#cap_start
func (t *TrailMesh) CAP_START(CAP_START float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(CAP_START)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetCAP_START sets the CAP_START property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#cap_start
func (t *TrailMesh) SetCAP_START(CAP_START float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(CAP_START)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// CENTER returns the CENTER property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#center
func (t *TrailMesh) CENTER(CENTER float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(CENTER)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetCENTER sets the CENTER property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#center
func (t *TrailMesh) SetCENTER(CENTER float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(CENTER)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// DEFAULTSIDE returns the DEFAULTSIDE property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#defaultside
func (t *TrailMesh) DEFAULTSIDE(DEFAULTSIDE float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(DEFAULTSIDE)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetDEFAULTSIDE sets the DEFAULTSIDE property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#defaultside
func (t *TrailMesh) SetDEFAULTSIDE(DEFAULTSIDE float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(DEFAULTSIDE)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// DOUBLESIDE returns the DOUBLESIDE property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#doubleside
func (t *TrailMesh) DOUBLESIDE(DOUBLESIDE float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(DOUBLESIDE)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetDOUBLESIDE sets the DOUBLESIDE property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#doubleside
func (t *TrailMesh) SetDOUBLESIDE(DOUBLESIDE float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(DOUBLESIDE)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// DelayLoadState returns the DelayLoadState property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#delayloadstate
func (t *TrailMesh) DelayLoadState(delayLoadState float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(delayLoadState)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetDelayLoadState sets the DelayLoadState property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#delayloadstate
func (t *TrailMesh) SetDelayLoadState(delayLoadState float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(delayLoadState)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// DelayLoadingFile returns the DelayLoadingFile property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#delayloadingfile
func (t *TrailMesh) DelayLoadingFile(delayLoadingFile string) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(delayLoadingFile)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetDelayLoadingFile sets the DelayLoadingFile property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#delayloadingfile
func (t *TrailMesh) SetDelayLoadingFile(delayLoadingFile string) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(delayLoadingFile)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// FLIP_N_ROTATE_ROW returns the FLIP_N_ROTATE_ROW property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#flip_n_rotate_row
func (t *TrailMesh) FLIP_N_ROTATE_ROW(FLIP_N_ROTATE_ROW float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(FLIP_N_ROTATE_ROW)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetFLIP_N_ROTATE_ROW sets the FLIP_N_ROTATE_ROW property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#flip_n_rotate_row
func (t *TrailMesh) SetFLIP_N_ROTATE_ROW(FLIP_N_ROTATE_ROW float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(FLIP_N_ROTATE_ROW)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// FLIP_N_ROTATE_TILE returns the FLIP_N_ROTATE_TILE property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#flip_n_rotate_tile
func (t *TrailMesh) FLIP_N_ROTATE_TILE(FLIP_N_ROTATE_TILE float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(FLIP_N_ROTATE_TILE)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetFLIP_N_ROTATE_TILE sets the FLIP_N_ROTATE_TILE property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#flip_n_rotate_tile
func (t *TrailMesh) SetFLIP_N_ROTATE_TILE(FLIP_N_ROTATE_TILE float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(FLIP_N_ROTATE_TILE)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// FLIP_ROW returns the FLIP_ROW property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#flip_row
func (t *TrailMesh) FLIP_ROW(FLIP_ROW float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(FLIP_ROW)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetFLIP_ROW sets the FLIP_ROW property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#flip_row
func (t *TrailMesh) SetFLIP_ROW(FLIP_ROW float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(FLIP_ROW)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// FLIP_TILE returns the FLIP_TILE property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#flip_tile
func (t *TrailMesh) FLIP_TILE(FLIP_TILE float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(FLIP_TILE)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetFLIP_TILE sets the FLIP_TILE property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#flip_tile
func (t *TrailMesh) SetFLIP_TILE(FLIP_TILE float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(FLIP_TILE)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// FRONTSIDE returns the FRONTSIDE property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#frontside
func (t *TrailMesh) FRONTSIDE(FRONTSIDE float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(FRONTSIDE)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetFRONTSIDE sets the FRONTSIDE property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#frontside
func (t *TrailMesh) SetFRONTSIDE(FRONTSIDE float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(FRONTSIDE)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// Geometry returns the Geometry property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#geometry
func (t *TrailMesh) Geometry(geometry *Geometry) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(geometry.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetGeometry sets the Geometry property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#geometry
func (t *TrailMesh) SetGeometry(geometry *Geometry) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(geometry.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// HasInstances returns the HasInstances property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#hasinstances
func (t *TrailMesh) HasInstances(hasInstances bool) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(hasInstances)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetHasInstances sets the HasInstances property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#hasinstances
func (t *TrailMesh) SetHasInstances(hasInstances bool) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(hasInstances)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// HasLODLevels returns the HasLODLevels property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#haslodlevels
func (t *TrailMesh) HasLODLevels(hasLODLevels bool) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(hasLODLevels)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetHasLODLevels sets the HasLODLevels property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#haslodlevels
func (t *TrailMesh) SetHasLODLevels(hasLODLevels bool) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(hasLODLevels)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// InstancedBuffers returns the InstancedBuffers property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#instancedbuffers
func (t *TrailMesh) InstancedBuffers(instancedBuffers js.Value) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(instancedBuffers)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetInstancedBuffers sets the InstancedBuffers property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#instancedbuffers
func (t *TrailMesh) SetInstancedBuffers(instancedBuffers js.Value) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(instancedBuffers)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// Instances returns the Instances property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#instances
func (t *TrailMesh) Instances(instances *InstancedMesh) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(instances.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetInstances sets the Instances property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#instances
func (t *TrailMesh) SetInstances(instances *InstancedMesh) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(instances.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// IsBlocked returns the IsBlocked property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#isblocked
func (t *TrailMesh) IsBlocked(isBlocked bool) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(isBlocked)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetIsBlocked sets the IsBlocked property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#isblocked
func (t *TrailMesh) SetIsBlocked(isBlocked bool) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(isBlocked)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// IsUnIndexed returns the IsUnIndexed property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#isunindexed
func (t *TrailMesh) IsUnIndexed(isUnIndexed bool) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(isUnIndexed)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetIsUnIndexed sets the IsUnIndexed property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#isunindexed
func (t *TrailMesh) SetIsUnIndexed(isUnIndexed bool) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(isUnIndexed)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// LEFT returns the LEFT property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#left
func (t *TrailMesh) LEFT(LEFT float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(LEFT)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetLEFT sets the LEFT property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#left
func (t *TrailMesh) SetLEFT(LEFT float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(LEFT)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// ManualUpdateOfWorldMatrixInstancedBuffer returns the ManualUpdateOfWorldMatrixInstancedBuffer property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#manualupdateofworldmatrixinstancedbuffer
func (t *TrailMesh) ManualUpdateOfWorldMatrixInstancedBuffer(manualUpdateOfWorldMatrixInstancedBuffer bool) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(manualUpdateOfWorldMatrixInstancedBuffer)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetManualUpdateOfWorldMatrixInstancedBuffer sets the ManualUpdateOfWorldMatrixInstancedBuffer property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#manualupdateofworldmatrixinstancedbuffer
func (t *TrailMesh) SetManualUpdateOfWorldMatrixInstancedBuffer(manualUpdateOfWorldMatrixInstancedBuffer bool) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(manualUpdateOfWorldMatrixInstancedBuffer)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// MorphTargetManager returns the MorphTargetManager property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#morphtargetmanager
func (t *TrailMesh) MorphTargetManager(morphTargetManager *MorphTargetManager) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(morphTargetManager.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetMorphTargetManager sets the MorphTargetManager property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#morphtargetmanager
func (t *TrailMesh) SetMorphTargetManager(morphTargetManager *MorphTargetManager) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(morphTargetManager.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// NO_CAP returns the NO_CAP property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#no_cap
func (t *TrailMesh) NO_CAP(NO_CAP float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(NO_CAP)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetNO_CAP sets the NO_CAP property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#no_cap
func (t *TrailMesh) SetNO_CAP(NO_CAP float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(NO_CAP)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// NO_FLIP returns the NO_FLIP property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#no_flip
func (t *TrailMesh) NO_FLIP(NO_FLIP float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(NO_FLIP)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetNO_FLIP sets the NO_FLIP property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#no_flip
func (t *TrailMesh) SetNO_FLIP(NO_FLIP float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(NO_FLIP)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// OnAfterRenderObservable returns the OnAfterRenderObservable property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#onafterrenderobservable
func (t *TrailMesh) OnAfterRenderObservable(onAfterRenderObservable *Observable) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(onAfterRenderObservable.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetOnAfterRenderObservable sets the OnAfterRenderObservable property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#onafterrenderobservable
func (t *TrailMesh) SetOnAfterRenderObservable(onAfterRenderObservable *Observable) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(onAfterRenderObservable.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// OnBeforeBindObservable returns the OnBeforeBindObservable property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#onbeforebindobservable
func (t *TrailMesh) OnBeforeBindObservable(onBeforeBindObservable *Observable) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(onBeforeBindObservable.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetOnBeforeBindObservable sets the OnBeforeBindObservable property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#onbeforebindobservable
func (t *TrailMesh) SetOnBeforeBindObservable(onBeforeBindObservable *Observable) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(onBeforeBindObservable.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// OnBeforeDraw returns the OnBeforeDraw property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#onbeforedraw
func (t *TrailMesh) OnBeforeDraw(onBeforeDraw func()) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(js.FuncOf(func(this js.Value, args []js.Value) interface{} {onBeforeDraw(); return nil}))
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetOnBeforeDraw sets the OnBeforeDraw property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#onbeforedraw
func (t *TrailMesh) SetOnBeforeDraw(onBeforeDraw func()) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(js.FuncOf(func(this js.Value, args []js.Value) interface{} {onBeforeDraw(); return nil}))
	return TrailMeshFromJSObject(p, ba.ctx)
}

// OnBeforeDrawObservable returns the OnBeforeDrawObservable property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#onbeforedrawobservable
func (t *TrailMesh) OnBeforeDrawObservable(onBeforeDrawObservable *Observable) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(onBeforeDrawObservable.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetOnBeforeDrawObservable sets the OnBeforeDrawObservable property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#onbeforedrawobservable
func (t *TrailMesh) SetOnBeforeDrawObservable(onBeforeDrawObservable *Observable) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(onBeforeDrawObservable.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// OnBeforeRenderObservable returns the OnBeforeRenderObservable property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#onbeforerenderobservable
func (t *TrailMesh) OnBeforeRenderObservable(onBeforeRenderObservable *Observable) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(onBeforeRenderObservable.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetOnBeforeRenderObservable sets the OnBeforeRenderObservable property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#onbeforerenderobservable
func (t *TrailMesh) SetOnBeforeRenderObservable(onBeforeRenderObservable *Observable) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(onBeforeRenderObservable.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// OnLODLevelSelection returns the OnLODLevelSelection property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#onlodlevelselection
func (t *TrailMesh) OnLODLevelSelection(onLODLevelSelection func()) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(js.FuncOf(func(this js.Value, args []js.Value) interface{} {onLODLevelSelection(); return nil}))
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetOnLODLevelSelection sets the OnLODLevelSelection property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#onlodlevelselection
func (t *TrailMesh) SetOnLODLevelSelection(onLODLevelSelection func()) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(js.FuncOf(func(this js.Value, args []js.Value) interface{} {onLODLevelSelection(); return nil}))
	return TrailMeshFromJSObject(p, ba.ctx)
}

// OverrideMaterialSideOrientation returns the OverrideMaterialSideOrientation property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#overridematerialsideorientation
func (t *TrailMesh) OverrideMaterialSideOrientation(overrideMaterialSideOrientation float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(overrideMaterialSideOrientation)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetOverrideMaterialSideOrientation sets the OverrideMaterialSideOrientation property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#overridematerialsideorientation
func (t *TrailMesh) SetOverrideMaterialSideOrientation(overrideMaterialSideOrientation float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(overrideMaterialSideOrientation)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// OverridenInstanceCount returns the OverridenInstanceCount property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#overrideninstancecount
func (t *TrailMesh) OverridenInstanceCount(overridenInstanceCount float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(overridenInstanceCount)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetOverridenInstanceCount sets the OverridenInstanceCount property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#overrideninstancecount
func (t *TrailMesh) SetOverridenInstanceCount(overridenInstanceCount float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(overridenInstanceCount)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// RIGHT returns the RIGHT property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#right
func (t *TrailMesh) RIGHT(RIGHT float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(RIGHT)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetRIGHT sets the RIGHT property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#right
func (t *TrailMesh) SetRIGHT(RIGHT float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(RIGHT)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// ROTATE_ROW returns the ROTATE_ROW property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#rotate_row
func (t *TrailMesh) ROTATE_ROW(ROTATE_ROW float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(ROTATE_ROW)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetROTATE_ROW sets the ROTATE_ROW property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#rotate_row
func (t *TrailMesh) SetROTATE_ROW(ROTATE_ROW float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(ROTATE_ROW)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// ROTATE_TILE returns the ROTATE_TILE property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#rotate_tile
func (t *TrailMesh) ROTATE_TILE(ROTATE_TILE float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(ROTATE_TILE)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetROTATE_TILE sets the ROTATE_TILE property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#rotate_tile
func (t *TrailMesh) SetROTATE_TILE(ROTATE_TILE float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(ROTATE_TILE)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// Source returns the Source property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#source
func (t *TrailMesh) Source(source *Mesh) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(source.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetSource sets the Source property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#source
func (t *TrailMesh) SetSource(source *Mesh) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(source.JSObject())
	return TrailMeshFromJSObject(p, ba.ctx)
}

// TOP returns the TOP property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#top
func (t *TrailMesh) TOP(TOP float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(TOP)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetTOP sets the TOP property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#top
func (t *TrailMesh) SetTOP(TOP float64) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(TOP)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// WorldMatrixInstancedBuffer returns the WorldMatrixInstancedBuffer property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#worldmatrixinstancedbuffer
func (t *TrailMesh) WorldMatrixInstancedBuffer(worldMatrixInstancedBuffer js.Value) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(worldMatrixInstancedBuffer)
	return TrailMeshFromJSObject(p, ba.ctx)
}

// SetWorldMatrixInstancedBuffer sets the WorldMatrixInstancedBuffer property of class TrailMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.trailmesh#worldmatrixinstancedbuffer
func (t *TrailMesh) SetWorldMatrixInstancedBuffer(worldMatrixInstancedBuffer js.Value) *TrailMesh {
	p := ba.ctx.Get("TrailMesh").New(worldMatrixInstancedBuffer)
	return TrailMeshFromJSObject(p, ba.ctx)
}

*/

// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// PointsCloudSystem represents a babylon.js PointsCloudSystem.
// The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.
// As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.
// The PointCloudSytem is also a particle system, with each point being a particle. It provides some methods to manage the particles.
// However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.
//
// Full documentation here : TO BE ENTERED
type PointsCloudSystem struct {
	p   js.Value
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (p *PointsCloudSystem) JSObject() js.Value { return p.p }

// PointsCloudSystem returns a PointsCloudSystem JavaScript class.
func (ba *Babylon) PointsCloudSystem() *PointsCloudSystem {
	p := ba.ctx.Get("PointsCloudSystem")
	return PointsCloudSystemFromJSObject(p, ba.ctx)
}

// PointsCloudSystemFromJSObject returns a wrapped PointsCloudSystem JavaScript class.
func PointsCloudSystemFromJSObject(p js.Value, ctx js.Value) *PointsCloudSystem {
	return &PointsCloudSystem{p: p, ctx: ctx}
}

// PointsCloudSystemArrayToJSArray returns a JavaScript Array for the wrapped array.
func PointsCloudSystemArrayToJSArray(array []*PointsCloudSystem) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewPointsCloudSystemOpts contains optional parameters for NewPointsCloudSystem.
type NewPointsCloudSystemOpts struct {
	Options map[string]interface{}
}

// NewPointsCloudSystem returns a new PointsCloudSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem
func (ba *Babylon) NewPointsCloudSystem(name string, pointSize float64, scene *Scene, opts *NewPointsCloudSystemOpts) *PointsCloudSystem {
	if opts == nil {
		opts = &NewPointsCloudSystemOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	args = append(args, name)
	args = append(args, pointSize)
	args = append(args, scene.JSObject())

	if opts.Options == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Options)
	}

	p := ba.ctx.Get("PointsCloudSystem").New(args...)
	return PointsCloudSystemFromJSObject(p, ba.ctx)
}

// PointsCloudSystemAddPointsOpts contains optional parameters for PointsCloudSystem.AddPoints.
type PointsCloudSystemAddPointsOpts struct {
	PointFunction *interface{}
}

// AddPoints calls the AddPoints method on the PointsCloudSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#addpoints
func (p *PointsCloudSystem) AddPoints(nb float64, opts *PointsCloudSystemAddPointsOpts) float64 {
	if opts == nil {
		opts = &PointsCloudSystemAddPointsOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, nb)

	if opts.PointFunction == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.PointFunction)
	}

	retVal := p.p.Call("addPoints", args...)
	return retVal.Float()
}

// PointsCloudSystemAddSurfacePointsOpts contains optional parameters for PointsCloudSystem.AddSurfacePoints.
type PointsCloudSystemAddSurfacePointsOpts struct {
	ColorWith *float64
	Color     *Color4
	Range     *float64
}

// AddSurfacePoints calls the AddSurfacePoints method on the PointsCloudSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#addsurfacepoints
func (p *PointsCloudSystem) AddSurfacePoints(mesh *Mesh, nb float64, opts *PointsCloudSystemAddSurfacePointsOpts) float64 {
	if opts == nil {
		opts = &PointsCloudSystemAddSurfacePointsOpts{}
	}

	args := make([]interface{}, 0, 2+3)

	args = append(args, mesh.JSObject())
	args = append(args, nb)

	if opts.ColorWith == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ColorWith)
	}
	if opts.Color == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Color.JSObject())
	}
	if opts.Range == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Range)
	}

	retVal := p.p.Call("addSurfacePoints", args...)
	return retVal.Float()
}

// PointsCloudSystemAddVolumePointsOpts contains optional parameters for PointsCloudSystem.AddVolumePoints.
type PointsCloudSystemAddVolumePointsOpts struct {
	ColorWith *float64
	Color     *Color4
	Range     *float64
}

// AddVolumePoints calls the AddVolumePoints method on the PointsCloudSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#addvolumepoints
func (p *PointsCloudSystem) AddVolumePoints(mesh *Mesh, nb float64, opts *PointsCloudSystemAddVolumePointsOpts) float64 {
	if opts == nil {
		opts = &PointsCloudSystemAddVolumePointsOpts{}
	}

	args := make([]interface{}, 0, 2+3)

	args = append(args, mesh.JSObject())
	args = append(args, nb)

	if opts.ColorWith == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ColorWith)
	}
	if opts.Color == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Color.JSObject())
	}
	if opts.Range == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Range)
	}

	retVal := p.p.Call("addVolumePoints", args...)
	return retVal.Float()
}

// PointsCloudSystemAfterUpdateParticlesOpts contains optional parameters for PointsCloudSystem.AfterUpdateParticles.
type PointsCloudSystemAfterUpdateParticlesOpts struct {
	Start  *float64
	Stop   *float64
	Update *bool
}

// AfterUpdateParticles calls the AfterUpdateParticles method on the PointsCloudSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#afterupdateparticles
func (p *PointsCloudSystem) AfterUpdateParticles(opts *PointsCloudSystemAfterUpdateParticlesOpts) {
	if opts == nil {
		opts = &PointsCloudSystemAfterUpdateParticlesOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.Start == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Start)
	}
	if opts.Stop == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Stop)
	}
	if opts.Update == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Update)
	}

	p.p.Call("afterUpdateParticles", args...)
}

// PointsCloudSystemBeforeUpdateParticlesOpts contains optional parameters for PointsCloudSystem.BeforeUpdateParticles.
type PointsCloudSystemBeforeUpdateParticlesOpts struct {
	Start  *float64
	Stop   *float64
	Update *bool
}

// BeforeUpdateParticles calls the BeforeUpdateParticles method on the PointsCloudSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#beforeupdateparticles
func (p *PointsCloudSystem) BeforeUpdateParticles(opts *PointsCloudSystemBeforeUpdateParticlesOpts) {
	if opts == nil {
		opts = &PointsCloudSystemBeforeUpdateParticlesOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.Start == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Start)
	}
	if opts.Stop == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Stop)
	}
	if opts.Update == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Update)
	}

	p.p.Call("beforeUpdateParticles", args...)
}

// BuildMeshAsync calls the BuildMeshAsync method on the PointsCloudSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#buildmeshasync
func (p *PointsCloudSystem) BuildMeshAsync() *Promise {

	retVal := p.p.Call("buildMeshAsync")
	return PromiseFromJSObject(retVal, p.ctx)
}

// Dispose calls the Dispose method on the PointsCloudSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#dispose
func (p *PointsCloudSystem) Dispose() {

	p.p.Call("dispose")
}

// InitParticles calls the InitParticles method on the PointsCloudSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#initparticles
func (p *PointsCloudSystem) InitParticles() {

	p.p.Call("initParticles")
}

// RecycleParticle calls the RecycleParticle method on the PointsCloudSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#recycleparticle
func (p *PointsCloudSystem) RecycleParticle(particle *CloudPoint) *CloudPoint {

	args := make([]interface{}, 0, 1+0)

	args = append(args, particle.JSObject())

	retVal := p.p.Call("recycleParticle", args...)
	return CloudPointFromJSObject(retVal, p.ctx)
}

// RefreshVisibleSize calls the RefreshVisibleSize method on the PointsCloudSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#refreshvisiblesize
func (p *PointsCloudSystem) RefreshVisibleSize() *PointsCloudSystem {

	retVal := p.p.Call("refreshVisibleSize")
	return PointsCloudSystemFromJSObject(retVal, p.ctx)
}

// PointsCloudSystemSetParticlesOpts contains optional parameters for PointsCloudSystem.SetParticles.
type PointsCloudSystemSetParticlesOpts struct {
	Start  *float64
	End    *float64
	Update *bool
}

// SetParticles calls the SetParticles method on the PointsCloudSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#setparticles
func (p *PointsCloudSystem) SetParticles(opts *PointsCloudSystemSetParticlesOpts) *PointsCloudSystem {
	if opts == nil {
		opts = &PointsCloudSystemSetParticlesOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.Start == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Start)
	}
	if opts.End == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.End)
	}
	if opts.Update == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Update)
	}

	retVal := p.p.Call("setParticles", args...)
	return PointsCloudSystemFromJSObject(retVal, p.ctx)
}

// SetVisibilityBox calls the SetVisibilityBox method on the PointsCloudSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#setvisibilitybox
func (p *PointsCloudSystem) SetVisibilityBox(size float64) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, size)

	p.p.Call("setVisibilityBox", args...)
}

// UpdateParticle calls the UpdateParticle method on the PointsCloudSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#updateparticle
func (p *PointsCloudSystem) UpdateParticle(particle *CloudPoint) *CloudPoint {

	args := make([]interface{}, 0, 1+0)

	args = append(args, particle.JSObject())

	retVal := p.p.Call("updateParticle", args...)
	return CloudPointFromJSObject(retVal, p.ctx)
}

// ComputeBoundingBox returns the ComputeBoundingBox property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#computeboundingbox
func (p *PointsCloudSystem) ComputeBoundingBox() bool {
	retVal := p.p.Get("computeBoundingBox")
	return retVal.Bool()
}

// SetComputeBoundingBox sets the ComputeBoundingBox property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#computeboundingbox
func (p *PointsCloudSystem) SetComputeBoundingBox(computeBoundingBox bool) *PointsCloudSystem {
	p.p.Set("computeBoundingBox", computeBoundingBox)
	return p
}

// ComputeParticleColor returns the ComputeParticleColor property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#computeparticlecolor
func (p *PointsCloudSystem) ComputeParticleColor() bool {
	retVal := p.p.Get("computeParticleColor")
	return retVal.Bool()
}

// SetComputeParticleColor sets the ComputeParticleColor property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#computeparticlecolor
func (p *PointsCloudSystem) SetComputeParticleColor(computeParticleColor bool) *PointsCloudSystem {
	p.p.Set("computeParticleColor", computeParticleColor)
	return p
}

// ComputeParticleRotation returns the ComputeParticleRotation property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#computeparticlerotation
func (p *PointsCloudSystem) ComputeParticleRotation() bool {
	retVal := p.p.Get("computeParticleRotation")
	return retVal.Bool()
}

// SetComputeParticleRotation sets the ComputeParticleRotation property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#computeparticlerotation
func (p *PointsCloudSystem) SetComputeParticleRotation(computeParticleRotation bool) *PointsCloudSystem {
	p.p.Set("computeParticleRotation", computeParticleRotation)
	return p
}

// ComputeParticleTexture returns the ComputeParticleTexture property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#computeparticletexture
func (p *PointsCloudSystem) ComputeParticleTexture() bool {
	retVal := p.p.Get("computeParticleTexture")
	return retVal.Bool()
}

// SetComputeParticleTexture sets the ComputeParticleTexture property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#computeparticletexture
func (p *PointsCloudSystem) SetComputeParticleTexture(computeParticleTexture bool) *PointsCloudSystem {
	p.p.Set("computeParticleTexture", computeParticleTexture)
	return p
}

// Counter returns the Counter property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#counter
func (p *PointsCloudSystem) Counter() float64 {
	retVal := p.p.Get("counter")
	return retVal.Float()
}

// SetCounter sets the Counter property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#counter
func (p *PointsCloudSystem) SetCounter(counter float64) *PointsCloudSystem {
	p.p.Set("counter", counter)
	return p
}

// IsAlwaysVisible returns the IsAlwaysVisible property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#isalwaysvisible
func (p *PointsCloudSystem) IsAlwaysVisible() bool {
	retVal := p.p.Get("isAlwaysVisible")
	return retVal.Bool()
}

// SetIsAlwaysVisible sets the IsAlwaysVisible property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#isalwaysvisible
func (p *PointsCloudSystem) SetIsAlwaysVisible(isAlwaysVisible bool) *PointsCloudSystem {
	p.p.Set("isAlwaysVisible", isAlwaysVisible)
	return p
}

// Mesh returns the Mesh property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#mesh
func (p *PointsCloudSystem) Mesh() *Mesh {
	retVal := p.p.Get("mesh")
	return MeshFromJSObject(retVal, p.ctx)
}

// SetMesh sets the Mesh property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#mesh
func (p *PointsCloudSystem) SetMesh(mesh *Mesh) *PointsCloudSystem {
	p.p.Set("mesh", mesh.JSObject())
	return p
}

// Name returns the Name property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#name
func (p *PointsCloudSystem) Name() string {
	retVal := p.p.Get("name")
	return retVal.String()
}

// SetName sets the Name property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#name
func (p *PointsCloudSystem) SetName(name string) *PointsCloudSystem {
	p.p.Set("name", name)
	return p
}

// NbParticles returns the NbParticles property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#nbparticles
func (p *PointsCloudSystem) NbParticles() float64 {
	retVal := p.p.Get("nbParticles")
	return retVal.Float()
}

// SetNbParticles sets the NbParticles property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#nbparticles
func (p *PointsCloudSystem) SetNbParticles(nbParticles float64) *PointsCloudSystem {
	p.p.Set("nbParticles", nbParticles)
	return p
}

// Particles returns the Particles property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#particles
func (p *PointsCloudSystem) Particles() []*CloudPoint {
	retVal := p.p.Get("particles")
	result := []*CloudPoint{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, CloudPointFromJSObject(retVal.Index(ri), p.ctx))
	}
	return result
}

// Vars returns the Vars property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#vars
func (p *PointsCloudSystem) Vars() interface{} {
	retVal := p.p.Get("vars")
	return retVal
}

// SetVars sets the Vars property of class PointsCloudSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.pointscloudsystem#vars
func (p *PointsCloudSystem) SetVars(vars interface{}) *PointsCloudSystem {
	p.p.Set("vars", vars)
	return p
}

// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// AbstractMesh represents a babylon.js AbstractMesh.
// Class used to store all common mesh properties
type AbstractMesh struct {
	*TransformNode
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (a *AbstractMesh) JSObject() js.Value { return a.p }

// AbstractMesh returns a AbstractMesh JavaScript class.
func (ba *Babylon) AbstractMesh() *AbstractMesh {
	p := ba.ctx.Get("AbstractMesh")
	return AbstractMeshFromJSObject(p, ba.ctx)
}

// AbstractMeshFromJSObject returns a wrapped AbstractMesh JavaScript class.
func AbstractMeshFromJSObject(p js.Value, ctx js.Value) *AbstractMesh {
	return &AbstractMesh{TransformNode: TransformNodeFromJSObject(p, ctx), ctx: ctx}
}

// AbstractMeshArrayToJSArray returns a JavaScript Array for the wrapped array.
func AbstractMeshArrayToJSArray(array []*AbstractMesh) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewAbstractMeshOpts contains optional parameters for NewAbstractMesh.
type NewAbstractMeshOpts struct {
	Scene *Scene
}

// NewAbstractMesh returns a new AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh
func (ba *Babylon) NewAbstractMesh(name string, opts *NewAbstractMeshOpts) *AbstractMesh {
	if opts == nil {
		opts = &NewAbstractMeshOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, name)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}

	p := ba.ctx.Get("AbstractMesh").New(args...)
	return AbstractMeshFromJSObject(p, ba.ctx)
}

// AddChild calls the AddChild method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#addchild
func (a *AbstractMesh) AddChild(mesh *AbstractMesh) *AbstractMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, mesh.JSObject())

	retVal := a.p.Call("addChild", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// AbstractMeshAlignWithNormalOpts contains optional parameters for AbstractMesh.AlignWithNormal.
type AbstractMeshAlignWithNormalOpts struct {
	UpDirection *Vector3
}

// AlignWithNormal calls the AlignWithNormal method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#alignwithnormal
func (a *AbstractMesh) AlignWithNormal(normal *Vector3, opts *AbstractMeshAlignWithNormalOpts) *AbstractMesh {
	if opts == nil {
		opts = &AbstractMeshAlignWithNormalOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, normal.JSObject())

	if opts.UpDirection == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.UpDirection.JSObject())
	}

	retVal := a.p.Call("alignWithNormal", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// ApplyImpulse calls the ApplyImpulse method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#applyimpulse
func (a *AbstractMesh) ApplyImpulse(force *Vector3, contactPoint *Vector3) *AbstractMesh {

	args := make([]interface{}, 0, 2+0)

	args = append(args, force.JSObject())
	args = append(args, contactPoint.JSObject())

	retVal := a.p.Call("applyImpulse", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// CalcMovePOV calls the CalcMovePOV method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#calcmovepov
func (a *AbstractMesh) CalcMovePOV(amountRight float64, amountUp float64, amountForward float64) *Vector3 {

	args := make([]interface{}, 0, 3+0)

	args = append(args, amountRight)
	args = append(args, amountUp)
	args = append(args, amountForward)

	retVal := a.p.Call("calcMovePOV", args...)
	return Vector3FromJSObject(retVal, a.ctx)
}

// CalcRotatePOV calls the CalcRotatePOV method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#calcrotatepov
func (a *AbstractMesh) CalcRotatePOV(flipBack float64, twirlClockwise float64, tiltRight float64) *Vector3 {

	args := make([]interface{}, 0, 3+0)

	args = append(args, flipBack)
	args = append(args, twirlClockwise)
	args = append(args, tiltRight)

	retVal := a.p.Call("calcRotatePOV", args...)
	return Vector3FromJSObject(retVal, a.ctx)
}

// AbstractMeshCloneOpts contains optional parameters for AbstractMesh.Clone.
type AbstractMeshCloneOpts struct {
	DoNotCloneChildren *bool
}

// Clone calls the Clone method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#clone
func (a *AbstractMesh) Clone(name string, newParent *Node, opts *AbstractMeshCloneOpts) *AbstractMesh {
	if opts == nil {
		opts = &AbstractMeshCloneOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, name)
	args = append(args, newParent.JSObject())

	if opts.DoNotCloneChildren == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotCloneChildren)
	}

	retVal := a.p.Call("clone", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// CreateNormals calls the CreateNormals method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#createnormals
func (a *AbstractMesh) CreateNormals(updatable bool) *AbstractMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, updatable)

	retVal := a.p.Call("createNormals", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// AbstractMeshCreateOrUpdateSubmeshesOctreeOpts contains optional parameters for AbstractMesh.CreateOrUpdateSubmeshesOctree.
type AbstractMeshCreateOrUpdateSubmeshesOctreeOpts struct {
	MaxCapacity *float64
	MaxDepth    *float64
}

// CreateOrUpdateSubmeshesOctree calls the CreateOrUpdateSubmeshesOctree method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#createorupdatesubmeshesoctree
func (a *AbstractMesh) CreateOrUpdateSubmeshesOctree(opts *AbstractMeshCreateOrUpdateSubmeshesOctreeOpts) *Octree {
	if opts == nil {
		opts = &AbstractMeshCreateOrUpdateSubmeshesOctreeOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.MaxCapacity == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MaxCapacity)
	}
	if opts.MaxDepth == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MaxDepth)
	}

	retVal := a.p.Call("createOrUpdateSubmeshesOctree", args...)
	return OctreeFromJSObject(retVal, a.ctx)
}

// DisableEdgesRendering calls the DisableEdgesRendering method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#disableedgesrendering
func (a *AbstractMesh) DisableEdgesRendering() *AbstractMesh {

	retVal := a.p.Call("disableEdgesRendering")
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// DisableFacetData calls the DisableFacetData method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#disablefacetdata
func (a *AbstractMesh) DisableFacetData() *AbstractMesh {

	retVal := a.p.Call("disableFacetData")
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// AbstractMeshDisposeOpts contains optional parameters for AbstractMesh.Dispose.
type AbstractMeshDisposeOpts struct {
	DoNotRecurse               *bool
	DisposeMaterialAndTextures *bool
}

// Dispose calls the Dispose method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#dispose
func (a *AbstractMesh) Dispose(opts *AbstractMeshDisposeOpts) {
	if opts == nil {
		opts = &AbstractMeshDisposeOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.DoNotRecurse == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotRecurse)
	}
	if opts.DisposeMaterialAndTextures == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DisposeMaterialAndTextures)
	}

	a.p.Call("dispose", args...)
}

// AbstractMeshEnableEdgesRenderingOpts contains optional parameters for AbstractMesh.EnableEdgesRendering.
type AbstractMeshEnableEdgesRenderingOpts struct {
	Epsilon                       *float64
	CheckVerticesInsteadOfIndices *bool
}

// EnableEdgesRendering calls the EnableEdgesRendering method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#enableedgesrendering
func (a *AbstractMesh) EnableEdgesRendering(opts *AbstractMeshEnableEdgesRenderingOpts) *AbstractMesh {
	if opts == nil {
		opts = &AbstractMeshEnableEdgesRenderingOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.Epsilon == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Epsilon)
	}
	if opts.CheckVerticesInsteadOfIndices == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CheckVerticesInsteadOfIndices)
	}

	retVal := a.p.Call("enableEdgesRendering", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// GetBoundingInfo calls the GetBoundingInfo method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getboundinginfo
func (a *AbstractMesh) GetBoundingInfo() *BoundingInfo {

	retVal := a.p.Call("getBoundingInfo")
	return BoundingInfoFromJSObject(retVal, a.ctx)
}

// GetClassName calls the GetClassName method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getclassname
func (a *AbstractMesh) GetClassName() string {

	retVal := a.p.Call("getClassName")
	return retVal.String()
}

// AbstractMeshGetClosestFacetAtCoordinatesOpts contains optional parameters for AbstractMesh.GetClosestFacetAtCoordinates.
type AbstractMeshGetClosestFacetAtCoordinatesOpts struct {
	Projected *Vector3
	CheckFace *bool
	Facing    *bool
}

// GetClosestFacetAtCoordinates calls the GetClosestFacetAtCoordinates method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getclosestfacetatcoordinates
func (a *AbstractMesh) GetClosestFacetAtCoordinates(x float64, y float64, z float64, opts *AbstractMeshGetClosestFacetAtCoordinatesOpts) float64 {
	if opts == nil {
		opts = &AbstractMeshGetClosestFacetAtCoordinatesOpts{}
	}

	args := make([]interface{}, 0, 3+3)

	args = append(args, x)
	args = append(args, y)
	args = append(args, z)

	if opts.Projected == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Projected.JSObject())
	}
	if opts.CheckFace == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CheckFace)
	}
	if opts.Facing == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Facing)
	}

	retVal := a.p.Call("getClosestFacetAtCoordinates", args...)
	return retVal.Float()
}

// AbstractMeshGetClosestFacetAtLocalCoordinatesOpts contains optional parameters for AbstractMesh.GetClosestFacetAtLocalCoordinates.
type AbstractMeshGetClosestFacetAtLocalCoordinatesOpts struct {
	Projected *Vector3
	CheckFace *bool
	Facing    *bool
}

// GetClosestFacetAtLocalCoordinates calls the GetClosestFacetAtLocalCoordinates method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getclosestfacetatlocalcoordinates
func (a *AbstractMesh) GetClosestFacetAtLocalCoordinates(x float64, y float64, z float64, opts *AbstractMeshGetClosestFacetAtLocalCoordinatesOpts) float64 {
	if opts == nil {
		opts = &AbstractMeshGetClosestFacetAtLocalCoordinatesOpts{}
	}

	args := make([]interface{}, 0, 3+3)

	args = append(args, x)
	args = append(args, y)
	args = append(args, z)

	if opts.Projected == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Projected.JSObject())
	}
	if opts.CheckFace == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CheckFace)
	}
	if opts.Facing == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Facing)
	}

	retVal := a.p.Call("getClosestFacetAtLocalCoordinates", args...)
	return retVal.Float()
}

// GetFacetDataParameters calls the GetFacetDataParameters method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getfacetdataparameters
func (a *AbstractMesh) GetFacetDataParameters() interface{} {

	retVal := a.p.Call("getFacetDataParameters")
	return retVal
}

// GetFacetLocalNormals calls the GetFacetLocalNormals method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getfacetlocalnormals
func (a *AbstractMesh) GetFacetLocalNormals() *Vector3 {

	retVal := a.p.Call("getFacetLocalNormals")
	return Vector3FromJSObject(retVal, a.ctx)
}

// GetFacetLocalPartitioning calls the GetFacetLocalPartitioning method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getfacetlocalpartitioning
func (a *AbstractMesh) GetFacetLocalPartitioning() float64 {

	retVal := a.p.Call("getFacetLocalPartitioning")
	return retVal.Float()
}

// GetFacetLocalPositions calls the GetFacetLocalPositions method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getfacetlocalpositions
func (a *AbstractMesh) GetFacetLocalPositions() *Vector3 {

	retVal := a.p.Call("getFacetLocalPositions")
	return Vector3FromJSObject(retVal, a.ctx)
}

// GetFacetNormal calls the GetFacetNormal method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getfacetnormal
func (a *AbstractMesh) GetFacetNormal(i float64) *Vector3 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, i)

	retVal := a.p.Call("getFacetNormal", args...)
	return Vector3FromJSObject(retVal, a.ctx)
}

// GetFacetNormalToRef calls the GetFacetNormalToRef method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getfacetnormaltoref
func (a *AbstractMesh) GetFacetNormalToRef(i float64, ref *Vector3) *AbstractMesh {

	args := make([]interface{}, 0, 2+0)

	args = append(args, i)
	args = append(args, ref.JSObject())

	retVal := a.p.Call("getFacetNormalToRef", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// GetFacetPosition calls the GetFacetPosition method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getfacetposition
func (a *AbstractMesh) GetFacetPosition(i float64) *Vector3 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, i)

	retVal := a.p.Call("getFacetPosition", args...)
	return Vector3FromJSObject(retVal, a.ctx)
}

// GetFacetPositionToRef calls the GetFacetPositionToRef method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getfacetpositiontoref
func (a *AbstractMesh) GetFacetPositionToRef(i float64, ref *Vector3) *AbstractMesh {

	args := make([]interface{}, 0, 2+0)

	args = append(args, i)
	args = append(args, ref.JSObject())

	retVal := a.p.Call("getFacetPositionToRef", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// GetFacetsAtLocalCoordinates calls the GetFacetsAtLocalCoordinates method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getfacetsatlocalcoordinates
func (a *AbstractMesh) GetFacetsAtLocalCoordinates(x float64, y float64, z float64) float64 {

	args := make([]interface{}, 0, 3+0)

	args = append(args, x)
	args = append(args, y)
	args = append(args, z)

	retVal := a.p.Call("getFacetsAtLocalCoordinates", args...)
	return retVal.Float()
}

// GetIndices calls the GetIndices method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getindices
func (a *AbstractMesh) GetIndices() js.Value {

	retVal := a.p.Call("getIndices")
	return retVal
}

// GetLOD calls the GetLOD method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getlod
func (a *AbstractMesh) GetLOD(camera *Camera) *AbstractMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, camera.JSObject())

	retVal := a.p.Call("getLOD", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// GetPhysicsImpostor calls the GetPhysicsImpostor method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getphysicsimpostor
func (a *AbstractMesh) GetPhysicsImpostor() *PhysicsImpostor {

	retVal := a.p.Call("getPhysicsImpostor")
	return PhysicsImpostorFromJSObject(retVal, a.ctx)
}

// GetTotalIndices calls the GetTotalIndices method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#gettotalindices
func (a *AbstractMesh) GetTotalIndices() float64 {

	retVal := a.p.Call("getTotalIndices")
	return retVal.Float()
}

// GetTotalVertices calls the GetTotalVertices method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#gettotalvertices
func (a *AbstractMesh) GetTotalVertices() float64 {

	retVal := a.p.Call("getTotalVertices")
	return retVal.Float()
}

// GetVerticesData calls the GetVerticesData method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getverticesdata
func (a *AbstractMesh) GetVerticesData(kind string) js.Value {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	retVal := a.p.Call("getVerticesData", args...)
	return retVal
}

// GetWorldMatrix calls the GetWorldMatrix method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#getworldmatrix
func (a *AbstractMesh) GetWorldMatrix() *Matrix {

	retVal := a.p.Call("getWorldMatrix")
	return MatrixFromJSObject(retVal, a.ctx)
}

// AbstractMeshIntersectsOpts contains optional parameters for AbstractMesh.Intersects.
type AbstractMeshIntersectsOpts struct {
	FastCheck         *bool
	TrianglePredicate js.Value
}

// Intersects calls the Intersects method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#intersects
func (a *AbstractMesh) Intersects(ray *Ray, opts *AbstractMeshIntersectsOpts) *PickingInfo {
	if opts == nil {
		opts = &AbstractMeshIntersectsOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, ray.JSObject())

	if opts.FastCheck == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FastCheck)
	}
	args = append(args, opts.TrianglePredicate)

	retVal := a.p.Call("intersects", args...)
	return PickingInfoFromJSObject(retVal, a.ctx)
}

// AbstractMeshIntersectsMeshOpts contains optional parameters for AbstractMesh.IntersectsMesh.
type AbstractMeshIntersectsMeshOpts struct {
	Precise            *bool
	IncludeDescendants *bool
}

// IntersectsMesh calls the IntersectsMesh method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#intersectsmesh
func (a *AbstractMesh) IntersectsMesh(mesh *AbstractMesh, opts *AbstractMeshIntersectsMeshOpts) bool {
	if opts == nil {
		opts = &AbstractMeshIntersectsMeshOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, mesh.JSObject())

	if opts.Precise == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Precise)
	}
	if opts.IncludeDescendants == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IncludeDescendants)
	}

	retVal := a.p.Call("intersectsMesh", args...)
	return retVal.Bool()
}

// IntersectsPoint calls the IntersectsPoint method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#intersectspoint
func (a *AbstractMesh) IntersectsPoint(point *Vector3) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, point.JSObject())

	retVal := a.p.Call("intersectsPoint", args...)
	return retVal.Bool()
}

// IsCompletelyInFrustum calls the IsCompletelyInFrustum method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#iscompletelyinfrustum
func (a *AbstractMesh) IsCompletelyInFrustum(frustumPlanes *Plane) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, frustumPlanes.JSObject())

	retVal := a.p.Call("isCompletelyInFrustum", args...)
	return retVal.Bool()
}

// IsInFrustum calls the IsInFrustum method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isinfrustum
func (a *AbstractMesh) IsInFrustum(frustumPlanes *Plane) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, frustumPlanes.JSObject())

	retVal := a.p.Call("isInFrustum", args...)
	return retVal.Bool()
}

// IsVerticesDataPresent calls the IsVerticesDataPresent method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isverticesdatapresent
func (a *AbstractMesh) IsVerticesDataPresent(kind string) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	retVal := a.p.Call("isVerticesDataPresent", args...)
	return retVal.Bool()
}

// MovePOV calls the MovePOV method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#movepov
func (a *AbstractMesh) MovePOV(amountRight float64, amountUp float64, amountForward float64) *AbstractMesh {

	args := make([]interface{}, 0, 3+0)

	args = append(args, amountRight)
	args = append(args, amountUp)
	args = append(args, amountForward)

	retVal := a.p.Call("movePOV", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// MoveWithCollisions calls the MoveWithCollisions method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#movewithcollisions
func (a *AbstractMesh) MoveWithCollisions(displacement *Vector3) *AbstractMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, displacement.JSObject())

	retVal := a.p.Call("moveWithCollisions", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// AbstractMeshNormalizeToUnitCubeOpts contains optional parameters for AbstractMesh.NormalizeToUnitCube.
type AbstractMeshNormalizeToUnitCubeOpts struct {
	IncludeDescendants *bool
	IgnoreRotation     *bool
	Predicate          func()
}

// NormalizeToUnitCube calls the NormalizeToUnitCube method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#normalizetounitcube
func (a *AbstractMesh) NormalizeToUnitCube(opts *AbstractMeshNormalizeToUnitCubeOpts) *AbstractMesh {
	if opts == nil {
		opts = &AbstractMeshNormalizeToUnitCubeOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.IncludeDescendants == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IncludeDescendants)
	}
	if opts.IgnoreRotation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IgnoreRotation)
	}
	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Predicate)
	}

	retVal := a.p.Call("normalizeToUnitCube", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// AbstractMeshRefreshBoundingInfoOpts contains optional parameters for AbstractMesh.RefreshBoundingInfo.
type AbstractMeshRefreshBoundingInfoOpts struct {
	ApplySkeleton *bool
}

// RefreshBoundingInfo calls the RefreshBoundingInfo method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#refreshboundinginfo
func (a *AbstractMesh) RefreshBoundingInfo(opts *AbstractMeshRefreshBoundingInfoOpts) *AbstractMesh {
	if opts == nil {
		opts = &AbstractMeshRefreshBoundingInfoOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.ApplySkeleton == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ApplySkeleton)
	}

	retVal := a.p.Call("refreshBoundingInfo", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// ReleaseSubMeshes calls the ReleaseSubMeshes method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#releasesubmeshes
func (a *AbstractMesh) ReleaseSubMeshes() *AbstractMesh {

	retVal := a.p.Call("releaseSubMeshes")
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// RemoveChild calls the RemoveChild method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#removechild
func (a *AbstractMesh) RemoveChild(mesh *AbstractMesh) *AbstractMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, mesh.JSObject())

	retVal := a.p.Call("removeChild", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// RotatePOV calls the RotatePOV method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#rotatepov
func (a *AbstractMesh) RotatePOV(flipBack float64, twirlClockwise float64, tiltRight float64) *AbstractMesh {

	args := make([]interface{}, 0, 3+0)

	args = append(args, flipBack)
	args = append(args, twirlClockwise)
	args = append(args, tiltRight)

	retVal := a.p.Call("rotatePOV", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// SetBoundingInfo calls the SetBoundingInfo method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#setboundinginfo
func (a *AbstractMesh) SetBoundingInfo(boundingInfo *BoundingInfo) *AbstractMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, boundingInfo.JSObject())

	retVal := a.p.Call("setBoundingInfo", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// SetIndices calls the SetIndices method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#setindices
func (a *AbstractMesh) SetIndices(indices js.Value, totalVertices float64) *AbstractMesh {

	args := make([]interface{}, 0, 2+0)

	args = append(args, indices)
	args = append(args, totalVertices)

	retVal := a.p.Call("setIndices", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// AbstractMeshSetPhysicsLinkWithOpts contains optional parameters for AbstractMesh.SetPhysicsLinkWith.
type AbstractMeshSetPhysicsLinkWithOpts struct {
	Options *interface{}
}

// SetPhysicsLinkWith calls the SetPhysicsLinkWith method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#setphysicslinkwith
func (a *AbstractMesh) SetPhysicsLinkWith(otherMesh *Mesh, pivot1 *Vector3, pivot2 *Vector3, opts *AbstractMeshSetPhysicsLinkWithOpts) *AbstractMesh {
	if opts == nil {
		opts = &AbstractMeshSetPhysicsLinkWithOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	args = append(args, otherMesh.JSObject())
	args = append(args, pivot1.JSObject())
	args = append(args, pivot2.JSObject())

	if opts.Options == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Options)
	}

	retVal := a.p.Call("setPhysicsLinkWith", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// AbstractMeshSetVerticesDataOpts contains optional parameters for AbstractMesh.SetVerticesData.
type AbstractMeshSetVerticesDataOpts struct {
	Updatable *bool
	Stride    *float64
}

// SetVerticesData calls the SetVerticesData method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#setverticesdata
func (a *AbstractMesh) SetVerticesData(kind string, data js.Value, opts *AbstractMeshSetVerticesDataOpts) *AbstractMesh {
	if opts == nil {
		opts = &AbstractMeshSetVerticesDataOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, kind)
	args = append(args, data)

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.Stride == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Stride)
	}

	retVal := a.p.Call("setVerticesData", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// AbstractMeshToStringOpts contains optional parameters for AbstractMesh.ToString.
type AbstractMeshToStringOpts struct {
	FullDetails *bool
}

// ToString calls the ToString method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#tostring
func (a *AbstractMesh) ToString(opts *AbstractMeshToStringOpts) string {
	if opts == nil {
		opts = &AbstractMeshToStringOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.FullDetails == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FullDetails)
	}

	retVal := a.p.Call("toString", args...)
	return retVal.String()
}

// UpdateFacetData calls the UpdateFacetData method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#updatefacetdata
func (a *AbstractMesh) UpdateFacetData() *AbstractMesh {

	retVal := a.p.Call("updateFacetData")
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// AbstractMeshUpdateIndicesOpts contains optional parameters for AbstractMesh.UpdateIndices.
type AbstractMeshUpdateIndicesOpts struct {
	Offset        *float64
	GpuMemoryOnly *bool
}

// UpdateIndices calls the UpdateIndices method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#updateindices
func (a *AbstractMesh) UpdateIndices(indices js.Value, opts *AbstractMeshUpdateIndicesOpts) *AbstractMesh {
	if opts == nil {
		opts = &AbstractMeshUpdateIndicesOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, indices)

	if opts.Offset == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Offset)
	}
	if opts.GpuMemoryOnly == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.GpuMemoryOnly)
	}

	retVal := a.p.Call("updateIndices", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// AbstractMeshUpdateVerticesDataOpts contains optional parameters for AbstractMesh.UpdateVerticesData.
type AbstractMeshUpdateVerticesDataOpts struct {
	UpdateExtends *bool
	MakeItUnique  *bool
}

// UpdateVerticesData calls the UpdateVerticesData method on the AbstractMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#updateverticesdata
func (a *AbstractMesh) UpdateVerticesData(kind string, data js.Value, opts *AbstractMeshUpdateVerticesDataOpts) *AbstractMesh {
	if opts == nil {
		opts = &AbstractMeshUpdateVerticesDataOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, kind)
	args = append(args, data)

	if opts.UpdateExtends == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UpdateExtends)
	}
	if opts.MakeItUnique == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MakeItUnique)
	}

	retVal := a.p.Call("updateVerticesData", args...)
	return AbstractMeshFromJSObject(retVal, a.ctx)
}

// ActionManager returns the ActionManager property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#actionmanager
func (a *AbstractMesh) ActionManager() *AbstractActionManager {
	retVal := a.p.Get("actionManager")
	return AbstractActionManagerFromJSObject(retVal, a.ctx)
}

// SetActionManager sets the ActionManager property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#actionmanager
func (a *AbstractMesh) SetActionManager(actionManager *AbstractActionManager) *AbstractMesh {
	a.p.Set("actionManager", actionManager.JSObject())
	return a
}

// AlphaIndex returns the AlphaIndex property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#alphaindex
func (a *AbstractMesh) AlphaIndex() float64 {
	retVal := a.p.Get("alphaIndex")
	return retVal.Float()
}

// SetAlphaIndex sets the AlphaIndex property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#alphaindex
func (a *AbstractMesh) SetAlphaIndex(alphaIndex float64) *AbstractMesh {
	a.p.Set("alphaIndex", alphaIndex)
	return a
}

// AlwaysSelectAsActiveMesh returns the AlwaysSelectAsActiveMesh property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#alwaysselectasactivemesh
func (a *AbstractMesh) AlwaysSelectAsActiveMesh() bool {
	retVal := a.p.Get("alwaysSelectAsActiveMesh")
	return retVal.Bool()
}

// SetAlwaysSelectAsActiveMesh sets the AlwaysSelectAsActiveMesh property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#alwaysselectasactivemesh
func (a *AbstractMesh) SetAlwaysSelectAsActiveMesh(alwaysSelectAsActiveMesh bool) *AbstractMesh {
	a.p.Set("alwaysSelectAsActiveMesh", alwaysSelectAsActiveMesh)
	return a
}

// ApplyFog returns the ApplyFog property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#applyfog
func (a *AbstractMesh) ApplyFog() bool {
	retVal := a.p.Get("applyFog")
	return retVal.Bool()
}

// SetApplyFog sets the ApplyFog property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#applyfog
func (a *AbstractMesh) SetApplyFog(applyFog bool) *AbstractMesh {
	a.p.Set("applyFog", applyFog)
	return a
}

// BILLBOARDMODE_ALL returns the BILLBOARDMODE_ALL property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#billboardmode_all
func (a *AbstractMesh) BILLBOARDMODE_ALL() float64 {
	retVal := a.p.Get("BILLBOARDMODE_ALL")
	return retVal.Float()
}

// SetBILLBOARDMODE_ALL sets the BILLBOARDMODE_ALL property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#billboardmode_all
func (a *AbstractMesh) SetBILLBOARDMODE_ALL(BILLBOARDMODE_ALL float64) *AbstractMesh {
	a.p.Set("BILLBOARDMODE_ALL", BILLBOARDMODE_ALL)
	return a
}

// BILLBOARDMODE_NONE returns the BILLBOARDMODE_NONE property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#billboardmode_none
func (a *AbstractMesh) BILLBOARDMODE_NONE() float64 {
	retVal := a.p.Get("BILLBOARDMODE_NONE")
	return retVal.Float()
}

// SetBILLBOARDMODE_NONE sets the BILLBOARDMODE_NONE property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#billboardmode_none
func (a *AbstractMesh) SetBILLBOARDMODE_NONE(BILLBOARDMODE_NONE float64) *AbstractMesh {
	a.p.Set("BILLBOARDMODE_NONE", BILLBOARDMODE_NONE)
	return a
}

// BILLBOARDMODE_USE_POSITION returns the BILLBOARDMODE_USE_POSITION property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#billboardmode_use_position
func (a *AbstractMesh) BILLBOARDMODE_USE_POSITION() float64 {
	retVal := a.p.Get("BILLBOARDMODE_USE_POSITION")
	return retVal.Float()
}

// SetBILLBOARDMODE_USE_POSITION sets the BILLBOARDMODE_USE_POSITION property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#billboardmode_use_position
func (a *AbstractMesh) SetBILLBOARDMODE_USE_POSITION(BILLBOARDMODE_USE_POSITION float64) *AbstractMesh {
	a.p.Set("BILLBOARDMODE_USE_POSITION", BILLBOARDMODE_USE_POSITION)
	return a
}

// BILLBOARDMODE_X returns the BILLBOARDMODE_X property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#billboardmode_x
func (a *AbstractMesh) BILLBOARDMODE_X() float64 {
	retVal := a.p.Get("BILLBOARDMODE_X")
	return retVal.Float()
}

// SetBILLBOARDMODE_X sets the BILLBOARDMODE_X property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#billboardmode_x
func (a *AbstractMesh) SetBILLBOARDMODE_X(BILLBOARDMODE_X float64) *AbstractMesh {
	a.p.Set("BILLBOARDMODE_X", BILLBOARDMODE_X)
	return a
}

// BILLBOARDMODE_Y returns the BILLBOARDMODE_Y property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#billboardmode_y
func (a *AbstractMesh) BILLBOARDMODE_Y() float64 {
	retVal := a.p.Get("BILLBOARDMODE_Y")
	return retVal.Float()
}

// SetBILLBOARDMODE_Y sets the BILLBOARDMODE_Y property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#billboardmode_y
func (a *AbstractMesh) SetBILLBOARDMODE_Y(BILLBOARDMODE_Y float64) *AbstractMesh {
	a.p.Set("BILLBOARDMODE_Y", BILLBOARDMODE_Y)
	return a
}

// BILLBOARDMODE_Z returns the BILLBOARDMODE_Z property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#billboardmode_z
func (a *AbstractMesh) BILLBOARDMODE_Z() float64 {
	retVal := a.p.Get("BILLBOARDMODE_Z")
	return retVal.Float()
}

// SetBILLBOARDMODE_Z sets the BILLBOARDMODE_Z property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#billboardmode_z
func (a *AbstractMesh) SetBILLBOARDMODE_Z(BILLBOARDMODE_Z float64) *AbstractMesh {
	a.p.Set("BILLBOARDMODE_Z", BILLBOARDMODE_Z)
	return a
}

// CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY returns the CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#cullingstrategy_boundingsphere_only
func (a *AbstractMesh) CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY() float64 {
	retVal := a.p.Get("CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY")
	return retVal.Float()
}

// SetCULLINGSTRATEGY_BOUNDINGSPHERE_ONLY sets the CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#cullingstrategy_boundingsphere_only
func (a *AbstractMesh) SetCULLINGSTRATEGY_BOUNDINGSPHERE_ONLY(CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY float64) *AbstractMesh {
	a.p.Set("CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY", CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY)
	return a
}

// CULLINGSTRATEGY_OPTIMISTIC_INCLUSION returns the CULLINGSTRATEGY_OPTIMISTIC_INCLUSION property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#cullingstrategy_optimistic_inclusion
func (a *AbstractMesh) CULLINGSTRATEGY_OPTIMISTIC_INCLUSION() float64 {
	retVal := a.p.Get("CULLINGSTRATEGY_OPTIMISTIC_INCLUSION")
	return retVal.Float()
}

// SetCULLINGSTRATEGY_OPTIMISTIC_INCLUSION sets the CULLINGSTRATEGY_OPTIMISTIC_INCLUSION property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#cullingstrategy_optimistic_inclusion
func (a *AbstractMesh) SetCULLINGSTRATEGY_OPTIMISTIC_INCLUSION(CULLINGSTRATEGY_OPTIMISTIC_INCLUSION float64) *AbstractMesh {
	a.p.Set("CULLINGSTRATEGY_OPTIMISTIC_INCLUSION", CULLINGSTRATEGY_OPTIMISTIC_INCLUSION)
	return a
}

// CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY returns the CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#cullingstrategy_optimistic_inclusion_then_bsphere_only
func (a *AbstractMesh) CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY() float64 {
	retVal := a.p.Get("CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY")
	return retVal.Float()
}

// SetCULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY sets the CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#cullingstrategy_optimistic_inclusion_then_bsphere_only
func (a *AbstractMesh) SetCULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY(CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY float64) *AbstractMesh {
	a.p.Set("CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY", CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY)
	return a
}

// CULLINGSTRATEGY_STANDARD returns the CULLINGSTRATEGY_STANDARD property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#cullingstrategy_standard
func (a *AbstractMesh) CULLINGSTRATEGY_STANDARD() float64 {
	retVal := a.p.Get("CULLINGSTRATEGY_STANDARD")
	return retVal.Float()
}

// SetCULLINGSTRATEGY_STANDARD sets the CULLINGSTRATEGY_STANDARD property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#cullingstrategy_standard
func (a *AbstractMesh) SetCULLINGSTRATEGY_STANDARD(CULLINGSTRATEGY_STANDARD float64) *AbstractMesh {
	a.p.Set("CULLINGSTRATEGY_STANDARD", CULLINGSTRATEGY_STANDARD)
	return a
}

// CheckCollisions returns the CheckCollisions property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#checkcollisions
func (a *AbstractMesh) CheckCollisions() bool {
	retVal := a.p.Get("checkCollisions")
	return retVal.Bool()
}

// SetCheckCollisions sets the CheckCollisions property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#checkcollisions
func (a *AbstractMesh) SetCheckCollisions(checkCollisions bool) *AbstractMesh {
	a.p.Set("checkCollisions", checkCollisions)
	return a
}

// Collider returns the Collider property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#collider
func (a *AbstractMesh) Collider() js.Value {
	retVal := a.p.Get("collider")
	return retVal
}

// SetCollider sets the Collider property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#collider
func (a *AbstractMesh) SetCollider(collider js.Value) *AbstractMesh {
	a.p.Set("collider", collider)
	return a
}

// CollisionGroup returns the CollisionGroup property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#collisiongroup
func (a *AbstractMesh) CollisionGroup() float64 {
	retVal := a.p.Get("collisionGroup")
	return retVal.Float()
}

// SetCollisionGroup sets the CollisionGroup property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#collisiongroup
func (a *AbstractMesh) SetCollisionGroup(collisionGroup float64) *AbstractMesh {
	a.p.Set("collisionGroup", collisionGroup)
	return a
}

// CollisionMask returns the CollisionMask property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#collisionmask
func (a *AbstractMesh) CollisionMask() float64 {
	retVal := a.p.Get("collisionMask")
	return retVal.Float()
}

// SetCollisionMask sets the CollisionMask property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#collisionmask
func (a *AbstractMesh) SetCollisionMask(collisionMask float64) *AbstractMesh {
	a.p.Set("collisionMask", collisionMask)
	return a
}

// ComputeBonesUsingShaders returns the ComputeBonesUsingShaders property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#computebonesusingshaders
func (a *AbstractMesh) ComputeBonesUsingShaders() bool {
	retVal := a.p.Get("computeBonesUsingShaders")
	return retVal.Bool()
}

// SetComputeBonesUsingShaders sets the ComputeBonesUsingShaders property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#computebonesusingshaders
func (a *AbstractMesh) SetComputeBonesUsingShaders(computeBonesUsingShaders bool) *AbstractMesh {
	a.p.Set("computeBonesUsingShaders", computeBonesUsingShaders)
	return a
}

// CullingStrategy returns the CullingStrategy property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#cullingstrategy
func (a *AbstractMesh) CullingStrategy() float64 {
	retVal := a.p.Get("cullingStrategy")
	return retVal.Float()
}

// SetCullingStrategy sets the CullingStrategy property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#cullingstrategy
func (a *AbstractMesh) SetCullingStrategy(cullingStrategy float64) *AbstractMesh {
	a.p.Set("cullingStrategy", cullingStrategy)
	return a
}

// DefinedFacingForward returns the DefinedFacingForward property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#definedfacingforward
func (a *AbstractMesh) DefinedFacingForward() bool {
	retVal := a.p.Get("definedFacingForward")
	return retVal.Bool()
}

// SetDefinedFacingForward sets the DefinedFacingForward property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#definedfacingforward
func (a *AbstractMesh) SetDefinedFacingForward(definedFacingForward bool) *AbstractMesh {
	a.p.Set("definedFacingForward", definedFacingForward)
	return a
}

// DoNotSyncBoundingInfo returns the DoNotSyncBoundingInfo property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#donotsyncboundinginfo
func (a *AbstractMesh) DoNotSyncBoundingInfo() bool {
	retVal := a.p.Get("doNotSyncBoundingInfo")
	return retVal.Bool()
}

// SetDoNotSyncBoundingInfo sets the DoNotSyncBoundingInfo property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#donotsyncboundinginfo
func (a *AbstractMesh) SetDoNotSyncBoundingInfo(doNotSyncBoundingInfo bool) *AbstractMesh {
	a.p.Set("doNotSyncBoundingInfo", doNotSyncBoundingInfo)
	return a
}

// EdgesColor returns the EdgesColor property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#edgescolor
func (a *AbstractMesh) EdgesColor() *Color4 {
	retVal := a.p.Get("edgesColor")
	return Color4FromJSObject(retVal, a.ctx)
}

// SetEdgesColor sets the EdgesColor property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#edgescolor
func (a *AbstractMesh) SetEdgesColor(edgesColor *Color4) *AbstractMesh {
	a.p.Set("edgesColor", edgesColor.JSObject())
	return a
}

// EdgesRenderer returns the EdgesRenderer property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#edgesrenderer
func (a *AbstractMesh) EdgesRenderer() *EdgesRenderer {
	retVal := a.p.Get("edgesRenderer")
	return EdgesRendererFromJSObject(retVal, a.ctx)
}

// SetEdgesRenderer sets the EdgesRenderer property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#edgesrenderer
func (a *AbstractMesh) SetEdgesRenderer(edgesRenderer *EdgesRenderer) *AbstractMesh {
	a.p.Set("edgesRenderer", edgesRenderer.JSObject())
	return a
}

// EdgesWidth returns the EdgesWidth property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#edgeswidth
func (a *AbstractMesh) EdgesWidth() float64 {
	retVal := a.p.Get("edgesWidth")
	return retVal.Float()
}

// SetEdgesWidth sets the EdgesWidth property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#edgeswidth
func (a *AbstractMesh) SetEdgesWidth(edgesWidth float64) *AbstractMesh {
	a.p.Set("edgesWidth", edgesWidth)
	return a
}

// Ellipsoid returns the Ellipsoid property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#ellipsoid
func (a *AbstractMesh) Ellipsoid() *Vector3 {
	retVal := a.p.Get("ellipsoid")
	return Vector3FromJSObject(retVal, a.ctx)
}

// SetEllipsoid sets the Ellipsoid property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#ellipsoid
func (a *AbstractMesh) SetEllipsoid(ellipsoid *Vector3) *AbstractMesh {
	a.p.Set("ellipsoid", ellipsoid.JSObject())
	return a
}

// EllipsoidOffset returns the EllipsoidOffset property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#ellipsoidoffset
func (a *AbstractMesh) EllipsoidOffset() *Vector3 {
	retVal := a.p.Get("ellipsoidOffset")
	return Vector3FromJSObject(retVal, a.ctx)
}

// SetEllipsoidOffset sets the EllipsoidOffset property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#ellipsoidoffset
func (a *AbstractMesh) SetEllipsoidOffset(ellipsoidOffset *Vector3) *AbstractMesh {
	a.p.Set("ellipsoidOffset", ellipsoidOffset.JSObject())
	return a
}

// EnablePointerMoveEvents returns the EnablePointerMoveEvents property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#enablepointermoveevents
func (a *AbstractMesh) EnablePointerMoveEvents() bool {
	retVal := a.p.Get("enablePointerMoveEvents")
	return retVal.Bool()
}

// SetEnablePointerMoveEvents sets the EnablePointerMoveEvents property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#enablepointermoveevents
func (a *AbstractMesh) SetEnablePointerMoveEvents(enablePointerMoveEvents bool) *AbstractMesh {
	a.p.Set("enablePointerMoveEvents", enablePointerMoveEvents)
	return a
}

// FacetDepthSortFrom returns the FacetDepthSortFrom property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#facetdepthsortfrom
func (a *AbstractMesh) FacetDepthSortFrom() *Vector3 {
	retVal := a.p.Get("facetDepthSortFrom")
	return Vector3FromJSObject(retVal, a.ctx)
}

// SetFacetDepthSortFrom sets the FacetDepthSortFrom property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#facetdepthsortfrom
func (a *AbstractMesh) SetFacetDepthSortFrom(facetDepthSortFrom *Vector3) *AbstractMesh {
	a.p.Set("facetDepthSortFrom", facetDepthSortFrom.JSObject())
	return a
}

// FacetNb returns the FacetNb property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#facetnb
func (a *AbstractMesh) FacetNb() float64 {
	retVal := a.p.Get("facetNb")
	return retVal.Float()
}

// SetFacetNb sets the FacetNb property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#facetnb
func (a *AbstractMesh) SetFacetNb(facetNb float64) *AbstractMesh {
	a.p.Set("facetNb", facetNb)
	return a
}

// HasInstances returns the HasInstances property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#hasinstances
func (a *AbstractMesh) HasInstances() bool {
	retVal := a.p.Get("hasInstances")
	return retVal.Bool()
}

// SetHasInstances sets the HasInstances property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#hasinstances
func (a *AbstractMesh) SetHasInstances(hasInstances bool) *AbstractMesh {
	a.p.Set("hasInstances", hasInstances)
	return a
}

// HasVertexAlpha returns the HasVertexAlpha property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#hasvertexalpha
func (a *AbstractMesh) HasVertexAlpha() bool {
	retVal := a.p.Get("hasVertexAlpha")
	return retVal.Bool()
}

// SetHasVertexAlpha sets the HasVertexAlpha property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#hasvertexalpha
func (a *AbstractMesh) SetHasVertexAlpha(hasVertexAlpha bool) *AbstractMesh {
	a.p.Set("hasVertexAlpha", hasVertexAlpha)
	return a
}

// InstancedBuffers returns the InstancedBuffers property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#instancedbuffers
func (a *AbstractMesh) InstancedBuffers() js.Value {
	retVal := a.p.Get("instancedBuffers")
	return retVal
}

// SetInstancedBuffers sets the InstancedBuffers property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#instancedbuffers
func (a *AbstractMesh) SetInstancedBuffers(instancedBuffers js.Value) *AbstractMesh {
	a.p.Set("instancedBuffers", instancedBuffers)
	return a
}

// IsAnInstance returns the IsAnInstance property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isaninstance
func (a *AbstractMesh) IsAnInstance() bool {
	retVal := a.p.Get("isAnInstance")
	return retVal.Bool()
}

// SetIsAnInstance sets the IsAnInstance property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isaninstance
func (a *AbstractMesh) SetIsAnInstance(isAnInstance bool) *AbstractMesh {
	a.p.Set("isAnInstance", isAnInstance)
	return a
}

// IsBlocked returns the IsBlocked property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isblocked
func (a *AbstractMesh) IsBlocked() bool {
	retVal := a.p.Get("isBlocked")
	return retVal.Bool()
}

// SetIsBlocked sets the IsBlocked property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isblocked
func (a *AbstractMesh) SetIsBlocked(isBlocked bool) *AbstractMesh {
	a.p.Set("isBlocked", isBlocked)
	return a
}

// IsBlocker returns the IsBlocker property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isblocker
func (a *AbstractMesh) IsBlocker() bool {
	retVal := a.p.Get("isBlocker")
	return retVal.Bool()
}

// SetIsBlocker sets the IsBlocker property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isblocker
func (a *AbstractMesh) SetIsBlocker(isBlocker bool) *AbstractMesh {
	a.p.Set("isBlocker", isBlocker)
	return a
}

// IsFacetDataEnabled returns the IsFacetDataEnabled property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isfacetdataenabled
func (a *AbstractMesh) IsFacetDataEnabled() bool {
	retVal := a.p.Get("isFacetDataEnabled")
	return retVal.Bool()
}

// SetIsFacetDataEnabled sets the IsFacetDataEnabled property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isfacetdataenabled
func (a *AbstractMesh) SetIsFacetDataEnabled(isFacetDataEnabled bool) *AbstractMesh {
	a.p.Set("isFacetDataEnabled", isFacetDataEnabled)
	return a
}

// IsOccluded returns the IsOccluded property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isoccluded
func (a *AbstractMesh) IsOccluded() bool {
	retVal := a.p.Get("isOccluded")
	return retVal.Bool()
}

// SetIsOccluded sets the IsOccluded property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isoccluded
func (a *AbstractMesh) SetIsOccluded(isOccluded bool) *AbstractMesh {
	a.p.Set("isOccluded", isOccluded)
	return a
}

// IsOcclusionQueryInProgress returns the IsOcclusionQueryInProgress property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isocclusionqueryinprogress
func (a *AbstractMesh) IsOcclusionQueryInProgress() bool {
	retVal := a.p.Get("isOcclusionQueryInProgress")
	return retVal.Bool()
}

// SetIsOcclusionQueryInProgress sets the IsOcclusionQueryInProgress property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isocclusionqueryinprogress
func (a *AbstractMesh) SetIsOcclusionQueryInProgress(isOcclusionQueryInProgress bool) *AbstractMesh {
	a.p.Set("isOcclusionQueryInProgress", isOcclusionQueryInProgress)
	return a
}

// IsPickable returns the IsPickable property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#ispickable
func (a *AbstractMesh) IsPickable() bool {
	retVal := a.p.Get("isPickable")
	return retVal.Bool()
}

// SetIsPickable sets the IsPickable property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#ispickable
func (a *AbstractMesh) SetIsPickable(isPickable bool) *AbstractMesh {
	a.p.Set("isPickable", isPickable)
	return a
}

// IsVisible returns the IsVisible property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isvisible
func (a *AbstractMesh) IsVisible() bool {
	retVal := a.p.Get("isVisible")
	return retVal.Bool()
}

// SetIsVisible sets the IsVisible property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#isvisible
func (a *AbstractMesh) SetIsVisible(isVisible bool) *AbstractMesh {
	a.p.Set("isVisible", isVisible)
	return a
}

// LayerMask returns the LayerMask property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#layermask
func (a *AbstractMesh) LayerMask() float64 {
	retVal := a.p.Get("layerMask")
	return retVal.Float()
}

// SetLayerMask sets the LayerMask property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#layermask
func (a *AbstractMesh) SetLayerMask(layerMask float64) *AbstractMesh {
	a.p.Set("layerMask", layerMask)
	return a
}

// LightSources returns the LightSources property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#lightsources
func (a *AbstractMesh) LightSources() *Light {
	retVal := a.p.Get("lightSources")
	return LightFromJSObject(retVal, a.ctx)
}

// SetLightSources sets the LightSources property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#lightsources
func (a *AbstractMesh) SetLightSources(lightSources *Light) *AbstractMesh {
	a.p.Set("lightSources", lightSources.JSObject())
	return a
}

// Material returns the Material property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#material
func (a *AbstractMesh) Material() *Material {
	retVal := a.p.Get("material")
	return MaterialFromJSObject(retVal, a.ctx)
}

// SetMaterial sets the Material property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#material
func (a *AbstractMesh) SetMaterial(material *Material) *AbstractMesh {
	a.p.Set("material", material.JSObject())
	return a
}

// MustDepthSortFacets returns the MustDepthSortFacets property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#mustdepthsortfacets
func (a *AbstractMesh) MustDepthSortFacets() bool {
	retVal := a.p.Get("mustDepthSortFacets")
	return retVal.Bool()
}

// SetMustDepthSortFacets sets the MustDepthSortFacets property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#mustdepthsortfacets
func (a *AbstractMesh) SetMustDepthSortFacets(mustDepthSortFacets bool) *AbstractMesh {
	a.p.Set("mustDepthSortFacets", mustDepthSortFacets)
	return a
}

// NumBoneInfluencers returns the NumBoneInfluencers property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#numboneinfluencers
func (a *AbstractMesh) NumBoneInfluencers() float64 {
	retVal := a.p.Get("numBoneInfluencers")
	return retVal.Float()
}

// SetNumBoneInfluencers sets the NumBoneInfluencers property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#numboneinfluencers
func (a *AbstractMesh) SetNumBoneInfluencers(numBoneInfluencers float64) *AbstractMesh {
	a.p.Set("numBoneInfluencers", numBoneInfluencers)
	return a
}

// OCCLUSION_ALGORITHM_TYPE_ACCURATE returns the OCCLUSION_ALGORITHM_TYPE_ACCURATE property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusion_algorithm_type_accurate
func (a *AbstractMesh) OCCLUSION_ALGORITHM_TYPE_ACCURATE() float64 {
	retVal := a.p.Get("OCCLUSION_ALGORITHM_TYPE_ACCURATE")
	return retVal.Float()
}

// SetOCCLUSION_ALGORITHM_TYPE_ACCURATE sets the OCCLUSION_ALGORITHM_TYPE_ACCURATE property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusion_algorithm_type_accurate
func (a *AbstractMesh) SetOCCLUSION_ALGORITHM_TYPE_ACCURATE(OCCLUSION_ALGORITHM_TYPE_ACCURATE float64) *AbstractMesh {
	a.p.Set("OCCLUSION_ALGORITHM_TYPE_ACCURATE", OCCLUSION_ALGORITHM_TYPE_ACCURATE)
	return a
}

// OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE returns the OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusion_algorithm_type_conservative
func (a *AbstractMesh) OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE() float64 {
	retVal := a.p.Get("OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE")
	return retVal.Float()
}

// SetOCCLUSION_ALGORITHM_TYPE_CONSERVATIVE sets the OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusion_algorithm_type_conservative
func (a *AbstractMesh) SetOCCLUSION_ALGORITHM_TYPE_CONSERVATIVE(OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE float64) *AbstractMesh {
	a.p.Set("OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE", OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE)
	return a
}

// OCCLUSION_TYPE_NONE returns the OCCLUSION_TYPE_NONE property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusion_type_none
func (a *AbstractMesh) OCCLUSION_TYPE_NONE() float64 {
	retVal := a.p.Get("OCCLUSION_TYPE_NONE")
	return retVal.Float()
}

// SetOCCLUSION_TYPE_NONE sets the OCCLUSION_TYPE_NONE property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusion_type_none
func (a *AbstractMesh) SetOCCLUSION_TYPE_NONE(OCCLUSION_TYPE_NONE float64) *AbstractMesh {
	a.p.Set("OCCLUSION_TYPE_NONE", OCCLUSION_TYPE_NONE)
	return a
}

// OCCLUSION_TYPE_OPTIMISTIC returns the OCCLUSION_TYPE_OPTIMISTIC property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusion_type_optimistic
func (a *AbstractMesh) OCCLUSION_TYPE_OPTIMISTIC() float64 {
	retVal := a.p.Get("OCCLUSION_TYPE_OPTIMISTIC")
	return retVal.Float()
}

// SetOCCLUSION_TYPE_OPTIMISTIC sets the OCCLUSION_TYPE_OPTIMISTIC property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusion_type_optimistic
func (a *AbstractMesh) SetOCCLUSION_TYPE_OPTIMISTIC(OCCLUSION_TYPE_OPTIMISTIC float64) *AbstractMesh {
	a.p.Set("OCCLUSION_TYPE_OPTIMISTIC", OCCLUSION_TYPE_OPTIMISTIC)
	return a
}

// OCCLUSION_TYPE_STRICT returns the OCCLUSION_TYPE_STRICT property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusion_type_strict
func (a *AbstractMesh) OCCLUSION_TYPE_STRICT() float64 {
	retVal := a.p.Get("OCCLUSION_TYPE_STRICT")
	return retVal.Float()
}

// SetOCCLUSION_TYPE_STRICT sets the OCCLUSION_TYPE_STRICT property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusion_type_strict
func (a *AbstractMesh) SetOCCLUSION_TYPE_STRICT(OCCLUSION_TYPE_STRICT float64) *AbstractMesh {
	a.p.Set("OCCLUSION_TYPE_STRICT", OCCLUSION_TYPE_STRICT)
	return a
}

// OcclusionQueryAlgorithmType returns the OcclusionQueryAlgorithmType property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusionqueryalgorithmtype
func (a *AbstractMesh) OcclusionQueryAlgorithmType() float64 {
	retVal := a.p.Get("occlusionQueryAlgorithmType")
	return retVal.Float()
}

// SetOcclusionQueryAlgorithmType sets the OcclusionQueryAlgorithmType property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusionqueryalgorithmtype
func (a *AbstractMesh) SetOcclusionQueryAlgorithmType(occlusionQueryAlgorithmType float64) *AbstractMesh {
	a.p.Set("occlusionQueryAlgorithmType", occlusionQueryAlgorithmType)
	return a
}

// OcclusionRetryCount returns the OcclusionRetryCount property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusionretrycount
func (a *AbstractMesh) OcclusionRetryCount() float64 {
	retVal := a.p.Get("occlusionRetryCount")
	return retVal.Float()
}

// SetOcclusionRetryCount sets the OcclusionRetryCount property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusionretrycount
func (a *AbstractMesh) SetOcclusionRetryCount(occlusionRetryCount float64) *AbstractMesh {
	a.p.Set("occlusionRetryCount", occlusionRetryCount)
	return a
}

// OcclusionType returns the OcclusionType property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusiontype
func (a *AbstractMesh) OcclusionType() float64 {
	retVal := a.p.Get("occlusionType")
	return retVal.Float()
}

// SetOcclusionType sets the OcclusionType property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#occlusiontype
func (a *AbstractMesh) SetOcclusionType(occlusionType float64) *AbstractMesh {
	a.p.Set("occlusionType", occlusionType)
	return a
}

// OnCollide returns the OnCollide property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#oncollide
func (a *AbstractMesh) OnCollide() js.Value {
	retVal := a.p.Get("onCollide")
	return retVal
}

// SetOnCollide sets the OnCollide property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#oncollide
func (a *AbstractMesh) SetOnCollide(onCollide func()) *AbstractMesh {
	a.p.Set("onCollide", js.FuncOf(func(this js.Value, args []js.Value) interface{} { onCollide(); return nil }))
	return a
}

// OnCollideObservable returns the OnCollideObservable property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#oncollideobservable
func (a *AbstractMesh) OnCollideObservable() *Observable {
	retVal := a.p.Get("onCollideObservable")
	return ObservableFromJSObject(retVal, a.ctx)
}

// SetOnCollideObservable sets the OnCollideObservable property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#oncollideobservable
func (a *AbstractMesh) SetOnCollideObservable(onCollideObservable *Observable) *AbstractMesh {
	a.p.Set("onCollideObservable", onCollideObservable.JSObject())
	return a
}

// OnCollisionPositionChange returns the OnCollisionPositionChange property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#oncollisionpositionchange
func (a *AbstractMesh) OnCollisionPositionChange() js.Value {
	retVal := a.p.Get("onCollisionPositionChange")
	return retVal
}

// SetOnCollisionPositionChange sets the OnCollisionPositionChange property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#oncollisionpositionchange
func (a *AbstractMesh) SetOnCollisionPositionChange(onCollisionPositionChange func()) *AbstractMesh {
	a.p.Set("onCollisionPositionChange", js.FuncOf(func(this js.Value, args []js.Value) interface{} { onCollisionPositionChange(); return nil }))
	return a
}

// OnCollisionPositionChangeObservable returns the OnCollisionPositionChangeObservable property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#oncollisionpositionchangeobservable
func (a *AbstractMesh) OnCollisionPositionChangeObservable() *Observable {
	retVal := a.p.Get("onCollisionPositionChangeObservable")
	return ObservableFromJSObject(retVal, a.ctx)
}

// SetOnCollisionPositionChangeObservable sets the OnCollisionPositionChangeObservable property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#oncollisionpositionchangeobservable
func (a *AbstractMesh) SetOnCollisionPositionChangeObservable(onCollisionPositionChangeObservable *Observable) *AbstractMesh {
	a.p.Set("onCollisionPositionChangeObservable", onCollisionPositionChangeObservable.JSObject())
	return a
}

// OnMaterialChangedObservable returns the OnMaterialChangedObservable property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#onmaterialchangedobservable
func (a *AbstractMesh) OnMaterialChangedObservable() *Observable {
	retVal := a.p.Get("onMaterialChangedObservable")
	return ObservableFromJSObject(retVal, a.ctx)
}

// SetOnMaterialChangedObservable sets the OnMaterialChangedObservable property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#onmaterialchangedobservable
func (a *AbstractMesh) SetOnMaterialChangedObservable(onMaterialChangedObservable *Observable) *AbstractMesh {
	a.p.Set("onMaterialChangedObservable", onMaterialChangedObservable.JSObject())
	return a
}

// OnRebuildObservable returns the OnRebuildObservable property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#onrebuildobservable
func (a *AbstractMesh) OnRebuildObservable() *Observable {
	retVal := a.p.Get("onRebuildObservable")
	return ObservableFromJSObject(retVal, a.ctx)
}

// SetOnRebuildObservable sets the OnRebuildObservable property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#onrebuildobservable
func (a *AbstractMesh) SetOnRebuildObservable(onRebuildObservable *Observable) *AbstractMesh {
	a.p.Set("onRebuildObservable", onRebuildObservable.JSObject())
	return a
}

// OutlineColor returns the OutlineColor property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#outlinecolor
func (a *AbstractMesh) OutlineColor() *Color3 {
	retVal := a.p.Get("outlineColor")
	return Color3FromJSObject(retVal, a.ctx)
}

// SetOutlineColor sets the OutlineColor property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#outlinecolor
func (a *AbstractMesh) SetOutlineColor(outlineColor *Color3) *AbstractMesh {
	a.p.Set("outlineColor", outlineColor.JSObject())
	return a
}

// OutlineWidth returns the OutlineWidth property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#outlinewidth
func (a *AbstractMesh) OutlineWidth() float64 {
	retVal := a.p.Get("outlineWidth")
	return retVal.Float()
}

// SetOutlineWidth sets the OutlineWidth property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#outlinewidth
func (a *AbstractMesh) SetOutlineWidth(outlineWidth float64) *AbstractMesh {
	a.p.Set("outlineWidth", outlineWidth)
	return a
}

// OverlayAlpha returns the OverlayAlpha property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#overlayalpha
func (a *AbstractMesh) OverlayAlpha() float64 {
	retVal := a.p.Get("overlayAlpha")
	return retVal.Float()
}

// SetOverlayAlpha sets the OverlayAlpha property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#overlayalpha
func (a *AbstractMesh) SetOverlayAlpha(overlayAlpha float64) *AbstractMesh {
	a.p.Set("overlayAlpha", overlayAlpha)
	return a
}

// OverlayColor returns the OverlayColor property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#overlaycolor
func (a *AbstractMesh) OverlayColor() *Color3 {
	retVal := a.p.Get("overlayColor")
	return Color3FromJSObject(retVal, a.ctx)
}

// SetOverlayColor sets the OverlayColor property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#overlaycolor
func (a *AbstractMesh) SetOverlayColor(overlayColor *Color3) *AbstractMesh {
	a.p.Set("overlayColor", overlayColor.JSObject())
	return a
}

// PartitioningBBoxRatio returns the PartitioningBBoxRatio property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#partitioningbboxratio
func (a *AbstractMesh) PartitioningBBoxRatio() float64 {
	retVal := a.p.Get("partitioningBBoxRatio")
	return retVal.Float()
}

// SetPartitioningBBoxRatio sets the PartitioningBBoxRatio property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#partitioningbboxratio
func (a *AbstractMesh) SetPartitioningBBoxRatio(partitioningBBoxRatio float64) *AbstractMesh {
	a.p.Set("partitioningBBoxRatio", partitioningBBoxRatio)
	return a
}

// PartitioningSubdivisions returns the PartitioningSubdivisions property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#partitioningsubdivisions
func (a *AbstractMesh) PartitioningSubdivisions() float64 {
	retVal := a.p.Get("partitioningSubdivisions")
	return retVal.Float()
}

// SetPartitioningSubdivisions sets the PartitioningSubdivisions property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#partitioningsubdivisions
func (a *AbstractMesh) SetPartitioningSubdivisions(partitioningSubdivisions float64) *AbstractMesh {
	a.p.Set("partitioningSubdivisions", partitioningSubdivisions)
	return a
}

// PhysicsImpostor returns the PhysicsImpostor property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#physicsimpostor
func (a *AbstractMesh) PhysicsImpostor() *PhysicsImpostor {
	retVal := a.p.Get("physicsImpostor")
	return PhysicsImpostorFromJSObject(retVal, a.ctx)
}

// SetPhysicsImpostor sets the PhysicsImpostor property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#physicsimpostor
func (a *AbstractMesh) SetPhysicsImpostor(physicsImpostor *PhysicsImpostor) *AbstractMesh {
	a.p.Set("physicsImpostor", physicsImpostor.JSObject())
	return a
}

// ReceiveShadows returns the ReceiveShadows property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#receiveshadows
func (a *AbstractMesh) ReceiveShadows() bool {
	retVal := a.p.Get("receiveShadows")
	return retVal.Bool()
}

// SetReceiveShadows sets the ReceiveShadows property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#receiveshadows
func (a *AbstractMesh) SetReceiveShadows(receiveShadows bool) *AbstractMesh {
	a.p.Set("receiveShadows", receiveShadows)
	return a
}

// RenderOutline returns the RenderOutline property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#renderoutline
func (a *AbstractMesh) RenderOutline() bool {
	retVal := a.p.Get("renderOutline")
	return retVal.Bool()
}

// SetRenderOutline sets the RenderOutline property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#renderoutline
func (a *AbstractMesh) SetRenderOutline(renderOutline bool) *AbstractMesh {
	a.p.Set("renderOutline", renderOutline)
	return a
}

// RenderOverlay returns the RenderOverlay property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#renderoverlay
func (a *AbstractMesh) RenderOverlay() bool {
	retVal := a.p.Get("renderOverlay")
	return retVal.Bool()
}

// SetRenderOverlay sets the RenderOverlay property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#renderoverlay
func (a *AbstractMesh) SetRenderOverlay(renderOverlay bool) *AbstractMesh {
	a.p.Set("renderOverlay", renderOverlay)
	return a
}

// RenderingGroupId returns the RenderingGroupId property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#renderinggroupid
func (a *AbstractMesh) RenderingGroupId() float64 {
	retVal := a.p.Get("renderingGroupId")
	return retVal.Float()
}

// SetRenderingGroupId sets the RenderingGroupId property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#renderinggroupid
func (a *AbstractMesh) SetRenderingGroupId(renderingGroupId float64) *AbstractMesh {
	a.p.Set("renderingGroupId", renderingGroupId)
	return a
}

// Scaling returns the Scaling property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#scaling
func (a *AbstractMesh) Scaling() *Vector3 {
	retVal := a.p.Get("scaling")
	return Vector3FromJSObject(retVal, a.ctx)
}

// SetScaling sets the Scaling property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#scaling
func (a *AbstractMesh) SetScaling(scaling *Vector3) *AbstractMesh {
	a.p.Set("scaling", scaling.JSObject())
	return a
}

// ShowBoundingBox returns the ShowBoundingBox property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#showboundingbox
func (a *AbstractMesh) ShowBoundingBox() bool {
	retVal := a.p.Get("showBoundingBox")
	return retVal.Bool()
}

// SetShowBoundingBox sets the ShowBoundingBox property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#showboundingbox
func (a *AbstractMesh) SetShowBoundingBox(showBoundingBox bool) *AbstractMesh {
	a.p.Set("showBoundingBox", showBoundingBox)
	return a
}

// ShowSubMeshesBoundingBox returns the ShowSubMeshesBoundingBox property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#showsubmeshesboundingbox
func (a *AbstractMesh) ShowSubMeshesBoundingBox() bool {
	retVal := a.p.Get("showSubMeshesBoundingBox")
	return retVal.Bool()
}

// SetShowSubMeshesBoundingBox sets the ShowSubMeshesBoundingBox property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#showsubmeshesboundingbox
func (a *AbstractMesh) SetShowSubMeshesBoundingBox(showSubMeshesBoundingBox bool) *AbstractMesh {
	a.p.Set("showSubMeshesBoundingBox", showSubMeshesBoundingBox)
	return a
}

// Skeleton returns the Skeleton property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#skeleton
func (a *AbstractMesh) Skeleton() *Skeleton {
	retVal := a.p.Get("skeleton")
	return SkeletonFromJSObject(retVal, a.ctx)
}

// SetSkeleton sets the Skeleton property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#skeleton
func (a *AbstractMesh) SetSkeleton(skeleton *Skeleton) *AbstractMesh {
	a.p.Set("skeleton", skeleton.JSObject())
	return a
}

// SubMeshes returns the SubMeshes property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#submeshes
func (a *AbstractMesh) SubMeshes() *SubMesh {
	retVal := a.p.Get("subMeshes")
	return SubMeshFromJSObject(retVal, a.ctx)
}

// SetSubMeshes sets the SubMeshes property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#submeshes
func (a *AbstractMesh) SetSubMeshes(subMeshes *SubMesh) *AbstractMesh {
	a.p.Set("subMeshes", subMeshes.JSObject())
	return a
}

// UseBones returns the UseBones property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#usebones
func (a *AbstractMesh) UseBones() bool {
	retVal := a.p.Get("useBones")
	return retVal.Bool()
}

// SetUseBones sets the UseBones property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#usebones
func (a *AbstractMesh) SetUseBones(useBones bool) *AbstractMesh {
	a.p.Set("useBones", useBones)
	return a
}

// UseOctreeForCollisions returns the UseOctreeForCollisions property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#useoctreeforcollisions
func (a *AbstractMesh) UseOctreeForCollisions() bool {
	retVal := a.p.Get("useOctreeForCollisions")
	return retVal.Bool()
}

// SetUseOctreeForCollisions sets the UseOctreeForCollisions property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#useoctreeforcollisions
func (a *AbstractMesh) SetUseOctreeForCollisions(useOctreeForCollisions bool) *AbstractMesh {
	a.p.Set("useOctreeForCollisions", useOctreeForCollisions)
	return a
}

// UseOctreeForPicking returns the UseOctreeForPicking property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#useoctreeforpicking
func (a *AbstractMesh) UseOctreeForPicking() bool {
	retVal := a.p.Get("useOctreeForPicking")
	return retVal.Bool()
}

// SetUseOctreeForPicking sets the UseOctreeForPicking property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#useoctreeforpicking
func (a *AbstractMesh) SetUseOctreeForPicking(useOctreeForPicking bool) *AbstractMesh {
	a.p.Set("useOctreeForPicking", useOctreeForPicking)
	return a
}

// UseOctreeForRenderingSelection returns the UseOctreeForRenderingSelection property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#useoctreeforrenderingselection
func (a *AbstractMesh) UseOctreeForRenderingSelection() bool {
	retVal := a.p.Get("useOctreeForRenderingSelection")
	return retVal.Bool()
}

// SetUseOctreeForRenderingSelection sets the UseOctreeForRenderingSelection property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#useoctreeforrenderingselection
func (a *AbstractMesh) SetUseOctreeForRenderingSelection(useOctreeForRenderingSelection bool) *AbstractMesh {
	a.p.Set("useOctreeForRenderingSelection", useOctreeForRenderingSelection)
	return a
}

// UseVertexColors returns the UseVertexColors property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#usevertexcolors
func (a *AbstractMesh) UseVertexColors() bool {
	retVal := a.p.Get("useVertexColors")
	return retVal.Bool()
}

// SetUseVertexColors sets the UseVertexColors property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#usevertexcolors
func (a *AbstractMesh) SetUseVertexColors(useVertexColors bool) *AbstractMesh {
	a.p.Set("useVertexColors", useVertexColors)
	return a
}

// Visibility returns the Visibility property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#visibility
func (a *AbstractMesh) Visibility() float64 {
	retVal := a.p.Get("visibility")
	return retVal.Float()
}

// SetVisibility sets the Visibility property of class AbstractMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.abstractmesh#visibility
func (a *AbstractMesh) SetVisibility(visibility float64) *AbstractMesh {
	a.p.Set("visibility", visibility)
	return a
}

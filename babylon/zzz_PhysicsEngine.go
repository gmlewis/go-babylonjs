// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// PhysicsEngine represents a babylon.js PhysicsEngine.
// Class used to control physics engine
//
// See: http://doc.babylonjs.com/how_to/using_the_physics_engine
type PhysicsEngine struct {
	p   js.Value
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (p *PhysicsEngine) JSObject() js.Value { return p.p }

// PhysicsEngine returns a PhysicsEngine JavaScript class.
func (ba *Babylon) PhysicsEngine() *PhysicsEngine {
	p := ba.ctx.Get("PhysicsEngine")
	return PhysicsEngineFromJSObject(p, ba.ctx)
}

// PhysicsEngineFromJSObject returns a wrapped PhysicsEngine JavaScript class.
func PhysicsEngineFromJSObject(p js.Value, ctx js.Value) *PhysicsEngine {
	return &PhysicsEngine{p: p, ctx: ctx}
}

// PhysicsEngineArrayToJSArray returns a JavaScript Array for the wrapped array.
func PhysicsEngineArrayToJSArray(array []*PhysicsEngine) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewPhysicsEngineOpts contains optional parameters for NewPhysicsEngine.
type NewPhysicsEngineOpts struct {
	_physicsPlugin js.Value
}

// NewPhysicsEngine returns a new PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine
func (ba *Babylon) NewPhysicsEngine(gravity *Vector3, opts *NewPhysicsEngineOpts) *PhysicsEngine {
	if opts == nil {
		opts = &NewPhysicsEngineOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, gravity.JSObject())

	args = append(args, opts._physicsPlugin)

	p := ba.ctx.Get("PhysicsEngine").New(args...)
	return PhysicsEngineFromJSObject(p, ba.ctx)
}

// AddImpostor calls the AddImpostor method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#addimpostor
func (p *PhysicsEngine) AddImpostor(impostor *PhysicsImpostor) {

	args := make([]interface{}, 0, 1+0)

	if impostor == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, impostor.JSObject())
	}

	p.p.Call("addImpostor", args...)
}

// AddJoint calls the AddJoint method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#addjoint
func (p *PhysicsEngine) AddJoint(mainImpostor *PhysicsImpostor, connectedImpostor *PhysicsImpostor, joint *PhysicsJoint) {

	args := make([]interface{}, 0, 3+0)

	if mainImpostor == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mainImpostor.JSObject())
	}

	if connectedImpostor == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, connectedImpostor.JSObject())
	}

	if joint == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, joint.JSObject())
	}

	p.p.Call("addJoint", args...)
}

// DefaultPluginFactory calls the DefaultPluginFactory method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#defaultpluginfactory
func (p *PhysicsEngine) DefaultPluginFactory() js.Value {

	retVal := p.p.Call("DefaultPluginFactory")
	return retVal
}

// Dispose calls the Dispose method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#dispose
func (p *PhysicsEngine) Dispose() {

	p.p.Call("dispose")
}

// GetImpostorForPhysicsObject calls the GetImpostorForPhysicsObject method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#getimpostorforphysicsobject
func (p *PhysicsEngine) GetImpostorForPhysicsObject(object *IPhysicsEnabledObject) *PhysicsImpostor {

	args := make([]interface{}, 0, 1+0)

	if object == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, object.JSObject())
	}

	retVal := p.p.Call("getImpostorForPhysicsObject", args...)
	return PhysicsImpostorFromJSObject(retVal, p.ctx)
}

// GetImpostorWithPhysicsBody calls the GetImpostorWithPhysicsBody method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#getimpostorwithphysicsbody
func (p *PhysicsEngine) GetImpostorWithPhysicsBody(body JSObject) *PhysicsImpostor {

	args := make([]interface{}, 0, 1+0)

	if body == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, body.JSObject())
	}

	retVal := p.p.Call("getImpostorWithPhysicsBody", args...)
	return PhysicsImpostorFromJSObject(retVal, p.ctx)
}

// GetImpostors calls the GetImpostors method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#getimpostors
func (p *PhysicsEngine) GetImpostors() []*PhysicsImpostor {

	retVal := p.p.Call("getImpostors")
	result := []*PhysicsImpostor{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, PhysicsImpostorFromJSObject(retVal.Index(ri), p.ctx))
	}
	return result
}

// GetPhysicsPlugin calls the GetPhysicsPlugin method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#getphysicsplugin
func (p *PhysicsEngine) GetPhysicsPlugin() js.Value {

	retVal := p.p.Call("getPhysicsPlugin")
	return retVal
}

// GetPhysicsPluginName calls the GetPhysicsPluginName method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#getphysicspluginname
func (p *PhysicsEngine) GetPhysicsPluginName() string {

	retVal := p.p.Call("getPhysicsPluginName")
	return retVal.String()
}

// GetSubTimeStep calls the GetSubTimeStep method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#getsubtimestep
func (p *PhysicsEngine) GetSubTimeStep() float64 {

	retVal := p.p.Call("getSubTimeStep")
	return retVal.Float()
}

// GetTimeStep calls the GetTimeStep method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#gettimestep
func (p *PhysicsEngine) GetTimeStep() float64 {

	retVal := p.p.Call("getTimeStep")
	return retVal.Float()
}

// Raycast calls the Raycast method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#raycast
func (p *PhysicsEngine) Raycast(from *Vector3, to *Vector3) *PhysicsRaycastResult {

	args := make([]interface{}, 0, 2+0)

	if from == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, from.JSObject())
	}

	if to == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, to.JSObject())
	}

	retVal := p.p.Call("raycast", args...)
	return PhysicsRaycastResultFromJSObject(retVal, p.ctx)
}

// RemoveImpostor calls the RemoveImpostor method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#removeimpostor
func (p *PhysicsEngine) RemoveImpostor(impostor *PhysicsImpostor) {

	args := make([]interface{}, 0, 1+0)

	if impostor == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, impostor.JSObject())
	}

	p.p.Call("removeImpostor", args...)
}

// RemoveJoint calls the RemoveJoint method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#removejoint
func (p *PhysicsEngine) RemoveJoint(mainImpostor *PhysicsImpostor, connectedImpostor *PhysicsImpostor, joint *PhysicsJoint) {

	args := make([]interface{}, 0, 3+0)

	if mainImpostor == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mainImpostor.JSObject())
	}

	if connectedImpostor == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, connectedImpostor.JSObject())
	}

	if joint == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, joint.JSObject())
	}

	p.p.Call("removeJoint", args...)
}

// SetGravity calls the SetGravity method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#setgravity
func (p *PhysicsEngine) SetGravity(gravity *Vector3) {

	args := make([]interface{}, 0, 1+0)

	if gravity == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, gravity.JSObject())
	}

	p.p.Call("setGravity", args...)
}

// PhysicsEngineSetSubTimeStepOpts contains optional parameters for PhysicsEngine.SetSubTimeStep.
type PhysicsEngineSetSubTimeStepOpts struct {
	SubTimeStep *float64
}

// SetSubTimeStep calls the SetSubTimeStep method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#setsubtimestep
func (p *PhysicsEngine) SetSubTimeStep(opts *PhysicsEngineSetSubTimeStepOpts) {
	if opts == nil {
		opts = &PhysicsEngineSetSubTimeStepOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.SubTimeStep == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SubTimeStep)
	}

	p.p.Call("setSubTimeStep", args...)
}

// PhysicsEngineSetTimeStepOpts contains optional parameters for PhysicsEngine.SetTimeStep.
type PhysicsEngineSetTimeStepOpts struct {
	NewTimeStep *float64
}

// SetTimeStep calls the SetTimeStep method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#settimestep
func (p *PhysicsEngine) SetTimeStep(opts *PhysicsEngineSetTimeStepOpts) {
	if opts == nil {
		opts = &PhysicsEngineSetTimeStepOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.NewTimeStep == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.NewTimeStep)
	}

	p.p.Call("setTimeStep", args...)
}

// _step calls the _step method on the PhysicsEngine object.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#_step
func (p *PhysicsEngine) _step(delta float64) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, delta)

	p.p.Call("_step", args...)
}

// Epsilon returns the Epsilon property of class PhysicsEngine.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#epsilon
func (p *PhysicsEngine) Epsilon() float64 {
	retVal := p.p.Get("Epsilon")
	return retVal.Float()
}

// SetEpsilon sets the Epsilon property of class PhysicsEngine.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#epsilon
func (p *PhysicsEngine) SetEpsilon(Epsilon float64) *PhysicsEngine {
	p.p.Set("Epsilon", Epsilon)
	return p
}

// Gravity returns the Gravity property of class PhysicsEngine.
//
// https://doc.babylonjs.com/api/classes/babylon.physicsengine#gravity
func (p *PhysicsEngine) Gravity() *Vector3 {
	retVal := p.p.Get("gravity")
	return Vector3FromJSObject(retVal, p.ctx)
}

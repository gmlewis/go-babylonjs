// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// ShaderMaterial represents a babylon.js ShaderMaterial.
// The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.
//
// This returned material effects how the mesh will look based on the code in the shaders.
//
// See: http://doc.babylonjs.com/how_to/shader_material
type ShaderMaterial struct {
	*Material
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (s *ShaderMaterial) JSObject() js.Value { return s.p }

// ShaderMaterial returns a ShaderMaterial JavaScript class.
func (ba *Babylon) ShaderMaterial() *ShaderMaterial {
	p := ba.ctx.Get("ShaderMaterial")
	return ShaderMaterialFromJSObject(p, ba.ctx)
}

// ShaderMaterialFromJSObject returns a wrapped ShaderMaterial JavaScript class.
func ShaderMaterialFromJSObject(p js.Value, ctx js.Value) *ShaderMaterial {
	return &ShaderMaterial{Material: MaterialFromJSObject(p, ctx), ctx: ctx}
}

// ShaderMaterialArrayToJSArray returns a JavaScript Array for the wrapped array.
func ShaderMaterialArrayToJSArray(array []*ShaderMaterial) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewShaderMaterialOpts contains optional parameters for NewShaderMaterial.
type NewShaderMaterialOpts struct {
	Options *IShaderMaterialOptions
}

// NewShaderMaterial returns a new ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial
func (ba *Babylon) NewShaderMaterial(name string, scene *Scene, shaderPath interface{}, opts *NewShaderMaterialOpts) *ShaderMaterial {
	if opts == nil {
		opts = &NewShaderMaterialOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	args = append(args, name)
	args = append(args, scene.JSObject())
	args = append(args, shaderPath)

	if opts.Options == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Options.JSObject())
	}

	p := ba.ctx.Get("ShaderMaterial").New(args...)
	return ShaderMaterialFromJSObject(p, ba.ctx)
}

// ShaderMaterialBindOpts contains optional parameters for ShaderMaterial.Bind.
type ShaderMaterialBindOpts struct {
	Mesh *Mesh
}

// Bind calls the Bind method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#bind
func (s *ShaderMaterial) Bind(world *Matrix, opts *ShaderMaterialBindOpts) {
	if opts == nil {
		opts = &ShaderMaterialBindOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, world.JSObject())

	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	s.p.Call("bind", args...)
}

// BindOnlyWorldMatrix calls the BindOnlyWorldMatrix method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#bindonlyworldmatrix
func (s *ShaderMaterial) BindOnlyWorldMatrix(world *Matrix) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, world.JSObject())

	s.p.Call("bindOnlyWorldMatrix", args...)
}

// Clone calls the Clone method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#clone
func (s *ShaderMaterial) Clone(name string) *ShaderMaterial {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := s.p.Call("clone", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// ShaderMaterialDisposeOpts contains optional parameters for ShaderMaterial.Dispose.
type ShaderMaterialDisposeOpts struct {
	ForceDisposeEffect   *bool
	ForceDisposeTextures *bool
	NotBoundToMesh       *bool
}

// Dispose calls the Dispose method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#dispose
func (s *ShaderMaterial) Dispose(opts *ShaderMaterialDisposeOpts) {
	if opts == nil {
		opts = &ShaderMaterialDisposeOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.ForceDisposeEffect == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceDisposeEffect)
	}
	if opts.ForceDisposeTextures == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceDisposeTextures)
	}
	if opts.NotBoundToMesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.NotBoundToMesh)
	}

	s.p.Call("dispose", args...)
}

// GetActiveTextures calls the GetActiveTextures method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#getactivetextures
func (s *ShaderMaterial) GetActiveTextures() *BaseTexture {

	retVal := s.p.Call("getActiveTextures")
	return BaseTextureFromJSObject(retVal, s.ctx)
}

// GetClassName calls the GetClassName method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#getclassname
func (s *ShaderMaterial) GetClassName() string {

	retVal := s.p.Call("getClassName")
	return retVal.String()
}

// HasTexture calls the HasTexture method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#hastexture
func (s *ShaderMaterial) HasTexture(texture *BaseTexture) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, texture.JSObject())

	retVal := s.p.Call("hasTexture", args...)
	return retVal.Bool()
}

// ShaderMaterialIsReadyOpts contains optional parameters for ShaderMaterial.IsReady.
type ShaderMaterialIsReadyOpts struct {
	Mesh         *AbstractMesh
	UseInstances *bool
}

// IsReady calls the IsReady method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#isready
func (s *ShaderMaterial) IsReady(opts *ShaderMaterialIsReadyOpts) bool {
	if opts == nil {
		opts = &ShaderMaterialIsReadyOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}
	if opts.UseInstances == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UseInstances)
	}

	retVal := s.p.Call("isReady", args...)
	return retVal.Bool()
}

// ShaderMaterialIsReadyForSubMeshOpts contains optional parameters for ShaderMaterial.IsReadyForSubMesh.
type ShaderMaterialIsReadyForSubMeshOpts struct {
	UseInstances *bool
}

// IsReadyForSubMesh calls the IsReadyForSubMesh method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#isreadyforsubmesh
func (s *ShaderMaterial) IsReadyForSubMesh(mesh *AbstractMesh, subMesh *BaseSubMesh, opts *ShaderMaterialIsReadyForSubMeshOpts) bool {
	if opts == nil {
		opts = &ShaderMaterialIsReadyForSubMeshOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, mesh.JSObject())
	args = append(args, subMesh.JSObject())

	if opts.UseInstances == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UseInstances)
	}

	retVal := s.p.Call("isReadyForSubMesh", args...)
	return retVal.Bool()
}

// NeedAlphaBlending calls the NeedAlphaBlending method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#needalphablending
func (s *ShaderMaterial) NeedAlphaBlending() bool {

	retVal := s.p.Call("needAlphaBlending")
	return retVal.Bool()
}

// NeedAlphaTesting calls the NeedAlphaTesting method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#needalphatesting
func (s *ShaderMaterial) NeedAlphaTesting() bool {

	retVal := s.p.Call("needAlphaTesting")
	return retVal.Bool()
}

// Parse calls the Parse method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#parse
func (s *ShaderMaterial) Parse(source interface{}, scene *Scene, rootUrl string) *ShaderMaterial {

	args := make([]interface{}, 0, 3+0)

	args = append(args, source)
	args = append(args, scene.JSObject())
	args = append(args, rootUrl)

	retVal := s.p.Call("Parse", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// Serialize calls the Serialize method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#serialize
func (s *ShaderMaterial) Serialize() interface{} {

	retVal := s.p.Call("serialize")
	return retVal
}

// SetArray2 calls the SetArray2 method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setarray2
func (s *ShaderMaterial) SetArray2(name string, value float64) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value)

	retVal := s.p.Call("setArray2", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetArray3 calls the SetArray3 method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setarray3
func (s *ShaderMaterial) SetArray3(name string, value float64) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value)

	retVal := s.p.Call("setArray3", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetArray4 calls the SetArray4 method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setarray4
func (s *ShaderMaterial) SetArray4(name string, value float64) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value)

	retVal := s.p.Call("setArray4", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetColor3 calls the SetColor3 method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setcolor3
func (s *ShaderMaterial) SetColor3(name string, value *Color3) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value.JSObject())

	retVal := s.p.Call("setColor3", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetColor3Array calls the SetColor3Array method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setcolor3array
func (s *ShaderMaterial) SetColor3Array(name string, value *Color3) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value.JSObject())

	retVal := s.p.Call("setColor3Array", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetColor4 calls the SetColor4 method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setcolor4
func (s *ShaderMaterial) SetColor4(name string, value *Color4) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value.JSObject())

	retVal := s.p.Call("setColor4", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetColor4Array calls the SetColor4Array method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setcolor4array
func (s *ShaderMaterial) SetColor4Array(name string, value *Color4) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value.JSObject())

	retVal := s.p.Call("setColor4Array", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetFloat calls the SetFloat method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setfloat
func (s *ShaderMaterial) SetFloat(name string, value float64) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value)

	retVal := s.p.Call("setFloat", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetFloats calls the SetFloats method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setfloats
func (s *ShaderMaterial) SetFloats(name string, value float64) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value)

	retVal := s.p.Call("setFloats", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetInt calls the SetInt method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setint
func (s *ShaderMaterial) SetInt(name string, value float64) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value)

	retVal := s.p.Call("setInt", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetMatrices calls the SetMatrices method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setmatrices
func (s *ShaderMaterial) SetMatrices(name string, value *Matrix) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value.JSObject())

	retVal := s.p.Call("setMatrices", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetMatrix calls the SetMatrix method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setmatrix
func (s *ShaderMaterial) SetMatrix(name string, value *Matrix) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value.JSObject())

	retVal := s.p.Call("setMatrix", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetMatrix2x2 calls the SetMatrix2x2 method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setmatrix2x2
func (s *ShaderMaterial) SetMatrix2x2(name string, value js.Value) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value)

	retVal := s.p.Call("setMatrix2x2", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetMatrix3x3 calls the SetMatrix3x3 method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setmatrix3x3
func (s *ShaderMaterial) SetMatrix3x3(name string, value js.Value) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value)

	retVal := s.p.Call("setMatrix3x3", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetTexture calls the SetTexture method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#settexture
func (s *ShaderMaterial) SetTexture(name string, texture *Texture) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, texture.JSObject())

	retVal := s.p.Call("setTexture", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetTextureArray calls the SetTextureArray method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#settexturearray
func (s *ShaderMaterial) SetTextureArray(name string, textures *Texture) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, textures.JSObject())

	retVal := s.p.Call("setTextureArray", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetVector2 calls the SetVector2 method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setvector2
func (s *ShaderMaterial) SetVector2(name string, value *Vector2) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value.JSObject())

	retVal := s.p.Call("setVector2", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetVector3 calls the SetVector3 method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setvector3
func (s *ShaderMaterial) SetVector3(name string, value *Vector3) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value.JSObject())

	retVal := s.p.Call("setVector3", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// SetVector4 calls the SetVector4 method on the ShaderMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#setvector4
func (s *ShaderMaterial) SetVector4(name string, value *Vector4) *ShaderMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, value.JSObject())

	retVal := s.p.Call("setVector4", args...)
	return ShaderMaterialFromJSObject(retVal, s.ctx)
}

// Options returns the Options property of class ShaderMaterial.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#options
func (s *ShaderMaterial) Options() *IShaderMaterialOptions {
	retVal := s.p.Get("options")
	return IShaderMaterialOptionsFromJSObject(retVal, s.ctx)
}

// SetOptions sets the Options property of class ShaderMaterial.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#options
func (s *ShaderMaterial) SetOptions(options *IShaderMaterialOptions) *ShaderMaterial {
	s.p.Set("options", options.JSObject())
	return s
}

// ShaderPath returns the ShaderPath property of class ShaderMaterial.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#shaderpath
func (s *ShaderMaterial) ShaderPath() interface{} {
	retVal := s.p.Get("shaderPath")
	return retVal
}

// SetShaderPath sets the ShaderPath property of class ShaderMaterial.
//
// https://doc.babylonjs.com/api/classes/babylon.shadermaterial#shaderpath
func (s *ShaderMaterial) SetShaderPath(shaderPath interface{}) *ShaderMaterial {
	s.p.Set("shaderPath", shaderPath)
	return s
}

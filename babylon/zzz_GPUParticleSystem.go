// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// GPUParticleSystem represents a babylon.js GPUParticleSystem.
// This represents a GPU particle system in Babylon
// This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data
//
// See: https://www.babylonjs-playground.com/#PU4WYI#4
type GPUParticleSystem struct {
	*BaseParticleSystem
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (g *GPUParticleSystem) JSObject() js.Value { return g.p }

// GPUParticleSystem returns a GPUParticleSystem JavaScript class.
func (ba *Babylon) GPUParticleSystem() *GPUParticleSystem {
	p := ba.ctx.Get("GPUParticleSystem")
	return GPUParticleSystemFromJSObject(p, ba.ctx)
}

// GPUParticleSystemFromJSObject returns a wrapped GPUParticleSystem JavaScript class.
func GPUParticleSystemFromJSObject(p js.Value, ctx js.Value) *GPUParticleSystem {
	return &GPUParticleSystem{BaseParticleSystem: BaseParticleSystemFromJSObject(p, ctx), ctx: ctx}
}

// GPUParticleSystemArrayToJSArray returns a JavaScript Array for the wrapped array.
func GPUParticleSystemArrayToJSArray(array []*GPUParticleSystem) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewGPUParticleSystemOpts contains optional parameters for NewGPUParticleSystem.
type NewGPUParticleSystemOpts struct {
	IsAnimationSheetEnabled *bool
}

// NewGPUParticleSystem returns a new GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem
func (ba *Babylon) NewGPUParticleSystem(name string, options js.Value, scene *Scene, opts *NewGPUParticleSystemOpts) *GPUParticleSystem {
	if opts == nil {
		opts = &NewGPUParticleSystemOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	args = append(args, name)
	args = append(args, options)
	args = append(args, scene.JSObject())

	if opts.IsAnimationSheetEnabled == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IsAnimationSheetEnabled)
	}

	p := ba.ctx.Get("GPUParticleSystem").New(args...)
	return GPUParticleSystemFromJSObject(p, ba.ctx)
}

// AddAlphaRemapGradient calls the AddAlphaRemapGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#addalpharemapgradient
func (g *GPUParticleSystem) AddAlphaRemapGradient(gradient float64, min float64, max float64) *IParticleSystem {

	args := make([]interface{}, 0, 3+0)

	args = append(args, gradient)

	args = append(args, min)

	args = append(args, max)

	retVal := g.p.Call("addAlphaRemapGradient", args...)
	return IParticleSystemFromJSObject(retVal, g.ctx)
}

// AddAngularSpeedGradient calls the AddAngularSpeedGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#addangularspeedgradient
func (g *GPUParticleSystem) AddAngularSpeedGradient(gradient float64, factor float64) *GPUParticleSystem {

	args := make([]interface{}, 0, 2+0)

	args = append(args, gradient)

	args = append(args, factor)

	retVal := g.p.Call("addAngularSpeedGradient", args...)
	return GPUParticleSystemFromJSObject(retVal, g.ctx)
}

// GPUParticleSystemAddColorGradientOpts contains optional parameters for GPUParticleSystem.AddColorGradient.
type GPUParticleSystemAddColorGradientOpts struct {
	Color2 *Color4
}

// AddColorGradient calls the AddColorGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#addcolorgradient
func (g *GPUParticleSystem) AddColorGradient(gradient float64, color1 *Color4, opts *GPUParticleSystemAddColorGradientOpts) *GPUParticleSystem {
	if opts == nil {
		opts = &GPUParticleSystemAddColorGradientOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, gradient)

	if color1 == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, color1.JSObject())
	}

	if opts.Color2 == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Color2.JSObject())
	}

	retVal := g.p.Call("addColorGradient", args...)
	return GPUParticleSystemFromJSObject(retVal, g.ctx)
}

// AddColorRemapGradient calls the AddColorRemapGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#addcolorremapgradient
func (g *GPUParticleSystem) AddColorRemapGradient(gradient float64, min float64, max float64) *IParticleSystem {

	args := make([]interface{}, 0, 3+0)

	args = append(args, gradient)

	args = append(args, min)

	args = append(args, max)

	retVal := g.p.Call("addColorRemapGradient", args...)
	return IParticleSystemFromJSObject(retVal, g.ctx)
}

// AddDragGradient calls the AddDragGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#adddraggradient
func (g *GPUParticleSystem) AddDragGradient(gradient float64, factor float64) *GPUParticleSystem {

	args := make([]interface{}, 0, 2+0)

	args = append(args, gradient)

	args = append(args, factor)

	retVal := g.p.Call("addDragGradient", args...)
	return GPUParticleSystemFromJSObject(retVal, g.ctx)
}

// GPUParticleSystemAddEmitRateGradientOpts contains optional parameters for GPUParticleSystem.AddEmitRateGradient.
type GPUParticleSystemAddEmitRateGradientOpts struct {
	Factor2 *float64
}

// AddEmitRateGradient calls the AddEmitRateGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#addemitrategradient
func (g *GPUParticleSystem) AddEmitRateGradient(gradient float64, factor float64, opts *GPUParticleSystemAddEmitRateGradientOpts) *IParticleSystem {
	if opts == nil {
		opts = &GPUParticleSystemAddEmitRateGradientOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, gradient)

	args = append(args, factor)

	if opts.Factor2 == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Factor2)
	}

	retVal := g.p.Call("addEmitRateGradient", args...)
	return IParticleSystemFromJSObject(retVal, g.ctx)
}

// GPUParticleSystemAddLifeTimeGradientOpts contains optional parameters for GPUParticleSystem.AddLifeTimeGradient.
type GPUParticleSystemAddLifeTimeGradientOpts struct {
	Factor2 *float64
}

// AddLifeTimeGradient calls the AddLifeTimeGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#addlifetimegradient
func (g *GPUParticleSystem) AddLifeTimeGradient(gradient float64, factor float64, opts *GPUParticleSystemAddLifeTimeGradientOpts) *IParticleSystem {
	if opts == nil {
		opts = &GPUParticleSystemAddLifeTimeGradientOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, gradient)

	args = append(args, factor)

	if opts.Factor2 == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Factor2)
	}

	retVal := g.p.Call("addLifeTimeGradient", args...)
	return IParticleSystemFromJSObject(retVal, g.ctx)
}

// AddLimitVelocityGradient calls the AddLimitVelocityGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#addlimitvelocitygradient
func (g *GPUParticleSystem) AddLimitVelocityGradient(gradient float64, factor float64) *GPUParticleSystem {

	args := make([]interface{}, 0, 2+0)

	args = append(args, gradient)

	args = append(args, factor)

	retVal := g.p.Call("addLimitVelocityGradient", args...)
	return GPUParticleSystemFromJSObject(retVal, g.ctx)
}

// AddRampGradient calls the AddRampGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#addrampgradient
func (g *GPUParticleSystem) AddRampGradient(gradient float64, color *Color3) *IParticleSystem {

	args := make([]interface{}, 0, 2+0)

	args = append(args, gradient)

	if color == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, color.JSObject())
	}

	retVal := g.p.Call("addRampGradient", args...)
	return IParticleSystemFromJSObject(retVal, g.ctx)
}

// AddSizeGradient calls the AddSizeGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#addsizegradient
func (g *GPUParticleSystem) AddSizeGradient(gradient float64, factor float64) *GPUParticleSystem {

	args := make([]interface{}, 0, 2+0)

	args = append(args, gradient)

	args = append(args, factor)

	retVal := g.p.Call("addSizeGradient", args...)
	return GPUParticleSystemFromJSObject(retVal, g.ctx)
}

// GPUParticleSystemAddStartSizeGradientOpts contains optional parameters for GPUParticleSystem.AddStartSizeGradient.
type GPUParticleSystemAddStartSizeGradientOpts struct {
	Factor2 *float64
}

// AddStartSizeGradient calls the AddStartSizeGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#addstartsizegradient
func (g *GPUParticleSystem) AddStartSizeGradient(gradient float64, factor float64, opts *GPUParticleSystemAddStartSizeGradientOpts) *IParticleSystem {
	if opts == nil {
		opts = &GPUParticleSystemAddStartSizeGradientOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, gradient)

	args = append(args, factor)

	if opts.Factor2 == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Factor2)
	}

	retVal := g.p.Call("addStartSizeGradient", args...)
	return IParticleSystemFromJSObject(retVal, g.ctx)
}

// AddVelocityGradient calls the AddVelocityGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#addvelocitygradient
func (g *GPUParticleSystem) AddVelocityGradient(gradient float64, factor float64) *GPUParticleSystem {

	args := make([]interface{}, 0, 2+0)

	args = append(args, gradient)

	args = append(args, factor)

	retVal := g.p.Call("addVelocityGradient", args...)
	return GPUParticleSystemFromJSObject(retVal, g.ctx)
}

// GPUParticleSystemAnimateOpts contains optional parameters for GPUParticleSystem.Animate.
type GPUParticleSystemAnimateOpts struct {
	PreWarm *bool
}

// Animate calls the Animate method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#animate
func (g *GPUParticleSystem) Animate(opts *GPUParticleSystemAnimateOpts) {
	if opts == nil {
		opts = &GPUParticleSystemAnimateOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.PreWarm == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.PreWarm)
	}

	g.p.Call("animate", args...)
}

// Clone calls the Clone method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#clone
func (g *GPUParticleSystem) Clone(name string, newEmitter JSObject) *GPUParticleSystem {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)

	if newEmitter == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, newEmitter.JSObject())
	}

	retVal := g.p.Call("clone", args...)
	return GPUParticleSystemFromJSObject(retVal, g.ctx)
}

// GPUParticleSystemDisposeOpts contains optional parameters for GPUParticleSystem.Dispose.
type GPUParticleSystemDisposeOpts struct {
	DisposeTexture *bool
}

// Dispose calls the Dispose method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#dispose
func (g *GPUParticleSystem) Dispose(opts *GPUParticleSystemDisposeOpts) {
	if opts == nil {
		opts = &GPUParticleSystemDisposeOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.DisposeTexture == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DisposeTexture)
	}

	g.p.Call("dispose", args...)
}

// GetCapacity calls the GetCapacity method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#getcapacity
func (g *GPUParticleSystem) GetCapacity() float64 {

	retVal := g.p.Call("getCapacity")
	return retVal.Float()
}

// GetClassName calls the GetClassName method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#getclassname
func (g *GPUParticleSystem) GetClassName() string {

	retVal := g.p.Call("getClassName")
	return retVal.String()
}

// GetRampGradients calls the GetRampGradients method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#getrampgradients
func (g *GPUParticleSystem) GetRampGradients() []*Color3Gradient {

	retVal := g.p.Call("getRampGradients")
	result := []*Color3Gradient{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, Color3GradientFromJSObject(retVal.Index(ri), g.ctx))
	}
	return result
}

// IsReady calls the IsReady method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#isready
func (g *GPUParticleSystem) IsReady() bool {

	retVal := g.p.Call("isReady")
	return retVal.Bool()
}

// IsStarted calls the IsStarted method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#isstarted
func (g *GPUParticleSystem) IsStarted() bool {

	retVal := g.p.Call("isStarted")
	return retVal.Bool()
}

// GPUParticleSystemParseOpts contains optional parameters for GPUParticleSystem.Parse.
type GPUParticleSystemParseOpts struct {
	DoNotStart *bool
}

// Parse calls the Parse method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#parse
func (g *GPUParticleSystem) Parse(parsedParticleSystem JSObject, scene *Scene, rootUrl string, opts *GPUParticleSystemParseOpts) *GPUParticleSystem {
	if opts == nil {
		opts = &GPUParticleSystemParseOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	if parsedParticleSystem == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, parsedParticleSystem.JSObject())
	}

	if scene == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, scene.JSObject())
	}

	args = append(args, rootUrl)

	if opts.DoNotStart == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotStart)
	}

	retVal := g.p.Call("Parse", args...)
	return GPUParticleSystemFromJSObject(retVal, g.ctx)
}

// Rebuild calls the Rebuild method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#rebuild
func (g *GPUParticleSystem) Rebuild() {

	g.p.Call("rebuild")
}

// RemoveAlphaRemapGradient calls the RemoveAlphaRemapGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#removealpharemapgradient
func (g *GPUParticleSystem) RemoveAlphaRemapGradient() *IParticleSystem {

	retVal := g.p.Call("removeAlphaRemapGradient")
	return IParticleSystemFromJSObject(retVal, g.ctx)
}

// RemoveAngularSpeedGradient calls the RemoveAngularSpeedGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#removeangularspeedgradient
func (g *GPUParticleSystem) RemoveAngularSpeedGradient(gradient float64) *GPUParticleSystem {

	args := make([]interface{}, 0, 1+0)

	args = append(args, gradient)

	retVal := g.p.Call("removeAngularSpeedGradient", args...)
	return GPUParticleSystemFromJSObject(retVal, g.ctx)
}

// RemoveColorGradient calls the RemoveColorGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#removecolorgradient
func (g *GPUParticleSystem) RemoveColorGradient(gradient float64) *GPUParticleSystem {

	args := make([]interface{}, 0, 1+0)

	args = append(args, gradient)

	retVal := g.p.Call("removeColorGradient", args...)
	return GPUParticleSystemFromJSObject(retVal, g.ctx)
}

// RemoveColorRemapGradient calls the RemoveColorRemapGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#removecolorremapgradient
func (g *GPUParticleSystem) RemoveColorRemapGradient() *IParticleSystem {

	retVal := g.p.Call("removeColorRemapGradient")
	return IParticleSystemFromJSObject(retVal, g.ctx)
}

// RemoveDragGradient calls the RemoveDragGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#removedraggradient
func (g *GPUParticleSystem) RemoveDragGradient(gradient float64) *GPUParticleSystem {

	args := make([]interface{}, 0, 1+0)

	args = append(args, gradient)

	retVal := g.p.Call("removeDragGradient", args...)
	return GPUParticleSystemFromJSObject(retVal, g.ctx)
}

// RemoveEmitRateGradient calls the RemoveEmitRateGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#removeemitrategradient
func (g *GPUParticleSystem) RemoveEmitRateGradient(gradient float64) *IParticleSystem {

	args := make([]interface{}, 0, 1+0)

	args = append(args, gradient)

	retVal := g.p.Call("removeEmitRateGradient", args...)
	return IParticleSystemFromJSObject(retVal, g.ctx)
}

// RemoveLifeTimeGradient calls the RemoveLifeTimeGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#removelifetimegradient
func (g *GPUParticleSystem) RemoveLifeTimeGradient(gradient float64) *IParticleSystem {

	args := make([]interface{}, 0, 1+0)

	args = append(args, gradient)

	retVal := g.p.Call("removeLifeTimeGradient", args...)
	return IParticleSystemFromJSObject(retVal, g.ctx)
}

// RemoveLimitVelocityGradient calls the RemoveLimitVelocityGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#removelimitvelocitygradient
func (g *GPUParticleSystem) RemoveLimitVelocityGradient(gradient float64) *GPUParticleSystem {

	args := make([]interface{}, 0, 1+0)

	args = append(args, gradient)

	retVal := g.p.Call("removeLimitVelocityGradient", args...)
	return GPUParticleSystemFromJSObject(retVal, g.ctx)
}

// RemoveRampGradient calls the RemoveRampGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#removerampgradient
func (g *GPUParticleSystem) RemoveRampGradient() *IParticleSystem {

	retVal := g.p.Call("removeRampGradient")
	return IParticleSystemFromJSObject(retVal, g.ctx)
}

// RemoveSizeGradient calls the RemoveSizeGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#removesizegradient
func (g *GPUParticleSystem) RemoveSizeGradient(gradient float64) *GPUParticleSystem {

	args := make([]interface{}, 0, 1+0)

	args = append(args, gradient)

	retVal := g.p.Call("removeSizeGradient", args...)
	return GPUParticleSystemFromJSObject(retVal, g.ctx)
}

// RemoveStartSizeGradient calls the RemoveStartSizeGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#removestartsizegradient
func (g *GPUParticleSystem) RemoveStartSizeGradient(gradient float64) *IParticleSystem {

	args := make([]interface{}, 0, 1+0)

	args = append(args, gradient)

	retVal := g.p.Call("removeStartSizeGradient", args...)
	return IParticleSystemFromJSObject(retVal, g.ctx)
}

// RemoveVelocityGradient calls the RemoveVelocityGradient method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#removevelocitygradient
func (g *GPUParticleSystem) RemoveVelocityGradient(gradient float64) *GPUParticleSystem {

	args := make([]interface{}, 0, 1+0)

	args = append(args, gradient)

	retVal := g.p.Call("removeVelocityGradient", args...)
	return GPUParticleSystemFromJSObject(retVal, g.ctx)
}

// GPUParticleSystemRenderOpts contains optional parameters for GPUParticleSystem.Render.
type GPUParticleSystemRenderOpts struct {
	PreWarm *bool
}

// Render calls the Render method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#render
func (g *GPUParticleSystem) Render(opts *GPUParticleSystemRenderOpts) float64 {
	if opts == nil {
		opts = &GPUParticleSystemRenderOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.PreWarm == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.PreWarm)
	}

	retVal := g.p.Call("render", args...)
	return retVal.Float()
}

// Reset calls the Reset method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#reset
func (g *GPUParticleSystem) Reset() {

	g.p.Call("reset")
}

// Serialize calls the Serialize method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#serialize
func (g *GPUParticleSystem) Serialize() js.Value {

	retVal := g.p.Call("serialize")
	return retVal
}

// GPUParticleSystemStartOpts contains optional parameters for GPUParticleSystem.Start.
type GPUParticleSystemStartOpts struct {
	Delay *float64
}

// Start calls the Start method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#start
func (g *GPUParticleSystem) Start(opts *GPUParticleSystemStartOpts) {
	if opts == nil {
		opts = &GPUParticleSystemStartOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.Delay == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Delay)
	}

	g.p.Call("start", args...)
}

// Stop calls the Stop method on the GPUParticleSystem object.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#stop
func (g *GPUParticleSystem) Stop() {

	g.p.Call("stop")
}

// ActiveParticleCount returns the ActiveParticleCount property of class GPUParticleSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#activeparticlecount
func (g *GPUParticleSystem) ActiveParticleCount() float64 {
	retVal := g.p.Get("activeParticleCount")
	return retVal.Float()
}

// SetActiveParticleCount sets the ActiveParticleCount property of class GPUParticleSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#activeparticlecount
func (g *GPUParticleSystem) SetActiveParticleCount(activeParticleCount float64) *GPUParticleSystem {
	g.p.Set("activeParticleCount", activeParticleCount)
	return g
}

// ForceDepthWrite returns the ForceDepthWrite property of class GPUParticleSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#forcedepthwrite
func (g *GPUParticleSystem) ForceDepthWrite() bool {
	retVal := g.p.Get("forceDepthWrite")
	return retVal.Bool()
}

// SetForceDepthWrite sets the ForceDepthWrite property of class GPUParticleSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#forcedepthwrite
func (g *GPUParticleSystem) SetForceDepthWrite(forceDepthWrite bool) *GPUParticleSystem {
	g.p.Set("forceDepthWrite", forceDepthWrite)
	return g
}

// IsSupported returns the IsSupported property of class GPUParticleSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#issupported
func (g *GPUParticleSystem) IsSupported() bool {
	retVal := g.p.Get("IsSupported")
	return retVal.Bool()
}

// SetIsSupported sets the IsSupported property of class GPUParticleSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#issupported
func (g *GPUParticleSystem) SetIsSupported(IsSupported bool) *GPUParticleSystem {
	g.p.Set("IsSupported", IsSupported)
	return g
}

// LayerMask returns the LayerMask property of class GPUParticleSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#layermask
func (g *GPUParticleSystem) LayerMask() float64 {
	retVal := g.p.Get("layerMask")
	return retVal.Float()
}

// SetLayerMask sets the LayerMask property of class GPUParticleSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#layermask
func (g *GPUParticleSystem) SetLayerMask(layerMask float64) *GPUParticleSystem {
	g.p.Set("layerMask", layerMask)
	return g
}

// OnDisposeObservable returns the OnDisposeObservable property of class GPUParticleSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#ondisposeobservable
func (g *GPUParticleSystem) OnDisposeObservable() *Observable {
	retVal := g.p.Get("onDisposeObservable")
	return ObservableFromJSObject(retVal, g.ctx)
}

// SetOnDisposeObservable sets the OnDisposeObservable property of class GPUParticleSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#ondisposeobservable
func (g *GPUParticleSystem) SetOnDisposeObservable(onDisposeObservable *Observable) *GPUParticleSystem {
	g.p.Set("onDisposeObservable", onDisposeObservable.JSObject())
	return g
}

// UseRampGradients returns the UseRampGradients property of class GPUParticleSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#userampgradients
func (g *GPUParticleSystem) UseRampGradients() bool {
	retVal := g.p.Get("useRampGradients")
	return retVal.Bool()
}

// SetUseRampGradients sets the UseRampGradients property of class GPUParticleSystem.
//
// https://doc.babylonjs.com/api/classes/babylon.gpuparticlesystem#userampgradients
func (g *GPUParticleSystem) SetUseRampGradients(useRampGradients bool) *GPUParticleSystem {
	g.p.Set("useRampGradients", useRampGradients)
	return g
}

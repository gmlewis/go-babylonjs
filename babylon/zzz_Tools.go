// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// Tools represents a babylon.js Tools.
// Class containing a set of static utilities functions
type Tools struct {
	p   js.Value
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (t *Tools) JSObject() js.Value { return t.p }

// Tools returns a Tools JavaScript class.
func (ba *Babylon) Tools() *Tools {
	p := ba.ctx.Get("Tools")
	return ToolsFromJSObject(p, ba.ctx)
}

// ToolsFromJSObject returns a wrapped Tools JavaScript class.
func ToolsFromJSObject(p js.Value, ctx js.Value) *Tools {
	return &Tools{p: p, ctx: ctx}
}

// ToolsArrayToJSArray returns a JavaScript Array for the wrapped array.
func ToolsArrayToJSArray(array []*Tools) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// CleanUrl calls the CleanUrl method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#cleanurl
func (t *Tools) CleanUrl(url string) string {

	args := make([]interface{}, 0, 1+0)

	args = append(args, url)

	retVal := t.p.Call("CleanUrl", args...)
	return retVal.String()
}

// ClearLogCache calls the ClearLogCache method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#clearlogcache
func (t *Tools) ClearLogCache() {

	t.p.Call("ClearLogCache")
}

// ToolsCreateScreenshotOpts contains optional parameters for Tools.CreateScreenshot.
type ToolsCreateScreenshotOpts struct {
	SuccessCallback JSFunc
	MimeType        *string
}

// CreateScreenshot calls the CreateScreenshot method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#createscreenshot
func (t *Tools) CreateScreenshot(engine *Engine, camera *Camera, size *IScreenshotSize, opts *ToolsCreateScreenshotOpts) {
	if opts == nil {
		opts = &ToolsCreateScreenshotOpts{}
	}

	args := make([]interface{}, 0, 3+2)

	if engine == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, engine.JSObject())
	}

	if camera == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, camera.JSObject())
	}

	if size == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, size.JSObject())
	}

	if opts.SuccessCallback == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(opts.SuccessCallback) /* never freed! */)
	}
	if opts.MimeType == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MimeType)
	}

	t.p.Call("CreateScreenshot", args...)
}

// ToolsCreateScreenshotAsyncOpts contains optional parameters for Tools.CreateScreenshotAsync.
type ToolsCreateScreenshotAsyncOpts struct {
	MimeType *string
}

// CreateScreenshotAsync calls the CreateScreenshotAsync method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#createscreenshotasync
func (t *Tools) CreateScreenshotAsync(engine *Engine, camera *Camera, size *IScreenshotSize, opts *ToolsCreateScreenshotAsyncOpts) *Promise {
	if opts == nil {
		opts = &ToolsCreateScreenshotAsyncOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	if engine == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, engine.JSObject())
	}

	if camera == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, camera.JSObject())
	}

	if size == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, size.JSObject())
	}

	if opts.MimeType == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MimeType)
	}

	retVal := t.p.Call("CreateScreenshotAsync", args...)
	return PromiseFromJSObject(retVal, t.ctx)
}

// ToolsCreateScreenshotUsingRenderTargetOpts contains optional parameters for Tools.CreateScreenshotUsingRenderTarget.
type ToolsCreateScreenshotUsingRenderTargetOpts struct {
	SuccessCallback JSFunc
	MimeType        *string
	Samples         *float64
	Antialiasing    *bool
	FileName        *string
}

// CreateScreenshotUsingRenderTarget calls the CreateScreenshotUsingRenderTarget method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#createscreenshotusingrendertarget
func (t *Tools) CreateScreenshotUsingRenderTarget(engine *Engine, camera *Camera, size *IScreenshotSize, opts *ToolsCreateScreenshotUsingRenderTargetOpts) {
	if opts == nil {
		opts = &ToolsCreateScreenshotUsingRenderTargetOpts{}
	}

	args := make([]interface{}, 0, 3+5)

	if engine == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, engine.JSObject())
	}

	if camera == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, camera.JSObject())
	}

	if size == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, size.JSObject())
	}

	if opts.SuccessCallback == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(opts.SuccessCallback) /* never freed! */)
	}
	if opts.MimeType == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MimeType)
	}
	if opts.Samples == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Samples)
	}
	if opts.Antialiasing == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Antialiasing)
	}
	if opts.FileName == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FileName)
	}

	t.p.Call("CreateScreenshotUsingRenderTarget", args...)
}

// ToolsCreateScreenshotUsingRenderTargetAsyncOpts contains optional parameters for Tools.CreateScreenshotUsingRenderTargetAsync.
type ToolsCreateScreenshotUsingRenderTargetAsyncOpts struct {
	MimeType     *string
	Samples      *float64
	Antialiasing *bool
	FileName     *string
}

// CreateScreenshotUsingRenderTargetAsync calls the CreateScreenshotUsingRenderTargetAsync method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#createscreenshotusingrendertargetasync
func (t *Tools) CreateScreenshotUsingRenderTargetAsync(engine *Engine, camera *Camera, size *IScreenshotSize, opts *ToolsCreateScreenshotUsingRenderTargetAsyncOpts) *Promise {
	if opts == nil {
		opts = &ToolsCreateScreenshotUsingRenderTargetAsyncOpts{}
	}

	args := make([]interface{}, 0, 3+4)

	if engine == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, engine.JSObject())
	}

	if camera == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, camera.JSObject())
	}

	if size == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, size.JSObject())
	}

	if opts.MimeType == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MimeType)
	}
	if opts.Samples == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Samples)
	}
	if opts.Antialiasing == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Antialiasing)
	}
	if opts.FileName == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FileName)
	}

	retVal := t.p.Call("CreateScreenshotUsingRenderTargetAsync", args...)
	return PromiseFromJSObject(retVal, t.ctx)
}

// DecodeBase64 calls the DecodeBase64 method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#decodebase64
func (t *Tools) DecodeBase64(uri string) js.Value {

	args := make([]interface{}, 0, 1+0)

	args = append(args, uri)

	retVal := t.p.Call("DecodeBase64", args...)
	return retVal
}

// ToolsDeepCopyOpts contains optional parameters for Tools.DeepCopy.
type ToolsDeepCopyOpts struct {
	DoNotCopyList []string
	MustCopyList  []string
}

// DeepCopy calls the DeepCopy method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#deepcopy
func (t *Tools) DeepCopy(source JSObject, destination JSObject, opts *ToolsDeepCopyOpts) {
	if opts == nil {
		opts = &ToolsDeepCopyOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	if source == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, source.JSObject())
	}

	if destination == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, destination.JSObject())
	}

	if opts.DoNotCopyList == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.DoNotCopyList)
	}
	if opts.MustCopyList == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.MustCopyList)
	}

	t.p.Call("DeepCopy", args...)
}

// DelayAsync calls the DelayAsync method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#delayasync
func (t *Tools) DelayAsync(delay float64) *Promise {

	args := make([]interface{}, 0, 1+0)

	args = append(args, delay)

	retVal := t.p.Call("DelayAsync", args...)
	return PromiseFromJSObject(retVal, t.ctx)
}

// Download calls the Download method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#download
func (t *Tools) Download(blob js.Value, fileName string) {

	args := make([]interface{}, 0, 2+0)

	args = append(args, blob)

	args = append(args, fileName)

	t.p.Call("Download", args...)
}

// ToolsDumpFramebufferOpts contains optional parameters for Tools.DumpFramebuffer.
type ToolsDumpFramebufferOpts struct {
	SuccessCallback JSFunc
	MimeType        *string
	FileName        *string
}

// DumpFramebuffer calls the DumpFramebuffer method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#dumpframebuffer
func (t *Tools) DumpFramebuffer(width float64, height float64, engine *Engine, opts *ToolsDumpFramebufferOpts) {
	if opts == nil {
		opts = &ToolsDumpFramebufferOpts{}
	}

	args := make([]interface{}, 0, 3+3)

	args = append(args, width)

	args = append(args, height)

	if engine == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, engine.JSObject())
	}

	if opts.SuccessCallback == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(opts.SuccessCallback) /* never freed! */)
	}
	if opts.MimeType == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MimeType)
	}
	if opts.FileName == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FileName)
	}

	t.p.Call("DumpFramebuffer", args...)
}

// ToolsEncodeScreenshotCanvasDataOpts contains optional parameters for Tools.EncodeScreenshotCanvasData.
type ToolsEncodeScreenshotCanvasDataOpts struct {
	SuccessCallback JSFunc
	MimeType        *string
	FileName        *string
}

// EncodeScreenshotCanvasData calls the EncodeScreenshotCanvasData method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#encodescreenshotcanvasdata
func (t *Tools) EncodeScreenshotCanvasData(opts *ToolsEncodeScreenshotCanvasDataOpts) {
	if opts == nil {
		opts = &ToolsEncodeScreenshotCanvasDataOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.SuccessCallback == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(opts.SuccessCallback) /* never freed! */)
	}
	if opts.MimeType == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MimeType)
	}
	if opts.FileName == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FileName)
	}

	t.p.Call("EncodeScreenshotCanvasData", args...)
}

// Error calls the Error method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#error
func (t *Tools) Error(message string) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, message)

	t.p.Call("Error", args...)
}

// FetchToRef calls the FetchToRef method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#fetchtoref
func (t *Tools) FetchToRef(u float64, v float64, width float64, height float64, pixels js.Value, color js.Value) {

	args := make([]interface{}, 0, 6+0)

	args = append(args, u)

	args = append(args, v)

	args = append(args, width)

	args = append(args, height)

	args = append(args, pixels)

	args = append(args, color)

	t.p.Call("FetchToRef", args...)
}

// FileAsURL calls the FileAsURL method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#fileasurl
func (t *Tools) FileAsURL(content string) string {

	args := make([]interface{}, 0, 1+0)

	args = append(args, content)

	retVal := t.p.Call("FileAsURL", args...)
	return retVal.String()
}

// FloatRound calls the FloatRound method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#floatround
func (t *Tools) FloatRound(value float64) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, value)

	retVal := t.p.Call("FloatRound", args...)
	return retVal.Float()
}

// ToolsFormatOpts contains optional parameters for Tools.Format.
type ToolsFormatOpts struct {
	Decimals *float64
}

// Format calls the Format method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#format
func (t *Tools) Format(value float64, opts *ToolsFormatOpts) string {
	if opts == nil {
		opts = &ToolsFormatOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, value)

	if opts.Decimals == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Decimals)
	}

	retVal := t.p.Call("Format", args...)
	return retVal.String()
}

// GetAbsoluteUrl calls the GetAbsoluteUrl method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#getabsoluteurl
func (t *Tools) GetAbsoluteUrl(url string) string {

	args := make([]interface{}, 0, 1+0)

	args = append(args, url)

	retVal := t.p.Call("GetAbsoluteUrl", args...)
	return retVal.String()
}

// ToolsGetClassNameOpts contains optional parameters for Tools.GetClassName.
type ToolsGetClassNameOpts struct {
	IsType *bool
}

// GetClassName calls the GetClassName method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#getclassname
func (t *Tools) GetClassName(object JSObject, opts *ToolsGetClassNameOpts) string {
	if opts == nil {
		opts = &ToolsGetClassNameOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	if object == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, object.JSObject())
	}

	if opts.IsType == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IsType)
	}

	retVal := t.p.Call("GetClassName", args...)
	return retVal.String()
}

// GetFilename calls the GetFilename method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#getfilename
func (t *Tools) GetFilename(path string) string {

	args := make([]interface{}, 0, 1+0)

	args = append(args, path)

	retVal := t.p.Call("GetFilename", args...)
	return retVal.String()
}

// ToolsGetFolderPathOpts contains optional parameters for Tools.GetFolderPath.
type ToolsGetFolderPathOpts struct {
	ReturnUnchangedIfNoSlash *bool
}

// GetFolderPath calls the GetFolderPath method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#getfolderpath
func (t *Tools) GetFolderPath(uri string, opts *ToolsGetFolderPathOpts) string {
	if opts == nil {
		opts = &ToolsGetFolderPathOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, uri)

	if opts.ReturnUnchangedIfNoSlash == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ReturnUnchangedIfNoSlash)
	}

	retVal := t.p.Call("GetFolderPath", args...)
	return retVal.String()
}

// ToolsGetFullClassNameOpts contains optional parameters for Tools.GetFullClassName.
type ToolsGetFullClassNameOpts struct {
	IsType *bool
}

// GetFullClassName calls the GetFullClassName method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#getfullclassname
func (t *Tools) GetFullClassName(object JSObject, opts *ToolsGetFullClassNameOpts) string {
	if opts == nil {
		opts = &ToolsGetFullClassNameOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	if object == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, object.JSObject())
	}

	if opts.IsType == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IsType)
	}

	retVal := t.p.Call("getFullClassName", args...)
	return retVal.String()
}

// GetPointerPrefix calls the GetPointerPrefix method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#getpointerprefix
func (t *Tools) GetPointerPrefix() string {

	retVal := t.p.Call("GetPointerPrefix")
	return retVal.String()
}

// Instantiate calls the Instantiate method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#instantiate
func (t *Tools) Instantiate(className string) js.Value {

	args := make([]interface{}, 0, 1+0)

	args = append(args, className)

	retVal := t.p.Call("Instantiate", args...)
	return retVal
}

// IsBase64 calls the IsBase64 method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#isbase64
func (t *Tools) IsBase64(uri string) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, uri)

	retVal := t.p.Call("IsBase64", args...)
	return retVal.Bool()
}

// IsEmpty calls the IsEmpty method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#isempty
func (t *Tools) IsEmpty(obj JSObject) bool {

	args := make([]interface{}, 0, 1+0)

	if obj == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, obj.JSObject())
	}

	retVal := t.p.Call("IsEmpty", args...)
	return retVal.Bool()
}

// IsExponentOfTwo calls the IsExponentOfTwo method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#isexponentoftwo
func (t *Tools) IsExponentOfTwo(value float64) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, value)

	retVal := t.p.Call("IsExponentOfTwo", args...)
	return retVal.Bool()
}

// ToolsLoadFileOpts contains optional parameters for Tools.LoadFile.
type ToolsLoadFileOpts struct {
	OnProgress      JSFunc
	OfflineProvider *IOfflineProvider
	UseArrayBuffer  *bool
	OnError         JSFunc
}

// LoadFile calls the LoadFile method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#loadfile
func (t *Tools) LoadFile(url string, onSuccess JSFunc, opts *ToolsLoadFileOpts) *IFileRequest {
	if opts == nil {
		opts = &ToolsLoadFileOpts{}
	}

	args := make([]interface{}, 0, 2+4)

	args = append(args, url)

	args = append(args, js.FuncOf(onSuccess))

	if opts.OnProgress == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(opts.OnProgress) /* never freed! */)
	}
	if opts.OfflineProvider == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.OfflineProvider.JSObject())
	}
	if opts.UseArrayBuffer == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UseArrayBuffer)
	}
	if opts.OnError == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(opts.OnError) /* never freed! */)
	}

	retVal := t.p.Call("LoadFile", args...)
	return IFileRequestFromJSObject(retVal, t.ctx)
}

// LoadFileAsync calls the LoadFileAsync method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#loadfileasync
func (t *Tools) LoadFileAsync(url string) *Promise {

	args := make([]interface{}, 0, 1+0)

	args = append(args, url)

	retVal := t.p.Call("LoadFileAsync", args...)
	return PromiseFromJSObject(retVal, t.ctx)
}

// ToolsLoadImageOpts contains optional parameters for Tools.LoadImage.
type ToolsLoadImageOpts struct {
	MimeType *string
}

// LoadImage calls the LoadImage method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#loadimage
func (t *Tools) LoadImage(input string, onLoad JSFunc, onError JSFunc, offlineProvider *IOfflineProvider, opts *ToolsLoadImageOpts) js.Value {
	if opts == nil {
		opts = &ToolsLoadImageOpts{}
	}

	args := make([]interface{}, 0, 4+1)

	args = append(args, input)

	args = append(args, js.FuncOf(onLoad))

	args = append(args, js.FuncOf(onError))

	if offlineProvider == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, offlineProvider.JSObject())
	}

	if opts.MimeType == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MimeType)
	}

	retVal := t.p.Call("LoadImage", args...)
	return retVal
}

// ToolsLoadScriptOpts contains optional parameters for Tools.LoadScript.
type ToolsLoadScriptOpts struct {
	OnError  JSFunc
	ScriptId *string
}

// LoadScript calls the LoadScript method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#loadscript
func (t *Tools) LoadScript(scriptUrl string, onSuccess JSFunc, opts *ToolsLoadScriptOpts) {
	if opts == nil {
		opts = &ToolsLoadScriptOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, scriptUrl)

	args = append(args, js.FuncOf(onSuccess))

	if opts.OnError == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(opts.OnError) /* never freed! */)
	}
	if opts.ScriptId == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ScriptId)
	}

	t.p.Call("LoadScript", args...)
}

// ToolsLoadScriptAsyncOpts contains optional parameters for Tools.LoadScriptAsync.
type ToolsLoadScriptAsyncOpts struct {
	ScriptId *string
}

// LoadScriptAsync calls the LoadScriptAsync method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#loadscriptasync
func (t *Tools) LoadScriptAsync(scriptUrl string, opts *ToolsLoadScriptAsyncOpts) *Promise {
	if opts == nil {
		opts = &ToolsLoadScriptAsyncOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, scriptUrl)

	if opts.ScriptId == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ScriptId)
	}

	retVal := t.p.Call("LoadScriptAsync", args...)
	return PromiseFromJSObject(retVal, t.ctx)
}

// Log calls the Log method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#log
func (t *Tools) Log(message string) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, message)

	t.p.Call("Log", args...)
}

// ToolsMakeArrayOpts contains optional parameters for Tools.MakeArray.
type ToolsMakeArrayOpts struct {
	AllowsNullUndefined *bool
}

// MakeArray calls the MakeArray method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#makearray
func (t *Tools) MakeArray(obj JSObject, opts *ToolsMakeArrayOpts) js.Value {
	if opts == nil {
		opts = &ToolsMakeArrayOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	if obj == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, obj.JSObject())
	}

	if opts.AllowsNullUndefined == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AllowsNullUndefined)
	}

	retVal := t.p.Call("MakeArray", args...)
	return retVal
}

// Mix calls the Mix method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#mix
func (t *Tools) Mix(a float64, b float64, alpha float64) float64 {

	args := make([]interface{}, 0, 3+0)

	args = append(args, a)

	args = append(args, b)

	args = append(args, alpha)

	retVal := t.p.Call("Mix", args...)
	return retVal.Float()
}

// RandomId calls the RandomId method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#randomid
func (t *Tools) RandomId() string {

	retVal := t.p.Call("RandomId")
	return retVal.String()
}

// ToolsReadFileOpts contains optional parameters for Tools.ReadFile.
type ToolsReadFileOpts struct {
	OnProgress     JSFunc
	UseArrayBuffer *bool
	OnError        JSFunc
}

// ReadFile calls the ReadFile method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#readfile
func (t *Tools) ReadFile(file js.Value, onSuccess JSFunc, opts *ToolsReadFileOpts) *IFileRequest {
	if opts == nil {
		opts = &ToolsReadFileOpts{}
	}

	args := make([]interface{}, 0, 2+3)

	args = append(args, file)

	args = append(args, js.FuncOf(onSuccess))

	if opts.OnProgress == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(opts.OnProgress) /* never freed! */)
	}
	if opts.UseArrayBuffer == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UseArrayBuffer)
	}
	if opts.OnError == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(opts.OnError) /* never freed! */)
	}

	retVal := t.p.Call("ReadFile", args...)
	return IFileRequestFromJSObject(retVal, t.ctx)
}

// ReadFileAsDataURL calls the ReadFileAsDataURL method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#readfileasdataurl
func (t *Tools) ReadFileAsDataURL(fileToLoad js.Value, callback JSFunc, progressCallback JSFunc) *IFileRequest {

	args := make([]interface{}, 0, 3+0)

	args = append(args, fileToLoad)

	args = append(args, js.FuncOf(callback))

	args = append(args, js.FuncOf(progressCallback))

	retVal := t.p.Call("ReadFileAsDataURL", args...)
	return IFileRequestFromJSObject(retVal, t.ctx)
}

// RegisterTopRootEvents calls the RegisterTopRootEvents method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#registertoprootevents
func (t *Tools) RegisterTopRootEvents(windowElement js.Value, events js.Value) {

	args := make([]interface{}, 0, 2+0)

	args = append(args, windowElement)

	args = append(args, events)

	t.p.Call("RegisterTopRootEvents", args...)
}

// SetCorsBehavior calls the SetCorsBehavior method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#setcorsbehavior
func (t *Tools) SetCorsBehavior(url []string, element js.Value) {

	args := make([]interface{}, 0, 2+0)

	args = append(args, url)

	args = append(args, element)

	t.p.Call("SetCorsBehavior", args...)
}

// SetImmediate calls the SetImmediate method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#setimmediate
func (t *Tools) SetImmediate(action JSFunc) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(action))

	t.p.Call("SetImmediate", args...)
}

// ToolsToBlobOpts contains optional parameters for Tools.ToBlob.
type ToolsToBlobOpts struct {
	MimeType *string
}

// ToBlob calls the ToBlob method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#toblob
func (t *Tools) ToBlob(canvas js.Value, successCallback JSFunc, opts *ToolsToBlobOpts) {
	if opts == nil {
		opts = &ToolsToBlobOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, canvas)

	args = append(args, js.FuncOf(successCallback))

	if opts.MimeType == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MimeType)
	}

	t.p.Call("ToBlob", args...)
}

// ToDegrees calls the ToDegrees method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#todegrees
func (t *Tools) ToDegrees(angle float64) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, angle)

	retVal := t.p.Call("ToDegrees", args...)
	return retVal.Float()
}

// ToRadians calls the ToRadians method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#toradians
func (t *Tools) ToRadians(angle float64) float64 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, angle)

	retVal := t.p.Call("ToRadians", args...)
	return retVal.Float()
}

// UnregisterTopRootEvents calls the UnregisterTopRootEvents method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#unregistertoprootevents
func (t *Tools) UnregisterTopRootEvents(windowElement js.Value, events js.Value) {

	args := make([]interface{}, 0, 2+0)

	args = append(args, windowElement)

	args = append(args, events)

	t.p.Call("UnregisterTopRootEvents", args...)
}

// Warn calls the Warn method on the Tools object.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#warn
func (t *Tools) Warn(message string) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, message)

	t.p.Call("Warn", args...)
}

// AllLogLevel returns the AllLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#allloglevel
func (t *Tools) AllLogLevel() float64 {
	retVal := t.p.Get("AllLogLevel")
	return retVal.Float()
}

// SetAllLogLevel sets the AllLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#allloglevel
func (t *Tools) SetAllLogLevel(AllLogLevel float64) *Tools {
	t.p.Set("AllLogLevel", AllLogLevel)
	return t
}

// BaseUrl returns the BaseUrl property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#baseurl
func (t *Tools) BaseUrl() string {
	retVal := t.p.Get("BaseUrl")
	return retVal.String()
}

// SetBaseUrl sets the BaseUrl property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#baseurl
func (t *Tools) SetBaseUrl(BaseUrl string) *Tools {
	t.p.Set("BaseUrl", BaseUrl)
	return t
}

// CorsBehavior returns the CorsBehavior property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#corsbehavior
func (t *Tools) CorsBehavior() string {
	retVal := t.p.Get("CorsBehavior")
	return retVal.String()
}

// CustomRequestHeaders returns the CustomRequestHeaders property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#customrequestheaders
func (t *Tools) CustomRequestHeaders() js.Value {
	retVal := t.p.Get("CustomRequestHeaders")
	return retVal
}

// SetCustomRequestHeaders sets the CustomRequestHeaders property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#customrequestheaders
func (t *Tools) SetCustomRequestHeaders(CustomRequestHeaders js.Value) *Tools {
	t.p.Set("CustomRequestHeaders", CustomRequestHeaders)
	return t
}

// DefaultRetryStrategy returns the DefaultRetryStrategy property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#defaultretrystrategy
func (t *Tools) DefaultRetryStrategy() js.Value {
	retVal := t.p.Get("DefaultRetryStrategy")
	return retVal
}

// SetDefaultRetryStrategy sets the DefaultRetryStrategy property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#defaultretrystrategy
func (t *Tools) SetDefaultRetryStrategy(DefaultRetryStrategy JSFunc) *Tools {
	t.p.Set("DefaultRetryStrategy", js.FuncOf(DefaultRetryStrategy))
	return t
}

// EndPerformanceCounter returns the EndPerformanceCounter property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#endperformancecounter
func (t *Tools) EndPerformanceCounter() js.Value {
	retVal := t.p.Get("EndPerformanceCounter")
	return retVal
}

// SetEndPerformanceCounter sets the EndPerformanceCounter property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#endperformancecounter
func (t *Tools) SetEndPerformanceCounter(EndPerformanceCounter JSFunc) *Tools {
	t.p.Set("EndPerformanceCounter", js.FuncOf(EndPerformanceCounter))
	return t
}

// ErrorLogLevel returns the ErrorLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#errorloglevel
func (t *Tools) ErrorLogLevel() float64 {
	retVal := t.p.Get("ErrorLogLevel")
	return retVal.Float()
}

// SetErrorLogLevel sets the ErrorLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#errorloglevel
func (t *Tools) SetErrorLogLevel(ErrorLogLevel float64) *Tools {
	t.p.Set("ErrorLogLevel", ErrorLogLevel)
	return t
}

// ErrorsCount returns the ErrorsCount property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#errorscount
func (t *Tools) ErrorsCount() float64 {
	retVal := t.p.Get("errorsCount")
	return retVal.Float()
}

// SetErrorsCount sets the ErrorsCount property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#errorscount
func (t *Tools) SetErrorsCount(errorsCount float64) *Tools {
	t.p.Set("errorsCount", errorsCount)
	return t
}

// FallbackTexture returns the FallbackTexture property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#fallbacktexture
func (t *Tools) FallbackTexture() string {
	retVal := t.p.Get("fallbackTexture")
	return retVal.String()
}

// SetFallbackTexture sets the FallbackTexture property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#fallbacktexture
func (t *Tools) SetFallbackTexture(fallbackTexture string) *Tools {
	t.p.Set("fallbackTexture", fallbackTexture)
	return t
}

// GetDOMTextContent returns the GetDOMTextContent property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#getdomtextcontent
func (t *Tools) GetDOMTextContent() js.Value {
	retVal := t.p.Get("GetDOMTextContent")
	return retVal
}

// SetGetDOMTextContent sets the GetDOMTextContent property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#getdomtextcontent
func (t *Tools) SetGetDOMTextContent(GetDOMTextContent js.Value) *Tools {
	t.p.Set("GetDOMTextContent", GetDOMTextContent)
	return t
}

// IsWindowObjectExist returns the IsWindowObjectExist property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#iswindowobjectexist
func (t *Tools) IsWindowObjectExist() js.Value {
	retVal := t.p.Get("IsWindowObjectExist")
	return retVal
}

// SetIsWindowObjectExist sets the IsWindowObjectExist property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#iswindowobjectexist
func (t *Tools) SetIsWindowObjectExist(IsWindowObjectExist js.Value) *Tools {
	t.p.Set("IsWindowObjectExist", IsWindowObjectExist)
	return t
}

// LogCache returns the LogCache property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#logcache
func (t *Tools) LogCache() string {
	retVal := t.p.Get("LogCache")
	return retVal.String()
}

// SetLogCache sets the LogCache property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#logcache
func (t *Tools) SetLogCache(LogCache string) *Tools {
	t.p.Set("LogCache", LogCache)
	return t
}

// LogLevels returns the LogLevels property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#loglevels
func (t *Tools) LogLevels() float64 {
	retVal := t.p.Get("LogLevels")
	return retVal.Float()
}

// SetLogLevels sets the LogLevels property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#loglevels
func (t *Tools) SetLogLevels(LogLevels float64) *Tools {
	t.p.Set("LogLevels", LogLevels)
	return t
}

// MessageLogLevel returns the MessageLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#messageloglevel
func (t *Tools) MessageLogLevel() float64 {
	retVal := t.p.Get("MessageLogLevel")
	return retVal.Float()
}

// SetMessageLogLevel sets the MessageLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#messageloglevel
func (t *Tools) SetMessageLogLevel(MessageLogLevel float64) *Tools {
	t.p.Set("MessageLogLevel", MessageLogLevel)
	return t
}

// NoneLogLevel returns the NoneLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#noneloglevel
func (t *Tools) NoneLogLevel() float64 {
	retVal := t.p.Get("NoneLogLevel")
	return retVal.Float()
}

// SetNoneLogLevel sets the NoneLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#noneloglevel
func (t *Tools) SetNoneLogLevel(NoneLogLevel float64) *Tools {
	t.p.Set("NoneLogLevel", NoneLogLevel)
	return t
}

// Now returns the Now property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#now
func (t *Tools) Now() float64 {
	retVal := t.p.Get("Now")
	return retVal.Float()
}

// SetNow sets the Now property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#now
func (t *Tools) SetNow(Now float64) *Tools {
	t.p.Set("Now", Now)
	return t
}

// OnNewCacheEntry returns the OnNewCacheEntry property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#onnewcacheentry
func (t *Tools) OnNewCacheEntry() js.Value {
	retVal := t.p.Get("OnNewCacheEntry")
	return retVal
}

// SetOnNewCacheEntry sets the OnNewCacheEntry property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#onnewcacheentry
func (t *Tools) SetOnNewCacheEntry(OnNewCacheEntry JSFunc) *Tools {
	t.p.Set("OnNewCacheEntry", js.FuncOf(OnNewCacheEntry))
	return t
}

// PerformanceConsoleLogLevel returns the PerformanceConsoleLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#performanceconsoleloglevel
func (t *Tools) PerformanceConsoleLogLevel() float64 {
	retVal := t.p.Get("PerformanceConsoleLogLevel")
	return retVal.Float()
}

// SetPerformanceConsoleLogLevel sets the PerformanceConsoleLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#performanceconsoleloglevel
func (t *Tools) SetPerformanceConsoleLogLevel(PerformanceConsoleLogLevel float64) *Tools {
	t.p.Set("PerformanceConsoleLogLevel", PerformanceConsoleLogLevel)
	return t
}

// PerformanceLogLevel returns the PerformanceLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#performanceloglevel
func (t *Tools) PerformanceLogLevel() float64 {
	retVal := t.p.Get("PerformanceLogLevel")
	return retVal.Float()
}

// SetPerformanceLogLevel sets the PerformanceLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#performanceloglevel
func (t *Tools) SetPerformanceLogLevel(PerformanceLogLevel float64) *Tools {
	t.p.Set("PerformanceLogLevel", PerformanceLogLevel)
	return t
}

// PerformanceNoneLogLevel returns the PerformanceNoneLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#performancenoneloglevel
func (t *Tools) PerformanceNoneLogLevel() float64 {
	retVal := t.p.Get("PerformanceNoneLogLevel")
	return retVal.Float()
}

// SetPerformanceNoneLogLevel sets the PerformanceNoneLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#performancenoneloglevel
func (t *Tools) SetPerformanceNoneLogLevel(PerformanceNoneLogLevel float64) *Tools {
	t.p.Set("PerformanceNoneLogLevel", PerformanceNoneLogLevel)
	return t
}

// PerformanceUserMarkLogLevel returns the PerformanceUserMarkLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#performanceusermarkloglevel
func (t *Tools) PerformanceUserMarkLogLevel() float64 {
	retVal := t.p.Get("PerformanceUserMarkLogLevel")
	return retVal.Float()
}

// SetPerformanceUserMarkLogLevel sets the PerformanceUserMarkLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#performanceusermarkloglevel
func (t *Tools) SetPerformanceUserMarkLogLevel(PerformanceUserMarkLogLevel float64) *Tools {
	t.p.Set("PerformanceUserMarkLogLevel", PerformanceUserMarkLogLevel)
	return t
}

// PreprocessUrl returns the PreprocessUrl property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#preprocessurl
func (t *Tools) PreprocessUrl() js.Value {
	retVal := t.p.Get("PreprocessUrl")
	return retVal
}

// SetPreprocessUrl sets the PreprocessUrl property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#preprocessurl
func (t *Tools) SetPreprocessUrl(PreprocessUrl JSFunc) *Tools {
	t.p.Set("PreprocessUrl", js.FuncOf(PreprocessUrl))
	return t
}

// RegisteredExternalClasses returns the RegisteredExternalClasses property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#registeredexternalclasses
func (t *Tools) RegisteredExternalClasses() js.Value {
	retVal := t.p.Get("RegisteredExternalClasses")
	return retVal
}

// SetRegisteredExternalClasses sets the RegisteredExternalClasses property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#registeredexternalclasses
func (t *Tools) SetRegisteredExternalClasses(RegisteredExternalClasses js.Value) *Tools {
	t.p.Set("RegisteredExternalClasses", RegisteredExternalClasses)
	return t
}

// StartPerformanceCounter returns the StartPerformanceCounter property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#startperformancecounter
func (t *Tools) StartPerformanceCounter() js.Value {
	retVal := t.p.Get("StartPerformanceCounter")
	return retVal
}

// SetStartPerformanceCounter sets the StartPerformanceCounter property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#startperformancecounter
func (t *Tools) SetStartPerformanceCounter(StartPerformanceCounter JSFunc) *Tools {
	t.p.Set("StartPerformanceCounter", js.FuncOf(StartPerformanceCounter))
	return t
}

// UseCustomRequestHeaders returns the UseCustomRequestHeaders property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#usecustomrequestheaders
func (t *Tools) UseCustomRequestHeaders() bool {
	retVal := t.p.Get("UseCustomRequestHeaders")
	return retVal.Bool()
}

// SetUseCustomRequestHeaders sets the UseCustomRequestHeaders property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#usecustomrequestheaders
func (t *Tools) SetUseCustomRequestHeaders(UseCustomRequestHeaders bool) *Tools {
	t.p.Set("UseCustomRequestHeaders", UseCustomRequestHeaders)
	return t
}

// UseFallbackTexture returns the UseFallbackTexture property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#usefallbacktexture
func (t *Tools) UseFallbackTexture() bool {
	retVal := t.p.Get("UseFallbackTexture")
	return retVal.Bool()
}

// SetUseFallbackTexture sets the UseFallbackTexture property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#usefallbacktexture
func (t *Tools) SetUseFallbackTexture(UseFallbackTexture bool) *Tools {
	t.p.Set("UseFallbackTexture", UseFallbackTexture)
	return t
}

// WarningLogLevel returns the WarningLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#warningloglevel
func (t *Tools) WarningLogLevel() float64 {
	retVal := t.p.Get("WarningLogLevel")
	return retVal.Float()
}

// SetWarningLogLevel sets the WarningLogLevel property of class Tools.
//
// https://doc.babylonjs.com/api/classes/babylon.tools#warningloglevel
func (t *Tools) SetWarningLogLevel(WarningLogLevel float64) *Tools {
	t.p.Set("WarningLogLevel", WarningLogLevel)
	return t
}

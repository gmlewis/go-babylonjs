// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// InputManager represents a babylon.js InputManager.
// Class used to manage all inputs for the scene.
type InputManager struct {
	p   js.Value
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (i *InputManager) JSObject() js.Value { return i.p }

// InputManager returns a InputManager JavaScript class.
func (ba *Babylon) InputManager() *InputManager {
	p := ba.ctx.Get("InputManager")
	return InputManagerFromJSObject(p, ba.ctx)
}

// InputManagerFromJSObject returns a wrapped InputManager JavaScript class.
func InputManagerFromJSObject(p js.Value, ctx js.Value) *InputManager {
	return &InputManager{p: p, ctx: ctx}
}

// InputManagerArrayToJSArray returns a JavaScript Array for the wrapped array.
func InputManagerArrayToJSArray(array []*InputManager) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewInputManager returns a new InputManager object.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager
func (ba *Babylon) NewInputManager(scene *Scene) *InputManager {

	args := make([]interface{}, 0, 1+0)

	args = append(args, scene.JSObject())

	p := ba.ctx.Get("InputManager").New(args...)
	return InputManagerFromJSObject(p, ba.ctx)
}

// InputManagerAttachControlOpts contains optional parameters for InputManager.AttachControl.
type InputManagerAttachControlOpts struct {
	AttachUp   *bool
	AttachDown *bool
	AttachMove *bool
}

// AttachControl calls the AttachControl method on the InputManager object.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#attachcontrol
func (i *InputManager) AttachControl(opts *InputManagerAttachControlOpts) {
	if opts == nil {
		opts = &InputManagerAttachControlOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.AttachUp == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AttachUp)
	}
	if opts.AttachDown == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AttachDown)
	}
	if opts.AttachMove == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AttachMove)
	}

	i.p.Call("attachControl", args...)
}

// DetachControl calls the DetachControl method on the InputManager object.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#detachcontrol
func (i *InputManager) DetachControl() {

	i.p.Call("detachControl")
}

// GetPointerOverMesh calls the GetPointerOverMesh method on the InputManager object.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#getpointerovermesh
func (i *InputManager) GetPointerOverMesh() *AbstractMesh {

	retVal := i.p.Call("getPointerOverMesh")
	return AbstractMeshFromJSObject(retVal, i.ctx)
}

// InputManagerIsPointerCapturedOpts contains optional parameters for InputManager.IsPointerCaptured.
type InputManagerIsPointerCapturedOpts struct {
	PointerId *float64
}

// IsPointerCaptured calls the IsPointerCaptured method on the InputManager object.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#ispointercaptured
func (i *InputManager) IsPointerCaptured(opts *InputManagerIsPointerCapturedOpts) bool {
	if opts == nil {
		opts = &InputManagerIsPointerCapturedOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.PointerId == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.PointerId)
	}

	retVal := i.p.Call("isPointerCaptured", args...)
	return retVal.Bool()
}

// SetPointerOverMesh calls the SetPointerOverMesh method on the InputManager object.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#setpointerovermesh
func (i *InputManager) SetPointerOverMesh(mesh *AbstractMesh) {

	args := make([]interface{}, 0, 1+0)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	i.p.Call("setPointerOverMesh", args...)
}

// InputManagerSimulatePointerDownOpts contains optional parameters for InputManager.SimulatePointerDown.
type InputManagerSimulatePointerDownOpts struct {
	PointerEventInit js.Value
}

// SimulatePointerDown calls the SimulatePointerDown method on the InputManager object.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#simulatepointerdown
func (i *InputManager) SimulatePointerDown(pickResult *PickingInfo, opts *InputManagerSimulatePointerDownOpts) {
	if opts == nil {
		opts = &InputManagerSimulatePointerDownOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	if pickResult == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, pickResult.JSObject())
	}

	args = append(args, opts.PointerEventInit)

	i.p.Call("simulatePointerDown", args...)
}

// InputManagerSimulatePointerMoveOpts contains optional parameters for InputManager.SimulatePointerMove.
type InputManagerSimulatePointerMoveOpts struct {
	PointerEventInit js.Value
}

// SimulatePointerMove calls the SimulatePointerMove method on the InputManager object.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#simulatepointermove
func (i *InputManager) SimulatePointerMove(pickResult *PickingInfo, opts *InputManagerSimulatePointerMoveOpts) {
	if opts == nil {
		opts = &InputManagerSimulatePointerMoveOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	if pickResult == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, pickResult.JSObject())
	}

	args = append(args, opts.PointerEventInit)

	i.p.Call("simulatePointerMove", args...)
}

// InputManagerSimulatePointerUpOpts contains optional parameters for InputManager.SimulatePointerUp.
type InputManagerSimulatePointerUpOpts struct {
	PointerEventInit js.Value
	DoubleTap        *bool
}

// SimulatePointerUp calls the SimulatePointerUp method on the InputManager object.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#simulatepointerup
func (i *InputManager) SimulatePointerUp(pickResult *PickingInfo, opts *InputManagerSimulatePointerUpOpts) {
	if opts == nil {
		opts = &InputManagerSimulatePointerUpOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	if pickResult == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, pickResult.JSObject())
	}

	args = append(args, opts.PointerEventInit)
	if opts.DoubleTap == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoubleTap)
	}

	i.p.Call("simulatePointerUp", args...)
}

// DoubleClickDelay returns the DoubleClickDelay property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#doubleclickdelay
func (i *InputManager) DoubleClickDelay() float64 {
	retVal := i.p.Get("DoubleClickDelay")
	return retVal.Float()
}

// SetDoubleClickDelay sets the DoubleClickDelay property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#doubleclickdelay
func (i *InputManager) SetDoubleClickDelay(DoubleClickDelay float64) *InputManager {
	i.p.Set("DoubleClickDelay", DoubleClickDelay)
	return i
}

// DragMovementThreshold returns the DragMovementThreshold property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#dragmovementthreshold
func (i *InputManager) DragMovementThreshold() float64 {
	retVal := i.p.Get("DragMovementThreshold")
	return retVal.Float()
}

// SetDragMovementThreshold sets the DragMovementThreshold property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#dragmovementthreshold
func (i *InputManager) SetDragMovementThreshold(DragMovementThreshold float64) *InputManager {
	i.p.Set("DragMovementThreshold", DragMovementThreshold)
	return i
}

// ExclusiveDoubleClickMode returns the ExclusiveDoubleClickMode property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#exclusivedoubleclickmode
func (i *InputManager) ExclusiveDoubleClickMode() bool {
	retVal := i.p.Get("ExclusiveDoubleClickMode")
	return retVal.Bool()
}

// SetExclusiveDoubleClickMode sets the ExclusiveDoubleClickMode property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#exclusivedoubleclickmode
func (i *InputManager) SetExclusiveDoubleClickMode(ExclusiveDoubleClickMode bool) *InputManager {
	i.p.Set("ExclusiveDoubleClickMode", ExclusiveDoubleClickMode)
	return i
}

// LongPressDelay returns the LongPressDelay property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#longpressdelay
func (i *InputManager) LongPressDelay() float64 {
	retVal := i.p.Get("LongPressDelay")
	return retVal.Float()
}

// SetLongPressDelay sets the LongPressDelay property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#longpressdelay
func (i *InputManager) SetLongPressDelay(LongPressDelay float64) *InputManager {
	i.p.Set("LongPressDelay", LongPressDelay)
	return i
}

// MeshUnderPointer returns the MeshUnderPointer property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#meshunderpointer
func (i *InputManager) MeshUnderPointer() *AbstractMesh {
	retVal := i.p.Get("meshUnderPointer")
	return AbstractMeshFromJSObject(retVal, i.ctx)
}

// SetMeshUnderPointer sets the MeshUnderPointer property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#meshunderpointer
func (i *InputManager) SetMeshUnderPointer(meshUnderPointer *AbstractMesh) *InputManager {
	i.p.Set("meshUnderPointer", meshUnderPointer.JSObject())
	return i
}

// PointerX returns the PointerX property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#pointerx
func (i *InputManager) PointerX() float64 {
	retVal := i.p.Get("pointerX")
	return retVal.Float()
}

// SetPointerX sets the PointerX property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#pointerx
func (i *InputManager) SetPointerX(pointerX float64) *InputManager {
	i.p.Set("pointerX", pointerX)
	return i
}

// PointerY returns the PointerY property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#pointery
func (i *InputManager) PointerY() float64 {
	retVal := i.p.Get("pointerY")
	return retVal.Float()
}

// SetPointerY sets the PointerY property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#pointery
func (i *InputManager) SetPointerY(pointerY float64) *InputManager {
	i.p.Set("pointerY", pointerY)
	return i
}

// UnTranslatedPointer returns the UnTranslatedPointer property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#untranslatedpointer
func (i *InputManager) UnTranslatedPointer() *Vector2 {
	retVal := i.p.Get("unTranslatedPointer")
	return Vector2FromJSObject(retVal, i.ctx)
}

// SetUnTranslatedPointer sets the UnTranslatedPointer property of class InputManager.
//
// https://doc.babylonjs.com/api/classes/babylon.inputmanager#untranslatedpointer
func (i *InputManager) SetUnTranslatedPointer(unTranslatedPointer *Vector2) *InputManager {
	i.p.Set("unTranslatedPointer", unTranslatedPointer.JSObject())
	return i
}

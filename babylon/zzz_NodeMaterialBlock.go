// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// NodeMaterialBlock represents a babylon.js NodeMaterialBlock.
// Defines a block that can be used inside a node based material
type NodeMaterialBlock struct {
	p   js.Value
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (n *NodeMaterialBlock) JSObject() js.Value { return n.p }

// NodeMaterialBlock returns a NodeMaterialBlock JavaScript class.
func (ba *Babylon) NodeMaterialBlock() *NodeMaterialBlock {
	p := ba.ctx.Get("NodeMaterialBlock")
	return NodeMaterialBlockFromJSObject(p, ba.ctx)
}

// NodeMaterialBlockFromJSObject returns a wrapped NodeMaterialBlock JavaScript class.
func NodeMaterialBlockFromJSObject(p js.Value, ctx js.Value) *NodeMaterialBlock {
	return &NodeMaterialBlock{p: p, ctx: ctx}
}

// NodeMaterialBlockArrayToJSArray returns a JavaScript Array for the wrapped array.
func NodeMaterialBlockArrayToJSArray(array []*NodeMaterialBlock) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewNodeMaterialBlockOpts contains optional parameters for NewNodeMaterialBlock.
type NewNodeMaterialBlockOpts struct {
	Target        js.Value
	IsFinalMerger *bool
	IsInput       *bool
}

// NewNodeMaterialBlock returns a new NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#constructor
func (ba *Babylon) NewNodeMaterialBlock(name string, opts *NewNodeMaterialBlockOpts) *NodeMaterialBlock {
	if opts == nil {
		opts = &NewNodeMaterialBlockOpts{}
	}

	args := make([]interface{}, 0, 1+3)

	args = append(args, name)

	args = append(args, opts.Target)
	if opts.IsFinalMerger == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IsFinalMerger)
	}
	if opts.IsInput == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IsInput)
	}

	p := ba.ctx.Get("NodeMaterialBlock").New(args...)
	return NodeMaterialBlockFromJSObject(p, ba.ctx)
}

// AutoConfigure calls the AutoConfigure method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#autoconfigure
func (n *NodeMaterialBlock) AutoConfigure(material *NodeMaterial) {

	args := make([]interface{}, 0, 1+0)

	if material == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, material.JSObject())
	}

	n.p.Call("autoConfigure", args...)
}

// NodeMaterialBlockBindOpts contains optional parameters for NodeMaterialBlock.Bind.
type NodeMaterialBlockBindOpts struct {
	Mesh *Mesh
}

// Bind calls the Bind method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#bind
func (n *NodeMaterialBlock) Bind(effect *Effect, nodeMaterial *NodeMaterial, opts *NodeMaterialBlockBindOpts) {
	if opts == nil {
		opts = &NodeMaterialBlockBindOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	if effect == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, effect.JSObject())
	}

	if nodeMaterial == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, nodeMaterial.JSObject())
	}

	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	n.p.Call("bind", args...)
}

// Build calls the Build method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#build
func (n *NodeMaterialBlock) Build(state *NodeMaterialBuildState, activeBlocks []*NodeMaterialBlock) bool {

	args := make([]interface{}, 0, 2+0)

	if state == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, state.JSObject())
	}

	args = append(args, NodeMaterialBlockArrayToJSArray(activeBlocks))

	retVal := n.p.Call("build", args...)
	return retVal.Bool()
}

// NodeMaterialBlockCloneOpts contains optional parameters for NodeMaterialBlock.Clone.
type NodeMaterialBlockCloneOpts struct {
	RootUrl *string
}

// Clone calls the Clone method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#clone
func (n *NodeMaterialBlock) Clone(scene *Scene, opts *NodeMaterialBlockCloneOpts) *NodeMaterialBlock {
	if opts == nil {
		opts = &NodeMaterialBlockCloneOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	if scene == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, scene.JSObject())
	}

	if opts.RootUrl == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.RootUrl)
	}

	retVal := n.p.Call("clone", args...)
	return NodeMaterialBlockFromJSObject(retVal, n.ctx)
}

// NodeMaterialBlockConnectToOpts contains optional parameters for NodeMaterialBlock.ConnectTo.
type NodeMaterialBlockConnectToOpts struct {
	Options map[string]interface{}
}

// ConnectTo calls the ConnectTo method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#connectto
func (n *NodeMaterialBlock) ConnectTo(other *NodeMaterialBlock, opts *NodeMaterialBlockConnectToOpts) *NodeMaterialBlock {
	if opts == nil {
		opts = &NodeMaterialBlockConnectToOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	if other == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, other.JSObject())
	}

	if opts.Options == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Options)
	}

	retVal := n.p.Call("connectTo", args...)
	return NodeMaterialBlockFromJSObject(retVal, n.ctx)
}

// Dispose calls the Dispose method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#dispose
func (n *NodeMaterialBlock) Dispose() {

	n.p.Call("dispose")
}

// GetClassName calls the GetClassName method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#getclassname
func (n *NodeMaterialBlock) GetClassName() string {

	retVal := n.p.Call("getClassName")
	return retVal.String()
}

// NodeMaterialBlockGetFirstAvailableInputOpts contains optional parameters for NodeMaterialBlock.GetFirstAvailableInput.
type NodeMaterialBlockGetFirstAvailableInputOpts struct {
	ForOutput *NodeMaterialConnectionPoint
}

// GetFirstAvailableInput calls the GetFirstAvailableInput method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#getfirstavailableinput
func (n *NodeMaterialBlock) GetFirstAvailableInput(opts *NodeMaterialBlockGetFirstAvailableInputOpts) *NodeMaterialConnectionPoint {
	if opts == nil {
		opts = &NodeMaterialBlockGetFirstAvailableInputOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.ForOutput == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.ForOutput.JSObject())
	}

	retVal := n.p.Call("getFirstAvailableInput", args...)
	return NodeMaterialConnectionPointFromJSObject(retVal, n.ctx)
}

// NodeMaterialBlockGetFirstAvailableOutputOpts contains optional parameters for NodeMaterialBlock.GetFirstAvailableOutput.
type NodeMaterialBlockGetFirstAvailableOutputOpts struct {
	ForBlock *NodeMaterialBlock
}

// GetFirstAvailableOutput calls the GetFirstAvailableOutput method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#getfirstavailableoutput
func (n *NodeMaterialBlock) GetFirstAvailableOutput(opts *NodeMaterialBlockGetFirstAvailableOutputOpts) *NodeMaterialConnectionPoint {
	if opts == nil {
		opts = &NodeMaterialBlockGetFirstAvailableOutputOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.ForBlock == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.ForBlock.JSObject())
	}

	retVal := n.p.Call("getFirstAvailableOutput", args...)
	return NodeMaterialConnectionPointFromJSObject(retVal, n.ctx)
}

// GetInputByName calls the GetInputByName method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#getinputbyname
func (n *NodeMaterialBlock) GetInputByName(name string) *NodeMaterialConnectionPoint {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := n.p.Call("getInputByName", args...)
	return NodeMaterialConnectionPointFromJSObject(retVal, n.ctx)
}

// GetOutputByName calls the GetOutputByName method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#getoutputbyname
func (n *NodeMaterialBlock) GetOutputByName(name string) *NodeMaterialConnectionPoint {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := n.p.Call("getOutputByName", args...)
	return NodeMaterialConnectionPointFromJSObject(retVal, n.ctx)
}

// GetSiblingOutput calls the GetSiblingOutput method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#getsiblingoutput
func (n *NodeMaterialBlock) GetSiblingOutput(current *NodeMaterialConnectionPoint) *NodeMaterialConnectionPoint {

	args := make([]interface{}, 0, 1+0)

	if current == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, current.JSObject())
	}

	retVal := n.p.Call("getSiblingOutput", args...)
	return NodeMaterialConnectionPointFromJSObject(retVal, n.ctx)
}

// Initialize calls the Initialize method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#initialize
func (n *NodeMaterialBlock) Initialize(state *NodeMaterialBuildState) {

	args := make([]interface{}, 0, 1+0)

	if state == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, state.JSObject())
	}

	n.p.Call("initialize", args...)
}

// NodeMaterialBlockInitializeDefinesOpts contains optional parameters for NodeMaterialBlock.InitializeDefines.
type NodeMaterialBlockInitializeDefinesOpts struct {
	UseInstances *bool
}

// InitializeDefines calls the InitializeDefines method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#initializedefines
func (n *NodeMaterialBlock) InitializeDefines(mesh *AbstractMesh, nodeMaterial *NodeMaterial, defines js.Value, opts *NodeMaterialBlockInitializeDefinesOpts) {
	if opts == nil {
		opts = &NodeMaterialBlockInitializeDefinesOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if nodeMaterial == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, nodeMaterial.JSObject())
	}

	args = append(args, defines)

	if opts.UseInstances == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UseInstances)
	}

	n.p.Call("initializeDefines", args...)
}

// NodeMaterialBlockIsReadyOpts contains optional parameters for NodeMaterialBlock.IsReady.
type NodeMaterialBlockIsReadyOpts struct {
	UseInstances *bool
}

// IsReady calls the IsReady method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#isready
func (n *NodeMaterialBlock) IsReady(mesh *AbstractMesh, nodeMaterial *NodeMaterial, defines js.Value, opts *NodeMaterialBlockIsReadyOpts) bool {
	if opts == nil {
		opts = &NodeMaterialBlockIsReadyOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if nodeMaterial == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, nodeMaterial.JSObject())
	}

	args = append(args, defines)

	if opts.UseInstances == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UseInstances)
	}

	retVal := n.p.Call("isReady", args...)
	return retVal.Bool()
}

// NodeMaterialBlockPrepareDefinesOpts contains optional parameters for NodeMaterialBlock.PrepareDefines.
type NodeMaterialBlockPrepareDefinesOpts struct {
	UseInstances *bool
}

// PrepareDefines calls the PrepareDefines method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#preparedefines
func (n *NodeMaterialBlock) PrepareDefines(mesh *AbstractMesh, nodeMaterial *NodeMaterial, defines js.Value, opts *NodeMaterialBlockPrepareDefinesOpts) {
	if opts == nil {
		opts = &NodeMaterialBlockPrepareDefinesOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if nodeMaterial == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, nodeMaterial.JSObject())
	}

	args = append(args, defines)

	if opts.UseInstances == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UseInstances)
	}

	n.p.Call("prepareDefines", args...)
}

// ProvideFallbacks calls the ProvideFallbacks method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#providefallbacks
func (n *NodeMaterialBlock) ProvideFallbacks(mesh *AbstractMesh, fallbacks *EffectFallbacks) {

	args := make([]interface{}, 0, 2+0)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if fallbacks == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, fallbacks.JSObject())
	}

	n.p.Call("provideFallbacks", args...)
}

// NodeMaterialBlockRegisterInputOpts contains optional parameters for NodeMaterialBlock.RegisterInput.
type NodeMaterialBlockRegisterInputOpts struct {
	IsOptional *bool
	Target     js.Value
}

// RegisterInput calls the RegisterInput method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#registerinput
func (n *NodeMaterialBlock) RegisterInput(name string, jsType js.Value, opts *NodeMaterialBlockRegisterInputOpts) *NodeMaterialBlock {
	if opts == nil {
		opts = &NodeMaterialBlockRegisterInputOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, name)

	args = append(args, jsType)

	if opts.IsOptional == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IsOptional)
	}
	args = append(args, opts.Target)

	retVal := n.p.Call("registerInput", args...)
	return NodeMaterialBlockFromJSObject(retVal, n.ctx)
}

// NodeMaterialBlockRegisterOutputOpts contains optional parameters for NodeMaterialBlock.RegisterOutput.
type NodeMaterialBlockRegisterOutputOpts struct {
	Target js.Value
}

// RegisterOutput calls the RegisterOutput method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#registeroutput
func (n *NodeMaterialBlock) RegisterOutput(name string, jsType js.Value, opts *NodeMaterialBlockRegisterOutputOpts) *NodeMaterialBlock {
	if opts == nil {
		opts = &NodeMaterialBlockRegisterOutputOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, name)

	args = append(args, jsType)

	args = append(args, opts.Target)

	retVal := n.p.Call("registerOutput", args...)
	return NodeMaterialBlockFromJSObject(retVal, n.ctx)
}

// ReplaceRepeatableContent calls the ReplaceRepeatableContent method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#replacerepeatablecontent
func (n *NodeMaterialBlock) ReplaceRepeatableContent(vertexShaderState *NodeMaterialBuildState, fragmentShaderState *NodeMaterialBuildState, mesh *AbstractMesh, defines js.Value) {

	args := make([]interface{}, 0, 4+0)

	if vertexShaderState == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, vertexShaderState.JSObject())
	}

	if fragmentShaderState == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, fragmentShaderState.JSObject())
	}

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	args = append(args, defines)

	n.p.Call("replaceRepeatableContent", args...)
}

// Serialize calls the Serialize method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#serialize
func (n *NodeMaterialBlock) Serialize() js.Value {

	retVal := n.p.Call("serialize")
	return retVal
}

// UpdateUniformsAndSamples calls the UpdateUniformsAndSamples method on the NodeMaterialBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#updateuniformsandsamples
func (n *NodeMaterialBlock) UpdateUniformsAndSamples(state *NodeMaterialBuildState, nodeMaterial *NodeMaterial, defines js.Value, uniformBuffers []string) {

	args := make([]interface{}, 0, 4+0)

	if state == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, state.JSObject())
	}

	if nodeMaterial == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, nodeMaterial.JSObject())
	}

	args = append(args, defines)

	args = append(args, uniformBuffers)

	n.p.Call("updateUniformsAndSamples", args...)
}

// BuildId returns the BuildId property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#buildid
func (n *NodeMaterialBlock) BuildId() float64 {
	retVal := n.p.Get("buildId")
	return retVal.Float()
}

// SetBuildId sets the BuildId property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#buildid
func (n *NodeMaterialBlock) SetBuildId(buildId float64) *NodeMaterialBlock {
	n.p.Set("buildId", buildId)
	return n
}

// Comments returns the Comments property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#comments
func (n *NodeMaterialBlock) Comments() string {
	retVal := n.p.Get("comments")
	return retVal.String()
}

// SetComments sets the Comments property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#comments
func (n *NodeMaterialBlock) SetComments(comments string) *NodeMaterialBlock {
	n.p.Set("comments", comments)
	return n
}

// Inputs returns the Inputs property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#inputs
func (n *NodeMaterialBlock) Inputs() []*NodeMaterialConnectionPoint {
	retVal := n.p.Get("inputs")
	result := []*NodeMaterialConnectionPoint{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, NodeMaterialConnectionPointFromJSObject(retVal.Index(ri), n.ctx))
	}
	return result
}

// SetInputs sets the Inputs property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#inputs
func (n *NodeMaterialBlock) SetInputs(inputs []*NodeMaterialConnectionPoint) *NodeMaterialBlock {
	n.p.Set("inputs", inputs)
	return n
}

// IsFinalMerger returns the IsFinalMerger property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#isfinalmerger
func (n *NodeMaterialBlock) IsFinalMerger() bool {
	retVal := n.p.Get("isFinalMerger")
	return retVal.Bool()
}

// SetIsFinalMerger sets the IsFinalMerger property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#isfinalmerger
func (n *NodeMaterialBlock) SetIsFinalMerger(isFinalMerger bool) *NodeMaterialBlock {
	n.p.Set("isFinalMerger", isFinalMerger)
	return n
}

// IsInput returns the IsInput property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#isinput
func (n *NodeMaterialBlock) IsInput() bool {
	retVal := n.p.Get("isInput")
	return retVal.Bool()
}

// SetIsInput sets the IsInput property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#isinput
func (n *NodeMaterialBlock) SetIsInput(isInput bool) *NodeMaterialBlock {
	n.p.Set("isInput", isInput)
	return n
}

// IsUnique returns the IsUnique property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#isunique
func (n *NodeMaterialBlock) IsUnique() bool {
	retVal := n.p.Get("isUnique")
	return retVal.Bool()
}

// SetIsUnique sets the IsUnique property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#isunique
func (n *NodeMaterialBlock) SetIsUnique(isUnique bool) *NodeMaterialBlock {
	n.p.Set("isUnique", isUnique)
	return n
}

// Name returns the Name property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#name
func (n *NodeMaterialBlock) Name() string {
	retVal := n.p.Get("name")
	return retVal.String()
}

// SetName sets the Name property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#name
func (n *NodeMaterialBlock) SetName(name string) *NodeMaterialBlock {
	n.p.Set("name", name)
	return n
}

// Outputs returns the Outputs property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#outputs
func (n *NodeMaterialBlock) Outputs() []*NodeMaterialConnectionPoint {
	retVal := n.p.Get("outputs")
	result := []*NodeMaterialConnectionPoint{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, NodeMaterialConnectionPointFromJSObject(retVal.Index(ri), n.ctx))
	}
	return result
}

// SetOutputs sets the Outputs property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#outputs
func (n *NodeMaterialBlock) SetOutputs(outputs []*NodeMaterialConnectionPoint) *NodeMaterialBlock {
	n.p.Set("outputs", outputs)
	return n
}

// Target returns the Target property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#target
func (n *NodeMaterialBlock) Target() js.Value {
	retVal := n.p.Get("target")
	return retVal
}

// SetTarget sets the Target property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#target
func (n *NodeMaterialBlock) SetTarget(target js.Value) *NodeMaterialBlock {
	n.p.Set("target", target)
	return n
}

// UniqueId returns the UniqueId property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#uniqueid
func (n *NodeMaterialBlock) UniqueId() float64 {
	retVal := n.p.Get("uniqueId")
	return retVal.Float()
}

// SetUniqueId sets the UniqueId property of class NodeMaterialBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.nodematerialblock#uniqueid
func (n *NodeMaterialBlock) SetUniqueId(uniqueId float64) *NodeMaterialBlock {
	n.p.Set("uniqueId", uniqueId)
	return n
}

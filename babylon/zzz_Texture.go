// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// Texture represents a babylon.js Texture.
// This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.
//
// See: http://doc.babylonjs.com/babylon101/materials#texture
type Texture struct {
	*BaseTexture
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (t *Texture) JSObject() js.Value { return t.p }

// Texture returns a Texture JavaScript class.
func (ba *Babylon) Texture() *Texture {
	p := ba.ctx.Get("Texture")
	return TextureFromJSObject(p, ba.ctx)
}

// TextureFromJSObject returns a wrapped Texture JavaScript class.
func TextureFromJSObject(p js.Value, ctx js.Value) *Texture {
	return &Texture{BaseTexture: BaseTextureFromJSObject(p, ctx), ctx: ctx}
}

// TextureArrayToJSArray returns a JavaScript Array for the wrapped array.
func TextureArrayToJSArray(array []*Texture) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewTextureOpts contains optional parameters for NewTexture.
type NewTextureOpts struct {
	NoMipmap     *bool
	InvertY      *bool
	SamplingMode *float64
	OnLoad       func()
	OnError      func()
	Buffer       *string
	DeleteBuffer *bool
	Format       *float64
	MimeType     *string
}

// NewTexture returns a new Texture object.
//
// https://doc.babylonjs.com/api/classes/babylon.texture
func (ba *Babylon) NewTexture(url string, sceneOrEngine *Scene, opts *NewTextureOpts) *Texture {
	if opts == nil {
		opts = &NewTextureOpts{}
	}

	args := make([]interface{}, 0, 2+9)

	args = append(args, url)
	args = append(args, sceneOrEngine.JSObject())

	if opts.NoMipmap == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.NoMipmap)
	}
	if opts.InvertY == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.InvertY)
	}
	if opts.SamplingMode == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SamplingMode)
	}
	if opts.OnLoad == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.OnLoad)
	}
	if opts.OnError == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.OnError)
	}
	if opts.Buffer == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Buffer)
	}
	if opts.DeleteBuffer == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DeleteBuffer)
	}
	if opts.Format == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Format)
	}
	if opts.MimeType == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MimeType)
	}

	p := ba.ctx.Get("Texture").New(args...)
	return TextureFromJSObject(p, ba.ctx)
}

// Clone calls the Clone method on the Texture object.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#clone
func (t *Texture) Clone() *Texture {

	retVal := t.p.Call("clone")
	return TextureFromJSObject(retVal, t.ctx)
}

// TextureCreateFromBase64StringOpts contains optional parameters for Texture.CreateFromBase64String.
type TextureCreateFromBase64StringOpts struct {
	NoMipmap     *bool
	InvertY      *bool
	SamplingMode *float64
	OnLoad       func()
	OnError      func()
	Format       *float64
}

// CreateFromBase64String calls the CreateFromBase64String method on the Texture object.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#createfrombase64string
func (t *Texture) CreateFromBase64String(data string, name string, scene *Scene, opts *TextureCreateFromBase64StringOpts) *Texture {
	if opts == nil {
		opts = &TextureCreateFromBase64StringOpts{}
	}

	args := make([]interface{}, 0, 3+6)

	args = append(args, data)
	args = append(args, name)
	args = append(args, scene.JSObject())

	if opts.NoMipmap == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.NoMipmap)
	}
	if opts.InvertY == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.InvertY)
	}
	if opts.SamplingMode == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SamplingMode)
	}
	if opts.OnLoad == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.OnLoad)
	}
	if opts.OnError == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.OnError)
	}
	if opts.Format == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Format)
	}

	retVal := t.p.Call("CreateFromBase64String", args...)
	return TextureFromJSObject(retVal, t.ctx)
}

// Dispose calls the Dispose method on the Texture object.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#dispose
func (t *Texture) Dispose() {

	t.p.Call("dispose")
}

// GetClassName calls the GetClassName method on the Texture object.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#getclassname
func (t *Texture) GetClassName() string {

	retVal := t.p.Call("getClassName")
	return retVal.String()
}

// GetReflectionTextureMatrix calls the GetReflectionTextureMatrix method on the Texture object.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#getreflectiontexturematrix
func (t *Texture) GetReflectionTextureMatrix() *Matrix {

	retVal := t.p.Call("getReflectionTextureMatrix")
	return MatrixFromJSObject(retVal, t.ctx)
}

// TextureGetTextureMatrixOpts contains optional parameters for Texture.GetTextureMatrix.
type TextureGetTextureMatrixOpts struct {
	UBase *float64
}

// GetTextureMatrix calls the GetTextureMatrix method on the Texture object.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#gettexturematrix
func (t *Texture) GetTextureMatrix(opts *TextureGetTextureMatrixOpts) *Matrix {
	if opts == nil {
		opts = &TextureGetTextureMatrixOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.UBase == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UBase)
	}

	retVal := t.p.Call("getTextureMatrix", args...)
	return MatrixFromJSObject(retVal, t.ctx)
}

// TextureLoadFromDataStringOpts contains optional parameters for Texture.LoadFromDataString.
type TextureLoadFromDataStringOpts struct {
	DeleteBuffer *bool
	NoMipmap     *bool
	InvertY      *bool
	SamplingMode *float64
	OnLoad       func()
	OnError      func()
	Format       *float64
}

// LoadFromDataString calls the LoadFromDataString method on the Texture object.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#loadfromdatastring
func (t *Texture) LoadFromDataString(name string, buffer interface{}, scene *Scene, opts *TextureLoadFromDataStringOpts) *Texture {
	if opts == nil {
		opts = &TextureLoadFromDataStringOpts{}
	}

	args := make([]interface{}, 0, 3+7)

	args = append(args, name)
	args = append(args, buffer)
	args = append(args, scene.JSObject())

	if opts.DeleteBuffer == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DeleteBuffer)
	}
	if opts.NoMipmap == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.NoMipmap)
	}
	if opts.InvertY == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.InvertY)
	}
	if opts.SamplingMode == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SamplingMode)
	}
	if opts.OnLoad == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.OnLoad)
	}
	if opts.OnError == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.OnError)
	}
	if opts.Format == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Format)
	}

	retVal := t.p.Call("LoadFromDataString", args...)
	return TextureFromJSObject(retVal, t.ctx)
}

// Parse calls the Parse method on the Texture object.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#parse
func (t *Texture) Parse(parsedTexture interface{}, scene *Scene, rootUrl string) *BaseTexture {

	args := make([]interface{}, 0, 3+0)

	args = append(args, parsedTexture)
	args = append(args, scene.JSObject())
	args = append(args, rootUrl)

	retVal := t.p.Call("Parse", args...)
	return BaseTextureFromJSObject(retVal, t.ctx)
}

// Serialize calls the Serialize method on the Texture object.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#serialize
func (t *Texture) Serialize() interface{} {

	retVal := t.p.Call("serialize")
	return retVal
}

// TextureUpdateURLOpts contains optional parameters for Texture.UpdateURL.
type TextureUpdateURLOpts struct {
	Buffer *string
	OnLoad func()
}

// UpdateURL calls the UpdateURL method on the Texture object.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#updateurl
func (t *Texture) UpdateURL(url string, opts *TextureUpdateURLOpts) {
	if opts == nil {
		opts = &TextureUpdateURLOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, url)

	if opts.Buffer == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Buffer)
	}
	if opts.OnLoad == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.OnLoad)
	}

	t.p.Call("updateURL", args...)
}

/*

// BILINEAR_SAMPLINGMODE returns the BILINEAR_SAMPLINGMODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#bilinear_samplingmode
func (t *Texture) BILINEAR_SAMPLINGMODE(BILINEAR_SAMPLINGMODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(BILINEAR_SAMPLINGMODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetBILINEAR_SAMPLINGMODE sets the BILINEAR_SAMPLINGMODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#bilinear_samplingmode
func (t *Texture) SetBILINEAR_SAMPLINGMODE(BILINEAR_SAMPLINGMODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(BILINEAR_SAMPLINGMODE)
	return TextureFromJSObject(p, ba.ctx)
}

// CLAMP_ADDRESSMODE returns the CLAMP_ADDRESSMODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#clamp_addressmode
func (t *Texture) CLAMP_ADDRESSMODE(CLAMP_ADDRESSMODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(CLAMP_ADDRESSMODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetCLAMP_ADDRESSMODE sets the CLAMP_ADDRESSMODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#clamp_addressmode
func (t *Texture) SetCLAMP_ADDRESSMODE(CLAMP_ADDRESSMODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(CLAMP_ADDRESSMODE)
	return TextureFromJSObject(p, ba.ctx)
}

// CUBIC_MODE returns the CUBIC_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#cubic_mode
func (t *Texture) CUBIC_MODE(CUBIC_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(CUBIC_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetCUBIC_MODE sets the CUBIC_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#cubic_mode
func (t *Texture) SetCUBIC_MODE(CUBIC_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(CUBIC_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// EQUIRECTANGULAR_MODE returns the EQUIRECTANGULAR_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#equirectangular_mode
func (t *Texture) EQUIRECTANGULAR_MODE(EQUIRECTANGULAR_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(EQUIRECTANGULAR_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetEQUIRECTANGULAR_MODE sets the EQUIRECTANGULAR_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#equirectangular_mode
func (t *Texture) SetEQUIRECTANGULAR_MODE(EQUIRECTANGULAR_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(EQUIRECTANGULAR_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// EXPLICIT_MODE returns the EXPLICIT_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#explicit_mode
func (t *Texture) EXPLICIT_MODE(EXPLICIT_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(EXPLICIT_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetEXPLICIT_MODE sets the EXPLICIT_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#explicit_mode
func (t *Texture) SetEXPLICIT_MODE(EXPLICIT_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(EXPLICIT_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// FIXED_EQUIRECTANGULAR_MIRRORED_MODE returns the FIXED_EQUIRECTANGULAR_MIRRORED_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#fixed_equirectangular_mirrored_mode
func (t *Texture) FIXED_EQUIRECTANGULAR_MIRRORED_MODE(FIXED_EQUIRECTANGULAR_MIRRORED_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(FIXED_EQUIRECTANGULAR_MIRRORED_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetFIXED_EQUIRECTANGULAR_MIRRORED_MODE sets the FIXED_EQUIRECTANGULAR_MIRRORED_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#fixed_equirectangular_mirrored_mode
func (t *Texture) SetFIXED_EQUIRECTANGULAR_MIRRORED_MODE(FIXED_EQUIRECTANGULAR_MIRRORED_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(FIXED_EQUIRECTANGULAR_MIRRORED_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// FIXED_EQUIRECTANGULAR_MODE returns the FIXED_EQUIRECTANGULAR_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#fixed_equirectangular_mode
func (t *Texture) FIXED_EQUIRECTANGULAR_MODE(FIXED_EQUIRECTANGULAR_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(FIXED_EQUIRECTANGULAR_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetFIXED_EQUIRECTANGULAR_MODE sets the FIXED_EQUIRECTANGULAR_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#fixed_equirectangular_mode
func (t *Texture) SetFIXED_EQUIRECTANGULAR_MODE(FIXED_EQUIRECTANGULAR_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(FIXED_EQUIRECTANGULAR_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// INVCUBIC_MODE returns the INVCUBIC_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#invcubic_mode
func (t *Texture) INVCUBIC_MODE(INVCUBIC_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(INVCUBIC_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetINVCUBIC_MODE sets the INVCUBIC_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#invcubic_mode
func (t *Texture) SetINVCUBIC_MODE(INVCUBIC_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(INVCUBIC_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// InspectableCustomProperties returns the InspectableCustomProperties property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#inspectablecustomproperties
func (t *Texture) InspectableCustomProperties(inspectableCustomProperties *IInspectable) *Texture {
	p := ba.ctx.Get("Texture").New(inspectableCustomProperties.JSObject())
	return TextureFromJSObject(p, ba.ctx)
}

// SetInspectableCustomProperties sets the InspectableCustomProperties property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#inspectablecustomproperties
func (t *Texture) SetInspectableCustomProperties(inspectableCustomProperties *IInspectable) *Texture {
	p := ba.ctx.Get("Texture").New(inspectableCustomProperties.JSObject())
	return TextureFromJSObject(p, ba.ctx)
}

// InvertY returns the InvertY property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#inverty
func (t *Texture) InvertY(invertY bool) *Texture {
	p := ba.ctx.Get("Texture").New(invertY)
	return TextureFromJSObject(p, ba.ctx)
}

// SetInvertY sets the InvertY property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#inverty
func (t *Texture) SetInvertY(invertY bool) *Texture {
	p := ba.ctx.Get("Texture").New(invertY)
	return TextureFromJSObject(p, ba.ctx)
}

// IsBlocking returns the IsBlocking property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#isblocking
func (t *Texture) IsBlocking(isBlocking bool) *Texture {
	p := ba.ctx.Get("Texture").New(isBlocking)
	return TextureFromJSObject(p, ba.ctx)
}

// SetIsBlocking sets the IsBlocking property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#isblocking
func (t *Texture) SetIsBlocking(isBlocking bool) *Texture {
	p := ba.ctx.Get("Texture").New(isBlocking)
	return TextureFromJSObject(p, ba.ctx)
}

// LINEAR_LINEAR returns the LINEAR_LINEAR property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#linear_linear
func (t *Texture) LINEAR_LINEAR(LINEAR_LINEAR float64) *Texture {
	p := ba.ctx.Get("Texture").New(LINEAR_LINEAR)
	return TextureFromJSObject(p, ba.ctx)
}

// SetLINEAR_LINEAR sets the LINEAR_LINEAR property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#linear_linear
func (t *Texture) SetLINEAR_LINEAR(LINEAR_LINEAR float64) *Texture {
	p := ba.ctx.Get("Texture").New(LINEAR_LINEAR)
	return TextureFromJSObject(p, ba.ctx)
}

// LINEAR_LINEAR_MIPLINEAR returns the LINEAR_LINEAR_MIPLINEAR property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#linear_linear_miplinear
func (t *Texture) LINEAR_LINEAR_MIPLINEAR(LINEAR_LINEAR_MIPLINEAR float64) *Texture {
	p := ba.ctx.Get("Texture").New(LINEAR_LINEAR_MIPLINEAR)
	return TextureFromJSObject(p, ba.ctx)
}

// SetLINEAR_LINEAR_MIPLINEAR sets the LINEAR_LINEAR_MIPLINEAR property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#linear_linear_miplinear
func (t *Texture) SetLINEAR_LINEAR_MIPLINEAR(LINEAR_LINEAR_MIPLINEAR float64) *Texture {
	p := ba.ctx.Get("Texture").New(LINEAR_LINEAR_MIPLINEAR)
	return TextureFromJSObject(p, ba.ctx)
}

// LINEAR_LINEAR_MIPNEAREST returns the LINEAR_LINEAR_MIPNEAREST property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#linear_linear_mipnearest
func (t *Texture) LINEAR_LINEAR_MIPNEAREST(LINEAR_LINEAR_MIPNEAREST float64) *Texture {
	p := ba.ctx.Get("Texture").New(LINEAR_LINEAR_MIPNEAREST)
	return TextureFromJSObject(p, ba.ctx)
}

// SetLINEAR_LINEAR_MIPNEAREST sets the LINEAR_LINEAR_MIPNEAREST property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#linear_linear_mipnearest
func (t *Texture) SetLINEAR_LINEAR_MIPNEAREST(LINEAR_LINEAR_MIPNEAREST float64) *Texture {
	p := ba.ctx.Get("Texture").New(LINEAR_LINEAR_MIPNEAREST)
	return TextureFromJSObject(p, ba.ctx)
}

// LINEAR_NEAREST returns the LINEAR_NEAREST property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#linear_nearest
func (t *Texture) LINEAR_NEAREST(LINEAR_NEAREST float64) *Texture {
	p := ba.ctx.Get("Texture").New(LINEAR_NEAREST)
	return TextureFromJSObject(p, ba.ctx)
}

// SetLINEAR_NEAREST sets the LINEAR_NEAREST property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#linear_nearest
func (t *Texture) SetLINEAR_NEAREST(LINEAR_NEAREST float64) *Texture {
	p := ba.ctx.Get("Texture").New(LINEAR_NEAREST)
	return TextureFromJSObject(p, ba.ctx)
}

// LINEAR_NEAREST_MIPLINEAR returns the LINEAR_NEAREST_MIPLINEAR property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#linear_nearest_miplinear
func (t *Texture) LINEAR_NEAREST_MIPLINEAR(LINEAR_NEAREST_MIPLINEAR float64) *Texture {
	p := ba.ctx.Get("Texture").New(LINEAR_NEAREST_MIPLINEAR)
	return TextureFromJSObject(p, ba.ctx)
}

// SetLINEAR_NEAREST_MIPLINEAR sets the LINEAR_NEAREST_MIPLINEAR property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#linear_nearest_miplinear
func (t *Texture) SetLINEAR_NEAREST_MIPLINEAR(LINEAR_NEAREST_MIPLINEAR float64) *Texture {
	p := ba.ctx.Get("Texture").New(LINEAR_NEAREST_MIPLINEAR)
	return TextureFromJSObject(p, ba.ctx)
}

// LINEAR_NEAREST_MIPNEAREST returns the LINEAR_NEAREST_MIPNEAREST property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#linear_nearest_mipnearest
func (t *Texture) LINEAR_NEAREST_MIPNEAREST(LINEAR_NEAREST_MIPNEAREST float64) *Texture {
	p := ba.ctx.Get("Texture").New(LINEAR_NEAREST_MIPNEAREST)
	return TextureFromJSObject(p, ba.ctx)
}

// SetLINEAR_NEAREST_MIPNEAREST sets the LINEAR_NEAREST_MIPNEAREST property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#linear_nearest_mipnearest
func (t *Texture) SetLINEAR_NEAREST_MIPNEAREST(LINEAR_NEAREST_MIPNEAREST float64) *Texture {
	p := ba.ctx.Get("Texture").New(LINEAR_NEAREST_MIPNEAREST)
	return TextureFromJSObject(p, ba.ctx)
}

// MIRROR_ADDRESSMODE returns the MIRROR_ADDRESSMODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#mirror_addressmode
func (t *Texture) MIRROR_ADDRESSMODE(MIRROR_ADDRESSMODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(MIRROR_ADDRESSMODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetMIRROR_ADDRESSMODE sets the MIRROR_ADDRESSMODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#mirror_addressmode
func (t *Texture) SetMIRROR_ADDRESSMODE(MIRROR_ADDRESSMODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(MIRROR_ADDRESSMODE)
	return TextureFromJSObject(p, ba.ctx)
}

// NEAREST_LINEAR returns the NEAREST_LINEAR property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nearest_linear
func (t *Texture) NEAREST_LINEAR(NEAREST_LINEAR float64) *Texture {
	p := ba.ctx.Get("Texture").New(NEAREST_LINEAR)
	return TextureFromJSObject(p, ba.ctx)
}

// SetNEAREST_LINEAR sets the NEAREST_LINEAR property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nearest_linear
func (t *Texture) SetNEAREST_LINEAR(NEAREST_LINEAR float64) *Texture {
	p := ba.ctx.Get("Texture").New(NEAREST_LINEAR)
	return TextureFromJSObject(p, ba.ctx)
}

// NEAREST_LINEAR_MIPLINEAR returns the NEAREST_LINEAR_MIPLINEAR property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nearest_linear_miplinear
func (t *Texture) NEAREST_LINEAR_MIPLINEAR(NEAREST_LINEAR_MIPLINEAR float64) *Texture {
	p := ba.ctx.Get("Texture").New(NEAREST_LINEAR_MIPLINEAR)
	return TextureFromJSObject(p, ba.ctx)
}

// SetNEAREST_LINEAR_MIPLINEAR sets the NEAREST_LINEAR_MIPLINEAR property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nearest_linear_miplinear
func (t *Texture) SetNEAREST_LINEAR_MIPLINEAR(NEAREST_LINEAR_MIPLINEAR float64) *Texture {
	p := ba.ctx.Get("Texture").New(NEAREST_LINEAR_MIPLINEAR)
	return TextureFromJSObject(p, ba.ctx)
}

// NEAREST_LINEAR_MIPNEAREST returns the NEAREST_LINEAR_MIPNEAREST property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nearest_linear_mipnearest
func (t *Texture) NEAREST_LINEAR_MIPNEAREST(NEAREST_LINEAR_MIPNEAREST float64) *Texture {
	p := ba.ctx.Get("Texture").New(NEAREST_LINEAR_MIPNEAREST)
	return TextureFromJSObject(p, ba.ctx)
}

// SetNEAREST_LINEAR_MIPNEAREST sets the NEAREST_LINEAR_MIPNEAREST property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nearest_linear_mipnearest
func (t *Texture) SetNEAREST_LINEAR_MIPNEAREST(NEAREST_LINEAR_MIPNEAREST float64) *Texture {
	p := ba.ctx.Get("Texture").New(NEAREST_LINEAR_MIPNEAREST)
	return TextureFromJSObject(p, ba.ctx)
}

// NEAREST_NEAREST returns the NEAREST_NEAREST property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nearest_nearest
func (t *Texture) NEAREST_NEAREST(NEAREST_NEAREST float64) *Texture {
	p := ba.ctx.Get("Texture").New(NEAREST_NEAREST)
	return TextureFromJSObject(p, ba.ctx)
}

// SetNEAREST_NEAREST sets the NEAREST_NEAREST property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nearest_nearest
func (t *Texture) SetNEAREST_NEAREST(NEAREST_NEAREST float64) *Texture {
	p := ba.ctx.Get("Texture").New(NEAREST_NEAREST)
	return TextureFromJSObject(p, ba.ctx)
}

// NEAREST_NEAREST_MIPLINEAR returns the NEAREST_NEAREST_MIPLINEAR property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nearest_nearest_miplinear
func (t *Texture) NEAREST_NEAREST_MIPLINEAR(NEAREST_NEAREST_MIPLINEAR float64) *Texture {
	p := ba.ctx.Get("Texture").New(NEAREST_NEAREST_MIPLINEAR)
	return TextureFromJSObject(p, ba.ctx)
}

// SetNEAREST_NEAREST_MIPLINEAR sets the NEAREST_NEAREST_MIPLINEAR property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nearest_nearest_miplinear
func (t *Texture) SetNEAREST_NEAREST_MIPLINEAR(NEAREST_NEAREST_MIPLINEAR float64) *Texture {
	p := ba.ctx.Get("Texture").New(NEAREST_NEAREST_MIPLINEAR)
	return TextureFromJSObject(p, ba.ctx)
}

// NEAREST_NEAREST_MIPNEAREST returns the NEAREST_NEAREST_MIPNEAREST property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nearest_nearest_mipnearest
func (t *Texture) NEAREST_NEAREST_MIPNEAREST(NEAREST_NEAREST_MIPNEAREST float64) *Texture {
	p := ba.ctx.Get("Texture").New(NEAREST_NEAREST_MIPNEAREST)
	return TextureFromJSObject(p, ba.ctx)
}

// SetNEAREST_NEAREST_MIPNEAREST sets the NEAREST_NEAREST_MIPNEAREST property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nearest_nearest_mipnearest
func (t *Texture) SetNEAREST_NEAREST_MIPNEAREST(NEAREST_NEAREST_MIPNEAREST float64) *Texture {
	p := ba.ctx.Get("Texture").New(NEAREST_NEAREST_MIPNEAREST)
	return TextureFromJSObject(p, ba.ctx)
}

// NEAREST_SAMPLINGMODE returns the NEAREST_SAMPLINGMODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nearest_samplingmode
func (t *Texture) NEAREST_SAMPLINGMODE(NEAREST_SAMPLINGMODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(NEAREST_SAMPLINGMODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetNEAREST_SAMPLINGMODE sets the NEAREST_SAMPLINGMODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nearest_samplingmode
func (t *Texture) SetNEAREST_SAMPLINGMODE(NEAREST_SAMPLINGMODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(NEAREST_SAMPLINGMODE)
	return TextureFromJSObject(p, ba.ctx)
}

// NoMipmap returns the NoMipmap property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nomipmap
func (t *Texture) NoMipmap(noMipmap bool) *Texture {
	p := ba.ctx.Get("Texture").New(noMipmap)
	return TextureFromJSObject(p, ba.ctx)
}

// SetNoMipmap sets the NoMipmap property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#nomipmap
func (t *Texture) SetNoMipmap(noMipmap bool) *Texture {
	p := ba.ctx.Get("Texture").New(noMipmap)
	return TextureFromJSObject(p, ba.ctx)
}

// OnLoadObservable returns the OnLoadObservable property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#onloadobservable
func (t *Texture) OnLoadObservable(onLoadObservable *Observable) *Texture {
	p := ba.ctx.Get("Texture").New(onLoadObservable.JSObject())
	return TextureFromJSObject(p, ba.ctx)
}

// SetOnLoadObservable sets the OnLoadObservable property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#onloadobservable
func (t *Texture) SetOnLoadObservable(onLoadObservable *Observable) *Texture {
	p := ba.ctx.Get("Texture").New(onLoadObservable.JSObject())
	return TextureFromJSObject(p, ba.ctx)
}

// PLANAR_MODE returns the PLANAR_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#planar_mode
func (t *Texture) PLANAR_MODE(PLANAR_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(PLANAR_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetPLANAR_MODE sets the PLANAR_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#planar_mode
func (t *Texture) SetPLANAR_MODE(PLANAR_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(PLANAR_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// PROJECTION_MODE returns the PROJECTION_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#projection_mode
func (t *Texture) PROJECTION_MODE(PROJECTION_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(PROJECTION_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetPROJECTION_MODE sets the PROJECTION_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#projection_mode
func (t *Texture) SetPROJECTION_MODE(PROJECTION_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(PROJECTION_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SKYBOX_MODE returns the SKYBOX_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#skybox_mode
func (t *Texture) SKYBOX_MODE(SKYBOX_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(SKYBOX_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetSKYBOX_MODE sets the SKYBOX_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#skybox_mode
func (t *Texture) SetSKYBOX_MODE(SKYBOX_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(SKYBOX_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SPHERICAL_MODE returns the SPHERICAL_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#spherical_mode
func (t *Texture) SPHERICAL_MODE(SPHERICAL_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(SPHERICAL_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetSPHERICAL_MODE sets the SPHERICAL_MODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#spherical_mode
func (t *Texture) SetSPHERICAL_MODE(SPHERICAL_MODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(SPHERICAL_MODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SamplingMode returns the SamplingMode property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#samplingmode
func (t *Texture) SamplingMode(samplingMode float64) *Texture {
	p := ba.ctx.Get("Texture").New(samplingMode)
	return TextureFromJSObject(p, ba.ctx)
}

// SetSamplingMode sets the SamplingMode property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#samplingmode
func (t *Texture) SetSamplingMode(samplingMode float64) *Texture {
	p := ba.ctx.Get("Texture").New(samplingMode)
	return TextureFromJSObject(p, ba.ctx)
}

// SerializeBuffers returns the SerializeBuffers property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#serializebuffers
func (t *Texture) SerializeBuffers(SerializeBuffers bool) *Texture {
	p := ba.ctx.Get("Texture").New(SerializeBuffers)
	return TextureFromJSObject(p, ba.ctx)
}

// SetSerializeBuffers sets the SerializeBuffers property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#serializebuffers
func (t *Texture) SetSerializeBuffers(SerializeBuffers bool) *Texture {
	p := ba.ctx.Get("Texture").New(SerializeBuffers)
	return TextureFromJSObject(p, ba.ctx)
}

// TRILINEAR_SAMPLINGMODE returns the TRILINEAR_SAMPLINGMODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#trilinear_samplingmode
func (t *Texture) TRILINEAR_SAMPLINGMODE(TRILINEAR_SAMPLINGMODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(TRILINEAR_SAMPLINGMODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetTRILINEAR_SAMPLINGMODE sets the TRILINEAR_SAMPLINGMODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#trilinear_samplingmode
func (t *Texture) SetTRILINEAR_SAMPLINGMODE(TRILINEAR_SAMPLINGMODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(TRILINEAR_SAMPLINGMODE)
	return TextureFromJSObject(p, ba.ctx)
}

// UAng returns the UAng property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#uang
func (t *Texture) UAng(uAng float64) *Texture {
	p := ba.ctx.Get("Texture").New(uAng)
	return TextureFromJSObject(p, ba.ctx)
}

// SetUAng sets the UAng property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#uang
func (t *Texture) SetUAng(uAng float64) *Texture {
	p := ba.ctx.Get("Texture").New(uAng)
	return TextureFromJSObject(p, ba.ctx)
}

// UOffset returns the UOffset property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#uoffset
func (t *Texture) UOffset(uOffset float64) *Texture {
	p := ba.ctx.Get("Texture").New(uOffset)
	return TextureFromJSObject(p, ba.ctx)
}

// SetUOffset sets the UOffset property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#uoffset
func (t *Texture) SetUOffset(uOffset float64) *Texture {
	p := ba.ctx.Get("Texture").New(uOffset)
	return TextureFromJSObject(p, ba.ctx)
}

// URotationCenter returns the URotationCenter property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#urotationcenter
func (t *Texture) URotationCenter(uRotationCenter float64) *Texture {
	p := ba.ctx.Get("Texture").New(uRotationCenter)
	return TextureFromJSObject(p, ba.ctx)
}

// SetURotationCenter sets the URotationCenter property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#urotationcenter
func (t *Texture) SetURotationCenter(uRotationCenter float64) *Texture {
	p := ba.ctx.Get("Texture").New(uRotationCenter)
	return TextureFromJSObject(p, ba.ctx)
}

// UScale returns the UScale property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#uscale
func (t *Texture) UScale(uScale float64) *Texture {
	p := ba.ctx.Get("Texture").New(uScale)
	return TextureFromJSObject(p, ba.ctx)
}

// SetUScale sets the UScale property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#uscale
func (t *Texture) SetUScale(uScale float64) *Texture {
	p := ba.ctx.Get("Texture").New(uScale)
	return TextureFromJSObject(p, ba.ctx)
}

// Url returns the Url property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#url
func (t *Texture) Url(url string) *Texture {
	p := ba.ctx.Get("Texture").New(url)
	return TextureFromJSObject(p, ba.ctx)
}

// SetUrl sets the Url property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#url
func (t *Texture) SetUrl(url string) *Texture {
	p := ba.ctx.Get("Texture").New(url)
	return TextureFromJSObject(p, ba.ctx)
}

// UseSerializedUrlIfAny returns the UseSerializedUrlIfAny property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#useserializedurlifany
func (t *Texture) UseSerializedUrlIfAny(UseSerializedUrlIfAny bool) *Texture {
	p := ba.ctx.Get("Texture").New(UseSerializedUrlIfAny)
	return TextureFromJSObject(p, ba.ctx)
}

// SetUseSerializedUrlIfAny sets the UseSerializedUrlIfAny property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#useserializedurlifany
func (t *Texture) SetUseSerializedUrlIfAny(UseSerializedUrlIfAny bool) *Texture {
	p := ba.ctx.Get("Texture").New(UseSerializedUrlIfAny)
	return TextureFromJSObject(p, ba.ctx)
}

// VAng returns the VAng property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#vang
func (t *Texture) VAng(vAng float64) *Texture {
	p := ba.ctx.Get("Texture").New(vAng)
	return TextureFromJSObject(p, ba.ctx)
}

// SetVAng sets the VAng property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#vang
func (t *Texture) SetVAng(vAng float64) *Texture {
	p := ba.ctx.Get("Texture").New(vAng)
	return TextureFromJSObject(p, ba.ctx)
}

// VOffset returns the VOffset property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#voffset
func (t *Texture) VOffset(vOffset float64) *Texture {
	p := ba.ctx.Get("Texture").New(vOffset)
	return TextureFromJSObject(p, ba.ctx)
}

// SetVOffset sets the VOffset property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#voffset
func (t *Texture) SetVOffset(vOffset float64) *Texture {
	p := ba.ctx.Get("Texture").New(vOffset)
	return TextureFromJSObject(p, ba.ctx)
}

// VRotationCenter returns the VRotationCenter property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#vrotationcenter
func (t *Texture) VRotationCenter(vRotationCenter float64) *Texture {
	p := ba.ctx.Get("Texture").New(vRotationCenter)
	return TextureFromJSObject(p, ba.ctx)
}

// SetVRotationCenter sets the VRotationCenter property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#vrotationcenter
func (t *Texture) SetVRotationCenter(vRotationCenter float64) *Texture {
	p := ba.ctx.Get("Texture").New(vRotationCenter)
	return TextureFromJSObject(p, ba.ctx)
}

// VScale returns the VScale property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#vscale
func (t *Texture) VScale(vScale float64) *Texture {
	p := ba.ctx.Get("Texture").New(vScale)
	return TextureFromJSObject(p, ba.ctx)
}

// SetVScale sets the VScale property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#vscale
func (t *Texture) SetVScale(vScale float64) *Texture {
	p := ba.ctx.Get("Texture").New(vScale)
	return TextureFromJSObject(p, ba.ctx)
}

// WAng returns the WAng property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#wang
func (t *Texture) WAng(wAng float64) *Texture {
	p := ba.ctx.Get("Texture").New(wAng)
	return TextureFromJSObject(p, ba.ctx)
}

// SetWAng sets the WAng property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#wang
func (t *Texture) SetWAng(wAng float64) *Texture {
	p := ba.ctx.Get("Texture").New(wAng)
	return TextureFromJSObject(p, ba.ctx)
}

// WRAP_ADDRESSMODE returns the WRAP_ADDRESSMODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#wrap_addressmode
func (t *Texture) WRAP_ADDRESSMODE(WRAP_ADDRESSMODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(WRAP_ADDRESSMODE)
	return TextureFromJSObject(p, ba.ctx)
}

// SetWRAP_ADDRESSMODE sets the WRAP_ADDRESSMODE property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#wrap_addressmode
func (t *Texture) SetWRAP_ADDRESSMODE(WRAP_ADDRESSMODE float64) *Texture {
	p := ba.ctx.Get("Texture").New(WRAP_ADDRESSMODE)
	return TextureFromJSObject(p, ba.ctx)
}

// WRotationCenter returns the WRotationCenter property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#wrotationcenter
func (t *Texture) WRotationCenter(wRotationCenter float64) *Texture {
	p := ba.ctx.Get("Texture").New(wRotationCenter)
	return TextureFromJSObject(p, ba.ctx)
}

// SetWRotationCenter sets the WRotationCenter property of class Texture.
//
// https://doc.babylonjs.com/api/classes/babylon.texture#wrotationcenter
func (t *Texture) SetWRotationCenter(wRotationCenter float64) *Texture {
	p := ba.ctx.Get("Texture").New(wRotationCenter)
	return TextureFromJSObject(p, ba.ctx)
}

*/

// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// Mesh represents a babylon.js Mesh.
// Class used to represent renderable models
type Mesh struct {
	*AbstractMesh
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (m *Mesh) JSObject() js.Value { return m.p }

// Mesh returns a Mesh JavaScript class.
func (ba *Babylon) Mesh() *Mesh {
	p := ba.ctx.Get("Mesh")
	return MeshFromJSObject(p, ba.ctx)
}

// MeshFromJSObject returns a wrapped Mesh JavaScript class.
func MeshFromJSObject(p js.Value, ctx js.Value) *Mesh {
	return &Mesh{AbstractMesh: AbstractMeshFromJSObject(p, ctx), ctx: ctx}
}

// MeshArrayToJSArray returns a JavaScript Array for the wrapped array.
func MeshArrayToJSArray(array []*Mesh) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewMeshOpts contains optional parameters for NewMesh.
type NewMeshOpts struct {
	Scene                *Scene
	Parent               *Node
	Source               *Mesh
	DoNotCloneChildren   *bool
	ClonePhysicsImpostor *bool
}

// NewMesh returns a new Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh
func (ba *Babylon) NewMesh(name string, opts *NewMeshOpts) *Mesh {
	if opts == nil {
		opts = &NewMeshOpts{}
	}

	args := make([]interface{}, 0, 1+5)

	args = append(args, name)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Parent == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Parent.JSObject())
	}
	if opts.Source == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Source.JSObject())
	}
	if opts.DoNotCloneChildren == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotCloneChildren)
	}
	if opts.ClonePhysicsImpostor == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ClonePhysicsImpostor)
	}

	p := ba.ctx.Get("Mesh").New(args...)
	return MeshFromJSObject(p, ba.ctx)
}

// AddLODLevel calls the AddLODLevel method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#addlodlevel
func (m *Mesh) AddLODLevel(distance float64, mesh *Mesh) *Mesh {

	args := make([]interface{}, 0, 2+0)

	args = append(args, distance)
	args = append(args, mesh.JSObject())

	retVal := m.p.Call("addLODLevel", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshApplyDisplacementMapOpts contains optional parameters for Mesh.ApplyDisplacementMap.
type MeshApplyDisplacementMapOpts struct {
	OnSuccess   func()
	UvOffset    *Vector2
	UvScale     *Vector2
	ForceUpdate *bool
}

// ApplyDisplacementMap calls the ApplyDisplacementMap method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#applydisplacementmap
func (m *Mesh) ApplyDisplacementMap(url string, minHeight float64, maxHeight float64, opts *MeshApplyDisplacementMapOpts) *Mesh {
	if opts == nil {
		opts = &MeshApplyDisplacementMapOpts{}
	}

	args := make([]interface{}, 0, 3+4)

	args = append(args, url)
	args = append(args, minHeight)
	args = append(args, maxHeight)

	if opts.OnSuccess == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OnSuccess(); return nil }) /* never freed! */)
	}
	if opts.UvOffset == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.UvOffset.JSObject())
	}
	if opts.UvScale == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.UvScale.JSObject())
	}
	if opts.ForceUpdate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceUpdate)
	}

	retVal := m.p.Call("applyDisplacementMap", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshApplyDisplacementMapFromBufferOpts contains optional parameters for Mesh.ApplyDisplacementMapFromBuffer.
type MeshApplyDisplacementMapFromBufferOpts struct {
	UvOffset    *Vector2
	UvScale     *Vector2
	ForceUpdate *bool
}

// ApplyDisplacementMapFromBuffer calls the ApplyDisplacementMapFromBuffer method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#applydisplacementmapfrombuffer
func (m *Mesh) ApplyDisplacementMapFromBuffer(buffer js.Value, heightMapWidth float64, heightMapHeight float64, minHeight float64, maxHeight float64, opts *MeshApplyDisplacementMapFromBufferOpts) *Mesh {
	if opts == nil {
		opts = &MeshApplyDisplacementMapFromBufferOpts{}
	}

	args := make([]interface{}, 0, 5+3)

	args = append(args, buffer)
	args = append(args, heightMapWidth)
	args = append(args, heightMapHeight)
	args = append(args, minHeight)
	args = append(args, maxHeight)

	if opts.UvOffset == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.UvOffset.JSObject())
	}
	if opts.UvScale == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.UvScale.JSObject())
	}
	if opts.ForceUpdate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceUpdate)
	}

	retVal := m.p.Call("applyDisplacementMapFromBuffer", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// ApplySkeleton calls the ApplySkeleton method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#applyskeleton
func (m *Mesh) ApplySkeleton(skeleton *Skeleton) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, skeleton.JSObject())

	retVal := m.p.Call("applySkeleton", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// BakeCurrentTransformIntoVertices calls the BakeCurrentTransformIntoVertices method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#bakecurrenttransformintovertices
func (m *Mesh) BakeCurrentTransformIntoVertices() *Mesh {

	retVal := m.p.Call("bakeCurrentTransformIntoVertices")
	return MeshFromJSObject(retVal, m.ctx)
}

// BakeTransformIntoVertices calls the BakeTransformIntoVertices method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#baketransformintovertices
func (m *Mesh) BakeTransformIntoVertices(transform *Matrix) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, transform.JSObject())

	retVal := m.p.Call("bakeTransformIntoVertices", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// Center calls the Center method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#center
func (m *Mesh) Center(meshesOrMinMaxVector js.Value) *Vector3 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, meshesOrMinMaxVector)

	retVal := m.p.Call("Center", args...)
	return Vector3FromJSObject(retVal, m.ctx)
}

// CleanMatrixWeights calls the CleanMatrixWeights method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#cleanmatrixweights
func (m *Mesh) CleanMatrixWeights() {

	m.p.Call("cleanMatrixWeights")
}

// MeshCloneOpts contains optional parameters for Mesh.Clone.
type MeshCloneOpts struct {
	Name                 *string
	NewParent            *Node
	DoNotCloneChildren   *bool
	ClonePhysicsImpostor *bool
}

// Clone calls the Clone method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#clone
func (m *Mesh) Clone(opts *MeshCloneOpts) *AbstractMesh {
	if opts == nil {
		opts = &MeshCloneOpts{}
	}

	args := make([]interface{}, 0, 0+4)

	if opts.Name == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Name)
	}
	if opts.NewParent == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.NewParent.JSObject())
	}
	if opts.DoNotCloneChildren == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotCloneChildren)
	}
	if opts.ClonePhysicsImpostor == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ClonePhysicsImpostor)
	}

	retVal := m.p.Call("clone", args...)
	return AbstractMeshFromJSObject(retVal, m.ctx)
}

// ConvertToFlatShadedMesh calls the ConvertToFlatShadedMesh method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#converttoflatshadedmesh
func (m *Mesh) ConvertToFlatShadedMesh() *Mesh {

	retVal := m.p.Call("convertToFlatShadedMesh")
	return MeshFromJSObject(retVal, m.ctx)
}

// ConvertToUnIndexedMesh calls the ConvertToUnIndexedMesh method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#converttounindexedmesh
func (m *Mesh) ConvertToUnIndexedMesh() *Mesh {

	retVal := m.p.Call("convertToUnIndexedMesh")
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshCreateBoxOpts contains optional parameters for Mesh.CreateBox.
type MeshCreateBoxOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateBox calls the CreateBox method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createbox
func (m *Mesh) CreateBox(name string, size float64, opts *MeshCreateBoxOpts) *Mesh {
	if opts == nil {
		opts = &MeshCreateBoxOpts{}
	}

	args := make([]interface{}, 0, 2+3)

	args = append(args, name)
	args = append(args, size)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := m.p.Call("CreateBox", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshCreateCylinderOpts contains optional parameters for Mesh.CreateCylinder.
type MeshCreateCylinderOpts struct {
	Scene           *Scene
	Updatable       *interface{}
	SideOrientation *float64
}

// CreateCylinder calls the CreateCylinder method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createcylinder
func (m *Mesh) CreateCylinder(name string, height float64, diameterTop float64, diameterBottom float64, tessellation float64, subdivisions interface{}, opts *MeshCreateCylinderOpts) *Mesh {
	if opts == nil {
		opts = &MeshCreateCylinderOpts{}
	}

	args := make([]interface{}, 0, 6+3)

	args = append(args, name)
	args = append(args, height)
	args = append(args, diameterTop)
	args = append(args, diameterBottom)
	args = append(args, tessellation)
	args = append(args, subdivisions)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := m.p.Call("CreateCylinder", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshCreateDashedLinesOpts contains optional parameters for Mesh.CreateDashedLines.
type MeshCreateDashedLinesOpts struct {
	Scene     *Scene
	Updatable *bool
	Instance  *LinesMesh
}

// CreateDashedLines calls the CreateDashedLines method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createdashedlines
func (m *Mesh) CreateDashedLines(name string, points *Vector3, dashSize float64, gapSize float64, dashNb float64, opts *MeshCreateDashedLinesOpts) *LinesMesh {
	if opts == nil {
		opts = &MeshCreateDashedLinesOpts{}
	}

	args := make([]interface{}, 0, 5+3)

	args = append(args, name)
	args = append(args, points.JSObject())
	args = append(args, dashSize)
	args = append(args, gapSize)
	args = append(args, dashNb)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := m.p.Call("CreateDashedLines", args...)
	return LinesMeshFromJSObject(retVal, m.ctx)
}

// CreateDecal calls the CreateDecal method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createdecal
func (m *Mesh) CreateDecal(name string, sourceMesh *AbstractMesh, position *Vector3, normal *Vector3, size *Vector3, angle float64) *Mesh {

	args := make([]interface{}, 0, 6+0)

	args = append(args, name)
	args = append(args, sourceMesh.JSObject())
	args = append(args, position.JSObject())
	args = append(args, normal.JSObject())
	args = append(args, size.JSObject())
	args = append(args, angle)

	retVal := m.p.Call("CreateDecal", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshCreateDiscOpts contains optional parameters for Mesh.CreateDisc.
type MeshCreateDiscOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateDisc calls the CreateDisc method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createdisc
func (m *Mesh) CreateDisc(name string, radius float64, tessellation float64, opts *MeshCreateDiscOpts) *Mesh {
	if opts == nil {
		opts = &MeshCreateDiscOpts{}
	}

	args := make([]interface{}, 0, 3+3)

	args = append(args, name)
	args = append(args, radius)
	args = append(args, tessellation)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := m.p.Call("CreateDisc", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshCreateGroundOpts contains optional parameters for Mesh.CreateGround.
type MeshCreateGroundOpts struct {
	Scene     *Scene
	Updatable *bool
}

// CreateGround calls the CreateGround method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createground
func (m *Mesh) CreateGround(name string, width float64, height float64, subdivisions float64, opts *MeshCreateGroundOpts) *Mesh {
	if opts == nil {
		opts = &MeshCreateGroundOpts{}
	}

	args := make([]interface{}, 0, 4+2)

	args = append(args, name)
	args = append(args, width)
	args = append(args, height)
	args = append(args, subdivisions)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}

	retVal := m.p.Call("CreateGround", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshCreateGroundFromHeightMapOpts contains optional parameters for Mesh.CreateGroundFromHeightMap.
type MeshCreateGroundFromHeightMapOpts struct {
	Updatable   *bool
	OnReady     func()
	AlphaFilter *float64
}

// CreateGroundFromHeightMap calls the CreateGroundFromHeightMap method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#creategroundfromheightmap
func (m *Mesh) CreateGroundFromHeightMap(name string, url string, width float64, height float64, subdivisions float64, minHeight float64, maxHeight float64, scene *Scene, opts *MeshCreateGroundFromHeightMapOpts) *GroundMesh {
	if opts == nil {
		opts = &MeshCreateGroundFromHeightMapOpts{}
	}

	args := make([]interface{}, 0, 8+3)

	args = append(args, name)
	args = append(args, url)
	args = append(args, width)
	args = append(args, height)
	args = append(args, subdivisions)
	args = append(args, minHeight)
	args = append(args, maxHeight)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.OnReady == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OnReady(); return nil }) /* never freed! */)
	}
	if opts.AlphaFilter == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AlphaFilter)
	}

	retVal := m.p.Call("CreateGroundFromHeightMap", args...)
	return GroundMeshFromJSObject(retVal, m.ctx)
}

// MeshCreateHemisphereOpts contains optional parameters for Mesh.CreateHemisphere.
type MeshCreateHemisphereOpts struct {
	Scene *Scene
}

// CreateHemisphere calls the CreateHemisphere method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createhemisphere
func (m *Mesh) CreateHemisphere(name string, segments float64, diameter float64, opts *MeshCreateHemisphereOpts) *Mesh {
	if opts == nil {
		opts = &MeshCreateHemisphereOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	args = append(args, name)
	args = append(args, segments)
	args = append(args, diameter)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}

	retVal := m.p.Call("CreateHemisphere", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// CreateIcoSphere calls the CreateIcoSphere method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createicosphere
func (m *Mesh) CreateIcoSphere(name string, options js.Value, scene *Scene) *Mesh {

	args := make([]interface{}, 0, 3+0)

	args = append(args, name)
	args = append(args, options)
	args = append(args, scene.JSObject())

	retVal := m.p.Call("CreateIcoSphere", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// CreateInstance calls the CreateInstance method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createinstance
func (m *Mesh) CreateInstance(name string) *InstancedMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := m.p.Call("createInstance", args...)
	return InstancedMeshFromJSObject(retVal, m.ctx)
}

// MeshCreateLatheOpts contains optional parameters for Mesh.CreateLathe.
type MeshCreateLatheOpts struct {
	Updatable       *bool
	SideOrientation *float64
}

// CreateLathe calls the CreateLathe method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createlathe
func (m *Mesh) CreateLathe(name string, shape *Vector3, radius float64, tessellation float64, scene *Scene, opts *MeshCreateLatheOpts) *Mesh {
	if opts == nil {
		opts = &MeshCreateLatheOpts{}
	}

	args := make([]interface{}, 0, 5+2)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, radius)
	args = append(args, tessellation)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := m.p.Call("CreateLathe", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshCreateLinesOpts contains optional parameters for Mesh.CreateLines.
type MeshCreateLinesOpts struct {
	Scene     *Scene
	Updatable *bool
	Instance  *LinesMesh
}

// CreateLines calls the CreateLines method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createlines
func (m *Mesh) CreateLines(name string, points *Vector3, opts *MeshCreateLinesOpts) *LinesMesh {
	if opts == nil {
		opts = &MeshCreateLinesOpts{}
	}

	args := make([]interface{}, 0, 2+3)

	args = append(args, name)
	args = append(args, points.JSObject())

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := m.p.Call("CreateLines", args...)
	return LinesMeshFromJSObject(retVal, m.ctx)
}

// MeshCreatePlaneOpts contains optional parameters for Mesh.CreatePlane.
type MeshCreatePlaneOpts struct {
	Updatable       *bool
	SideOrientation *float64
}

// CreatePlane calls the CreatePlane method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createplane
func (m *Mesh) CreatePlane(name string, size float64, scene *Scene, opts *MeshCreatePlaneOpts) *Mesh {
	if opts == nil {
		opts = &MeshCreatePlaneOpts{}
	}

	args := make([]interface{}, 0, 3+2)

	args = append(args, name)
	args = append(args, size)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := m.p.Call("CreatePlane", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshCreatePolygonOpts contains optional parameters for Mesh.CreatePolygon.
type MeshCreatePolygonOpts struct {
	Holes           *Vector3
	Updatable       *bool
	SideOrientation *float64
	EarcutInjection *interface{}
}

// CreatePolygon calls the CreatePolygon method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createpolygon
func (m *Mesh) CreatePolygon(name string, shape *Vector3, scene *Scene, opts *MeshCreatePolygonOpts) *Mesh {
	if opts == nil {
		opts = &MeshCreatePolygonOpts{}
	}

	args := make([]interface{}, 0, 3+4)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, scene.JSObject())

	if opts.Holes == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Holes.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.EarcutInjection == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.EarcutInjection)
	}

	retVal := m.p.Call("CreatePolygon", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// CreatePolyhedron calls the CreatePolyhedron method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createpolyhedron
func (m *Mesh) CreatePolyhedron(name string, options js.Value, scene *Scene) *Mesh {

	args := make([]interface{}, 0, 3+0)

	args = append(args, name)
	args = append(args, options)
	args = append(args, scene.JSObject())

	retVal := m.p.Call("CreatePolyhedron", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshCreateRibbonOpts contains optional parameters for Mesh.CreateRibbon.
type MeshCreateRibbonOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
	Instance        *Mesh
}

// CreateRibbon calls the CreateRibbon method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createribbon
func (m *Mesh) CreateRibbon(name string, pathArray *Vector3, closeArray bool, closePath bool, offset float64, opts *MeshCreateRibbonOpts) *Mesh {
	if opts == nil {
		opts = &MeshCreateRibbonOpts{}
	}

	args := make([]interface{}, 0, 5+4)

	args = append(args, name)
	args = append(args, pathArray.JSObject())
	args = append(args, closeArray)
	args = append(args, closePath)
	args = append(args, offset)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := m.p.Call("CreateRibbon", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshCreateSphereOpts contains optional parameters for Mesh.CreateSphere.
type MeshCreateSphereOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateSphere calls the CreateSphere method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createsphere
func (m *Mesh) CreateSphere(name string, segments float64, diameter float64, opts *MeshCreateSphereOpts) *Mesh {
	if opts == nil {
		opts = &MeshCreateSphereOpts{}
	}

	args := make([]interface{}, 0, 3+3)

	args = append(args, name)
	args = append(args, segments)
	args = append(args, diameter)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := m.p.Call("CreateSphere", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshCreateTiledGroundOpts contains optional parameters for Mesh.CreateTiledGround.
type MeshCreateTiledGroundOpts struct {
	Updatable *bool
}

// CreateTiledGround calls the CreateTiledGround method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createtiledground
func (m *Mesh) CreateTiledGround(name string, xmin float64, zmin float64, xmax float64, zmax float64, subdivisions js.Value, precision js.Value, scene *Scene, opts *MeshCreateTiledGroundOpts) *Mesh {
	if opts == nil {
		opts = &MeshCreateTiledGroundOpts{}
	}

	args := make([]interface{}, 0, 8+1)

	args = append(args, name)
	args = append(args, xmin)
	args = append(args, zmin)
	args = append(args, xmax)
	args = append(args, zmax)
	args = append(args, subdivisions)
	args = append(args, precision)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}

	retVal := m.p.Call("CreateTiledGround", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshCreateTorusOpts contains optional parameters for Mesh.CreateTorus.
type MeshCreateTorusOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateTorus calls the CreateTorus method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createtorus
func (m *Mesh) CreateTorus(name string, diameter float64, thickness float64, tessellation float64, opts *MeshCreateTorusOpts) *Mesh {
	if opts == nil {
		opts = &MeshCreateTorusOpts{}
	}

	args := make([]interface{}, 0, 4+3)

	args = append(args, name)
	args = append(args, diameter)
	args = append(args, thickness)
	args = append(args, tessellation)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := m.p.Call("CreateTorus", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshCreateTorusKnotOpts contains optional parameters for Mesh.CreateTorusKnot.
type MeshCreateTorusKnotOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
}

// CreateTorusKnot calls the CreateTorusKnot method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createtorusknot
func (m *Mesh) CreateTorusKnot(name string, radius float64, tube float64, radialSegments float64, tubularSegments float64, p float64, q float64, opts *MeshCreateTorusKnotOpts) *Mesh {
	if opts == nil {
		opts = &MeshCreateTorusKnotOpts{}
	}

	args := make([]interface{}, 0, 7+3)

	args = append(args, name)
	args = append(args, radius)
	args = append(args, tube)
	args = append(args, radialSegments)
	args = append(args, tubularSegments)
	args = append(args, p)
	args = append(args, q)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}

	retVal := m.p.Call("CreateTorusKnot", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshCreateTubeOpts contains optional parameters for Mesh.CreateTube.
type MeshCreateTubeOpts struct {
	Updatable       *bool
	SideOrientation *float64
	Instance        *Mesh
}

// CreateTube calls the CreateTube method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#createtube
func (m *Mesh) CreateTube(name string, path *Vector3, radius float64, tessellation float64, radiusFunction func(), cap float64, scene *Scene, opts *MeshCreateTubeOpts) *Mesh {
	if opts == nil {
		opts = &MeshCreateTubeOpts{}
	}

	args := make([]interface{}, 0, 7+3)

	args = append(args, name)
	args = append(args, path.JSObject())
	args = append(args, radius)
	args = append(args, tessellation)
	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { radiusFunction(); return nil }))
	args = append(args, cap)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := m.p.Call("CreateTube", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshDisposeOpts contains optional parameters for Mesh.Dispose.
type MeshDisposeOpts struct {
	DoNotRecurse               *bool
	DisposeMaterialAndTextures *bool
}

// Dispose calls the Dispose method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#dispose
func (m *Mesh) Dispose(opts *MeshDisposeOpts) {
	if opts == nil {
		opts = &MeshDisposeOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.DoNotRecurse == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotRecurse)
	}
	if opts.DisposeMaterialAndTextures == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DisposeMaterialAndTextures)
	}

	m.p.Call("dispose", args...)
}

// MeshExtrudePolygonOpts contains optional parameters for Mesh.ExtrudePolygon.
type MeshExtrudePolygonOpts struct {
	Holes           *Vector3
	Updatable       *bool
	SideOrientation *float64
	EarcutInjection *interface{}
}

// ExtrudePolygon calls the ExtrudePolygon method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#extrudepolygon
func (m *Mesh) ExtrudePolygon(name string, shape *Vector3, depth float64, scene *Scene, opts *MeshExtrudePolygonOpts) *Mesh {
	if opts == nil {
		opts = &MeshExtrudePolygonOpts{}
	}

	args := make([]interface{}, 0, 4+4)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, depth)
	args = append(args, scene.JSObject())

	if opts.Holes == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Holes.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.EarcutInjection == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.EarcutInjection)
	}

	retVal := m.p.Call("ExtrudePolygon", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshExtrudeShapeOpts contains optional parameters for Mesh.ExtrudeShape.
type MeshExtrudeShapeOpts struct {
	Scene           *Scene
	Updatable       *bool
	SideOrientation *float64
	Instance        *Mesh
}

// ExtrudeShape calls the ExtrudeShape method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#extrudeshape
func (m *Mesh) ExtrudeShape(name string, shape *Vector3, path *Vector3, scale float64, rotation float64, cap float64, opts *MeshExtrudeShapeOpts) *Mesh {
	if opts == nil {
		opts = &MeshExtrudeShapeOpts{}
	}

	args := make([]interface{}, 0, 6+4)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, path.JSObject())
	args = append(args, scale)
	args = append(args, rotation)
	args = append(args, cap)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := m.p.Call("ExtrudeShape", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshExtrudeShapeCustomOpts contains optional parameters for Mesh.ExtrudeShapeCustom.
type MeshExtrudeShapeCustomOpts struct {
	Updatable       *bool
	SideOrientation *float64
	Instance        *Mesh
}

// ExtrudeShapeCustom calls the ExtrudeShapeCustom method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#extrudeshapecustom
func (m *Mesh) ExtrudeShapeCustom(name string, shape *Vector3, path *Vector3, scaleFunction func(), rotationFunction func(), ribbonCloseArray bool, ribbonClosePath bool, cap float64, scene *Scene, opts *MeshExtrudeShapeCustomOpts) *Mesh {
	if opts == nil {
		opts = &MeshExtrudeShapeCustomOpts{}
	}

	args := make([]interface{}, 0, 9+3)

	args = append(args, name)
	args = append(args, shape.JSObject())
	args = append(args, path.JSObject())
	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { scaleFunction(); return nil }))
	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { rotationFunction(); return nil }))
	args = append(args, ribbonCloseArray)
	args = append(args, ribbonClosePath)
	args = append(args, cap)
	args = append(args, scene.JSObject())

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.SideOrientation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SideOrientation)
	}
	if opts.Instance == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Instance.JSObject())
	}

	retVal := m.p.Call("ExtrudeShapeCustom", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshFlipFacesOpts contains optional parameters for Mesh.FlipFaces.
type MeshFlipFacesOpts struct {
	FlipNormals *bool
}

// FlipFaces calls the FlipFaces method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#flipfaces
func (m *Mesh) FlipFaces(opts *MeshFlipFacesOpts) *Mesh {
	if opts == nil {
		opts = &MeshFlipFacesOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.FlipNormals == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FlipNormals)
	}

	retVal := m.p.Call("flipFaces", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// ForceSharedVertices calls the ForceSharedVertices method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#forcesharedvertices
func (m *Mesh) ForceSharedVertices() {

	m.p.Call("forceSharedVertices")
}

// FreezeNormals calls the FreezeNormals method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#freezenormals
func (m *Mesh) FreezeNormals() *Mesh {

	retVal := m.p.Call("freezeNormals")
	return MeshFromJSObject(retVal, m.ctx)
}

// GetAnimatables calls the GetAnimatables method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#getanimatables
func (m *Mesh) GetAnimatables() *IAnimatable {

	retVal := m.p.Call("getAnimatables")
	return IAnimatableFromJSObject(retVal, m.ctx)
}

// GetClassName calls the GetClassName method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#getclassname
func (m *Mesh) GetClassName() string {

	retVal := m.p.Call("getClassName")
	return retVal.String()
}

// GetEmittedParticleSystems calls the GetEmittedParticleSystems method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#getemittedparticlesystems
func (m *Mesh) GetEmittedParticleSystems() *IParticleSystem {

	retVal := m.p.Call("getEmittedParticleSystems")
	return IParticleSystemFromJSObject(retVal, m.ctx)
}

// GetHierarchyEmittedParticleSystems calls the GetHierarchyEmittedParticleSystems method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#gethierarchyemittedparticlesystems
func (m *Mesh) GetHierarchyEmittedParticleSystems() *IParticleSystem {

	retVal := m.p.Call("getHierarchyEmittedParticleSystems")
	return IParticleSystemFromJSObject(retVal, m.ctx)
}

// MeshGetIndicesOpts contains optional parameters for Mesh.GetIndices.
type MeshGetIndicesOpts struct {
	CopyWhenShared *bool
	ForceCopy      *bool
}

// GetIndices calls the GetIndices method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#getindices
func (m *Mesh) GetIndices(opts *MeshGetIndicesOpts) js.Value {
	if opts == nil {
		opts = &MeshGetIndicesOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.CopyWhenShared == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CopyWhenShared)
	}
	if opts.ForceCopy == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceCopy)
	}

	retVal := m.p.Call("getIndices", args...)
	return retVal
}

// MeshGetLODOpts contains optional parameters for Mesh.GetLOD.
type MeshGetLODOpts struct {
	BoundingSphere *BoundingSphere
}

// GetLOD calls the GetLOD method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#getlod
func (m *Mesh) GetLOD(camera *Camera, opts *MeshGetLODOpts) *AbstractMesh {
	if opts == nil {
		opts = &MeshGetLODOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, camera.JSObject())

	if opts.BoundingSphere == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.BoundingSphere.JSObject())
	}

	retVal := m.p.Call("getLOD", args...)
	return AbstractMeshFromJSObject(retVal, m.ctx)
}

// GetLODLevelAtDistance calls the GetLODLevelAtDistance method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#getlodlevelatdistance
func (m *Mesh) GetLODLevelAtDistance(distance float64) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, distance)

	retVal := m.p.Call("getLODLevelAtDistance", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// GetLODLevels calls the GetLODLevels method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#getlodlevels
func (m *Mesh) GetLODLevels() *MeshLODLevel {

	retVal := m.p.Call("getLODLevels")
	return MeshLODLevelFromJSObject(retVal, m.ctx)
}

// GetTotalIndices calls the GetTotalIndices method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#gettotalindices
func (m *Mesh) GetTotalIndices() float64 {

	retVal := m.p.Call("getTotalIndices")
	return retVal.Float()
}

// GetTotalVertices calls the GetTotalVertices method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#gettotalvertices
func (m *Mesh) GetTotalVertices() float64 {

	retVal := m.p.Call("getTotalVertices")
	return retVal.Float()
}

// GetVertexBuffer calls the GetVertexBuffer method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#getvertexbuffer
func (m *Mesh) GetVertexBuffer(kind string) *VertexBuffer {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	retVal := m.p.Call("getVertexBuffer", args...)
	return VertexBufferFromJSObject(retVal, m.ctx)
}

// MeshGetVerticesDataOpts contains optional parameters for Mesh.GetVerticesData.
type MeshGetVerticesDataOpts struct {
	CopyWhenShared *bool
	ForceCopy      *bool
}

// GetVerticesData calls the GetVerticesData method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#getverticesdata
func (m *Mesh) GetVerticesData(kind string, opts *MeshGetVerticesDataOpts) js.Value {
	if opts == nil {
		opts = &MeshGetVerticesDataOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, kind)

	if opts.CopyWhenShared == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CopyWhenShared)
	}
	if opts.ForceCopy == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceCopy)
	}

	retVal := m.p.Call("getVerticesData", args...)
	return retVal
}

// GetVerticesDataKinds calls the GetVerticesDataKinds method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#getverticesdatakinds
func (m *Mesh) GetVerticesDataKinds() string {

	retVal := m.p.Call("getVerticesDataKinds")
	return retVal.String()
}

// IncreaseVertices calls the IncreaseVertices method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#increasevertices
func (m *Mesh) IncreaseVertices(numberPerEdge float64) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, numberPerEdge)

	m.p.Call("increaseVertices", args...)
}

// MeshInstantiateHierarchyOpts contains optional parameters for Mesh.InstantiateHierarchy.
type MeshInstantiateHierarchyOpts struct {
	NewParent        *TransformNode
	Options          map[string]interface{}
	OnNewNodeCreated func()
}

// InstantiateHierarchy calls the InstantiateHierarchy method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#instantiatehierarchy
func (m *Mesh) InstantiateHierarchy(opts *MeshInstantiateHierarchyOpts) *TransformNode {
	if opts == nil {
		opts = &MeshInstantiateHierarchyOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.NewParent == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.NewParent.JSObject())
	}
	if opts.Options == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Options)
	}
	if opts.OnNewNodeCreated == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OnNewNodeCreated(); return nil }) /* never freed! */)
	}

	retVal := m.p.Call("instantiateHierarchy", args...)
	return TransformNodeFromJSObject(retVal, m.ctx)
}

// IsInFrustum calls the IsInFrustum method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#isinfrustum
func (m *Mesh) IsInFrustum(frustumPlanes *Plane) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, frustumPlanes.JSObject())

	retVal := m.p.Call("isInFrustum", args...)
	return retVal.Bool()
}

// MeshIsReadyOpts contains optional parameters for Mesh.IsReady.
type MeshIsReadyOpts struct {
	CompleteCheck        *bool
	ForceInstanceSupport *bool
}

// IsReady calls the IsReady method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#isready
func (m *Mesh) IsReady(opts *MeshIsReadyOpts) bool {
	if opts == nil {
		opts = &MeshIsReadyOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.CompleteCheck == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CompleteCheck)
	}
	if opts.ForceInstanceSupport == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ForceInstanceSupport)
	}

	retVal := m.p.Call("isReady", args...)
	return retVal.Bool()
}

// IsVertexBufferUpdatable calls the IsVertexBufferUpdatable method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#isvertexbufferupdatable
func (m *Mesh) IsVertexBufferUpdatable(kind string) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	retVal := m.p.Call("isVertexBufferUpdatable", args...)
	return retVal.Bool()
}

// IsVerticesDataPresent calls the IsVerticesDataPresent method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#isverticesdatapresent
func (m *Mesh) IsVerticesDataPresent(kind string) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	retVal := m.p.Call("isVerticesDataPresent", args...)
	return retVal.Bool()
}

// MakeGeometryUnique calls the MakeGeometryUnique method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#makegeometryunique
func (m *Mesh) MakeGeometryUnique() *Mesh {

	retVal := m.p.Call("makeGeometryUnique")
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshMarkVerticesDataAsUpdatableOpts contains optional parameters for Mesh.MarkVerticesDataAsUpdatable.
type MeshMarkVerticesDataAsUpdatableOpts struct {
	Updatable *bool
}

// MarkVerticesDataAsUpdatable calls the MarkVerticesDataAsUpdatable method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#markverticesdataasupdatable
func (m *Mesh) MarkVerticesDataAsUpdatable(kind string, opts *MeshMarkVerticesDataAsUpdatableOpts) {
	if opts == nil {
		opts = &MeshMarkVerticesDataAsUpdatableOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, kind)

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}

	m.p.Call("markVerticesDataAsUpdatable", args...)
}

// MeshMergeMeshesOpts contains optional parameters for Mesh.MergeMeshes.
type MeshMergeMeshesOpts struct {
	DisposeSource          *bool
	Allow32BitsIndices     *bool
	MeshSubclass           *Mesh
	SubdivideWithSubMeshes *bool
	MultiMultiMaterials    *bool
}

// MergeMeshes calls the MergeMeshes method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#mergemeshes
func (m *Mesh) MergeMeshes(meshes []*Mesh, opts *MeshMergeMeshesOpts) *Mesh {
	if opts == nil {
		opts = &MeshMergeMeshesOpts{}
	}

	args := make([]interface{}, 0, 1+5)

	args = append(args, MeshArrayToJSArray(meshes))

	if opts.DisposeSource == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DisposeSource)
	}
	if opts.Allow32BitsIndices == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Allow32BitsIndices)
	}
	if opts.MeshSubclass == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.MeshSubclass.JSObject())
	}
	if opts.SubdivideWithSubMeshes == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.SubdivideWithSubMeshes)
	}
	if opts.MultiMultiMaterials == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MultiMultiMaterials)
	}

	retVal := m.p.Call("MergeMeshes", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MinMax calls the MinMax method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#minmax
func (m *Mesh) MinMax(meshes *AbstractMesh) js.Value {

	args := make([]interface{}, 0, 1+0)

	args = append(args, meshes.JSObject())

	retVal := m.p.Call("MinMax", args...)
	return retVal
}

// MeshOptimizeIndicesOpts contains optional parameters for Mesh.OptimizeIndices.
type MeshOptimizeIndicesOpts struct {
	SuccessCallback func()
}

// OptimizeIndices calls the OptimizeIndices method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#optimizeindices
func (m *Mesh) OptimizeIndices(opts *MeshOptimizeIndicesOpts) *Mesh {
	if opts == nil {
		opts = &MeshOptimizeIndicesOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.SuccessCallback == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.SuccessCallback(); return nil }) /* never freed! */)
	}

	retVal := m.p.Call("optimizeIndices", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// Parse calls the Parse method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#parse
func (m *Mesh) Parse(parsedMesh interface{}, scene *Scene, rootUrl string) *Mesh {

	args := make([]interface{}, 0, 3+0)

	args = append(args, parsedMesh)
	args = append(args, scene.JSObject())
	args = append(args, rootUrl)

	retVal := m.p.Call("Parse", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshRefreshBoundingInfoOpts contains optional parameters for Mesh.RefreshBoundingInfo.
type MeshRefreshBoundingInfoOpts struct {
	ApplySkeleton *bool
}

// RefreshBoundingInfo calls the RefreshBoundingInfo method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#refreshboundinginfo
func (m *Mesh) RefreshBoundingInfo(opts *MeshRefreshBoundingInfoOpts) *Mesh {
	if opts == nil {
		opts = &MeshRefreshBoundingInfoOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.ApplySkeleton == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ApplySkeleton)
	}

	retVal := m.p.Call("refreshBoundingInfo", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// RegisterAfterRender calls the RegisterAfterRender method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#registerafterrender
func (m *Mesh) RegisterAfterRender(jsFunc func()) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	retVal := m.p.Call("registerAfterRender", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// RegisterBeforeRender calls the RegisterBeforeRender method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#registerbeforerender
func (m *Mesh) RegisterBeforeRender(jsFunc func()) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	retVal := m.p.Call("registerBeforeRender", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// RegisterInstancedBuffer calls the RegisterInstancedBuffer method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#registerinstancedbuffer
func (m *Mesh) RegisterInstancedBuffer(kind string, stride float64) {

	args := make([]interface{}, 0, 2+0)

	args = append(args, kind)
	args = append(args, stride)

	m.p.Call("registerInstancedBuffer", args...)
}

// RemoveLODLevel calls the RemoveLODLevel method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#removelodlevel
func (m *Mesh) RemoveLODLevel(mesh *Mesh) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, mesh.JSObject())

	retVal := m.p.Call("removeLODLevel", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// RemoveVerticesData calls the RemoveVerticesData method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#removeverticesdata
func (m *Mesh) RemoveVerticesData(kind string) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	m.p.Call("removeVerticesData", args...)
}

// MeshRenderOpts contains optional parameters for Mesh.Render.
type MeshRenderOpts struct {
	EffectiveMeshReplacement *AbstractMesh
}

// Render calls the Render method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#render
func (m *Mesh) Render(subMesh *SubMesh, enableAlphaMode bool, opts *MeshRenderOpts) *Mesh {
	if opts == nil {
		opts = &MeshRenderOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, subMesh.JSObject())
	args = append(args, enableAlphaMode)

	if opts.EffectiveMeshReplacement == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.EffectiveMeshReplacement.JSObject())
	}

	retVal := m.p.Call("render", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// Serialize calls the Serialize method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#serialize
func (m *Mesh) Serialize(serializationObject interface{}) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, serializationObject)

	m.p.Call("serialize", args...)
}

// MeshSetIndicesOpts contains optional parameters for Mesh.SetIndices.
type MeshSetIndicesOpts struct {
	TotalVertices *float64
	Updatable     *bool
}

// SetIndices calls the SetIndices method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#setindices
func (m *Mesh) SetIndices(indices js.Value, opts *MeshSetIndicesOpts) *AbstractMesh {
	if opts == nil {
		opts = &MeshSetIndicesOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, indices)

	if opts.TotalVertices == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.TotalVertices)
	}
	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}

	retVal := m.p.Call("setIndices", args...)
	return AbstractMeshFromJSObject(retVal, m.ctx)
}

// SetMaterialByID calls the SetMaterialByID method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#setmaterialbyid
func (m *Mesh) SetMaterialByID(id string) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, id)

	retVal := m.p.Call("setMaterialByID", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// SetNormalsForCPUSkinning calls the SetNormalsForCPUSkinning method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#setnormalsforcpuskinning
func (m *Mesh) SetNormalsForCPUSkinning() js.Value {

	retVal := m.p.Call("setNormalsForCPUSkinning")
	return retVal
}

// SetPositionsForCPUSkinning calls the SetPositionsForCPUSkinning method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#setpositionsforcpuskinning
func (m *Mesh) SetPositionsForCPUSkinning() js.Value {

	retVal := m.p.Call("setPositionsForCPUSkinning")
	return retVal
}

// SetVerticesBuffer calls the SetVerticesBuffer method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#setverticesbuffer
func (m *Mesh) SetVerticesBuffer(buffer *VertexBuffer) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, buffer.JSObject())

	retVal := m.p.Call("setVerticesBuffer", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshSetVerticesDataOpts contains optional parameters for Mesh.SetVerticesData.
type MeshSetVerticesDataOpts struct {
	Updatable *bool
	Stride    *float64
}

// SetVerticesData calls the SetVerticesData method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#setverticesdata
func (m *Mesh) SetVerticesData(kind string, data js.Value, opts *MeshSetVerticesDataOpts) *AbstractMesh {
	if opts == nil {
		opts = &MeshSetVerticesDataOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, kind)
	args = append(args, data)

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.Stride == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Stride)
	}

	retVal := m.p.Call("setVerticesData", args...)
	return AbstractMeshFromJSObject(retVal, m.ctx)
}

// MeshSimplifyOpts contains optional parameters for Mesh.Simplify.
type MeshSimplifyOpts struct {
	ParallelProcessing *bool
	SimplificationType js.Value
	SuccessCallback    func()
}

// Simplify calls the Simplify method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#simplify
func (m *Mesh) Simplify(settings []*ISimplificationSettings, opts *MeshSimplifyOpts) *Mesh {
	if opts == nil {
		opts = &MeshSimplifyOpts{}
	}

	args := make([]interface{}, 0, 1+3)

	args = append(args, ISimplificationSettingsArrayToJSArray(settings))

	if opts.ParallelProcessing == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ParallelProcessing)
	}
	args = append(args, opts.SimplificationType)
	if opts.SuccessCallback == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.SuccessCallback(); return nil }) /* never freed! */)
	}

	retVal := m.p.Call("simplify", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// Subdivide calls the Subdivide method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#subdivide
func (m *Mesh) Subdivide(count float64) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, count)

	m.p.Call("subdivide", args...)
}

// SynchronizeInstances calls the SynchronizeInstances method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#synchronizeinstances
func (m *Mesh) SynchronizeInstances() *Mesh {

	retVal := m.p.Call("synchronizeInstances")
	return MeshFromJSObject(retVal, m.ctx)
}

// ToLeftHanded calls the ToLeftHanded method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#tolefthanded
func (m *Mesh) ToLeftHanded() *Mesh {

	retVal := m.p.Call("toLeftHanded")
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshToStringOpts contains optional parameters for Mesh.ToString.
type MeshToStringOpts struct {
	FullDetails *bool
}

// ToString calls the ToString method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#tostring
func (m *Mesh) ToString(opts *MeshToStringOpts) string {
	if opts == nil {
		opts = &MeshToStringOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.FullDetails == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FullDetails)
	}

	retVal := m.p.Call("toString", args...)
	return retVal.String()
}

// UnfreezeNormals calls the UnfreezeNormals method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#unfreezenormals
func (m *Mesh) UnfreezeNormals() *Mesh {

	retVal := m.p.Call("unfreezeNormals")
	return MeshFromJSObject(retVal, m.ctx)
}

// UnregisterAfterRender calls the UnregisterAfterRender method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#unregisterafterrender
func (m *Mesh) UnregisterAfterRender(jsFunc func()) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	retVal := m.p.Call("unregisterAfterRender", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// UnregisterBeforeRender calls the UnregisterBeforeRender method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#unregisterbeforerender
func (m *Mesh) UnregisterBeforeRender(jsFunc func()) *Mesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	retVal := m.p.Call("unregisterBeforeRender", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshUpdateIndicesOpts contains optional parameters for Mesh.UpdateIndices.
type MeshUpdateIndicesOpts struct {
	Offset        *float64
	GpuMemoryOnly *bool
}

// UpdateIndices calls the UpdateIndices method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#updateindices
func (m *Mesh) UpdateIndices(indices js.Value, opts *MeshUpdateIndicesOpts) *AbstractMesh {
	if opts == nil {
		opts = &MeshUpdateIndicesOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, indices)

	if opts.Offset == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Offset)
	}
	if opts.GpuMemoryOnly == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.GpuMemoryOnly)
	}

	retVal := m.p.Call("updateIndices", args...)
	return AbstractMeshFromJSObject(retVal, m.ctx)
}

// MeshUpdateMeshPositionsOpts contains optional parameters for Mesh.UpdateMeshPositions.
type MeshUpdateMeshPositionsOpts struct {
	ComputeNormals *bool
}

// UpdateMeshPositions calls the UpdateMeshPositions method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#updatemeshpositions
func (m *Mesh) UpdateMeshPositions(positionFunction func(), opts *MeshUpdateMeshPositionsOpts) *Mesh {
	if opts == nil {
		opts = &MeshUpdateMeshPositionsOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { positionFunction(); return nil }))

	if opts.ComputeNormals == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ComputeNormals)
	}

	retVal := m.p.Call("updateMeshPositions", args...)
	return MeshFromJSObject(retVal, m.ctx)
}

// MeshUpdateVerticesDataOpts contains optional parameters for Mesh.UpdateVerticesData.
type MeshUpdateVerticesDataOpts struct {
	UpdateExtends *bool
	MakeItUnique  *bool
}

// UpdateVerticesData calls the UpdateVerticesData method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#updateverticesdata
func (m *Mesh) UpdateVerticesData(kind string, data js.Value, opts *MeshUpdateVerticesDataOpts) *AbstractMesh {
	if opts == nil {
		opts = &MeshUpdateVerticesDataOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, kind)
	args = append(args, data)

	if opts.UpdateExtends == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UpdateExtends)
	}
	if opts.MakeItUnique == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MakeItUnique)
	}

	retVal := m.p.Call("updateVerticesData", args...)
	return AbstractMeshFromJSObject(retVal, m.ctx)
}

// ValidateSkinning calls the ValidateSkinning method on the Mesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#validateskinning
func (m *Mesh) ValidateSkinning() js.Value {

	retVal := m.p.Call("validateSkinning")
	return retVal
}

// AreNormalsFrozen returns the AreNormalsFrozen property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#arenormalsfrozen
func (m *Mesh) AreNormalsFrozen() bool {
	retVal := m.p.Get("areNormalsFrozen")
	return retVal.Bool()
}

// SetAreNormalsFrozen sets the AreNormalsFrozen property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#arenormalsfrozen
func (m *Mesh) SetAreNormalsFrozen(areNormalsFrozen bool) *Mesh {
	m.p.Set("areNormalsFrozen", areNormalsFrozen)
	return m
}

// BACKSIDE returns the BACKSIDE property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#backside
func (m *Mesh) BACKSIDE() float64 {
	retVal := m.p.Get("BACKSIDE")
	return retVal.Float()
}

// SetBACKSIDE sets the BACKSIDE property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#backside
func (m *Mesh) SetBACKSIDE(BACKSIDE float64) *Mesh {
	m.p.Set("BACKSIDE", BACKSIDE)
	return m
}

// BOTTOM returns the BOTTOM property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#bottom
func (m *Mesh) BOTTOM() float64 {
	retVal := m.p.Get("BOTTOM")
	return retVal.Float()
}

// SetBOTTOM sets the BOTTOM property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#bottom
func (m *Mesh) SetBOTTOM(BOTTOM float64) *Mesh {
	m.p.Set("BOTTOM", BOTTOM)
	return m
}

// CAP_ALL returns the CAP_ALL property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#cap_all
func (m *Mesh) CAP_ALL() float64 {
	retVal := m.p.Get("CAP_ALL")
	return retVal.Float()
}

// SetCAP_ALL sets the CAP_ALL property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#cap_all
func (m *Mesh) SetCAP_ALL(CAP_ALL float64) *Mesh {
	m.p.Set("CAP_ALL", CAP_ALL)
	return m
}

// CAP_END returns the CAP_END property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#cap_end
func (m *Mesh) CAP_END() float64 {
	retVal := m.p.Get("CAP_END")
	return retVal.Float()
}

// SetCAP_END sets the CAP_END property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#cap_end
func (m *Mesh) SetCAP_END(CAP_END float64) *Mesh {
	m.p.Set("CAP_END", CAP_END)
	return m
}

// CAP_START returns the CAP_START property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#cap_start
func (m *Mesh) CAP_START() float64 {
	retVal := m.p.Get("CAP_START")
	return retVal.Float()
}

// SetCAP_START sets the CAP_START property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#cap_start
func (m *Mesh) SetCAP_START(CAP_START float64) *Mesh {
	m.p.Set("CAP_START", CAP_START)
	return m
}

// CENTER returns the CENTER property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#center
func (m *Mesh) CENTER() float64 {
	retVal := m.p.Get("CENTER")
	return retVal.Float()
}

// SetCENTER sets the CENTER property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#center
func (m *Mesh) SetCENTER(CENTER float64) *Mesh {
	m.p.Set("CENTER", CENTER)
	return m
}

// DEFAULTSIDE returns the DEFAULTSIDE property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#defaultside
func (m *Mesh) DEFAULTSIDE() float64 {
	retVal := m.p.Get("DEFAULTSIDE")
	return retVal.Float()
}

// SetDEFAULTSIDE sets the DEFAULTSIDE property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#defaultside
func (m *Mesh) SetDEFAULTSIDE(DEFAULTSIDE float64) *Mesh {
	m.p.Set("DEFAULTSIDE", DEFAULTSIDE)
	return m
}

// DOUBLESIDE returns the DOUBLESIDE property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#doubleside
func (m *Mesh) DOUBLESIDE() float64 {
	retVal := m.p.Get("DOUBLESIDE")
	return retVal.Float()
}

// SetDOUBLESIDE sets the DOUBLESIDE property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#doubleside
func (m *Mesh) SetDOUBLESIDE(DOUBLESIDE float64) *Mesh {
	m.p.Set("DOUBLESIDE", DOUBLESIDE)
	return m
}

// DelayLoadState returns the DelayLoadState property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#delayloadstate
func (m *Mesh) DelayLoadState() float64 {
	retVal := m.p.Get("delayLoadState")
	return retVal.Float()
}

// SetDelayLoadState sets the DelayLoadState property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#delayloadstate
func (m *Mesh) SetDelayLoadState(delayLoadState float64) *Mesh {
	m.p.Set("delayLoadState", delayLoadState)
	return m
}

// DelayLoadingFile returns the DelayLoadingFile property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#delayloadingfile
func (m *Mesh) DelayLoadingFile() string {
	retVal := m.p.Get("delayLoadingFile")
	return retVal.String()
}

// SetDelayLoadingFile sets the DelayLoadingFile property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#delayloadingfile
func (m *Mesh) SetDelayLoadingFile(delayLoadingFile string) *Mesh {
	m.p.Set("delayLoadingFile", delayLoadingFile)
	return m
}

// FLIP_N_ROTATE_ROW returns the FLIP_N_ROTATE_ROW property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#flip_n_rotate_row
func (m *Mesh) FLIP_N_ROTATE_ROW() float64 {
	retVal := m.p.Get("FLIP_N_ROTATE_ROW")
	return retVal.Float()
}

// SetFLIP_N_ROTATE_ROW sets the FLIP_N_ROTATE_ROW property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#flip_n_rotate_row
func (m *Mesh) SetFLIP_N_ROTATE_ROW(FLIP_N_ROTATE_ROW float64) *Mesh {
	m.p.Set("FLIP_N_ROTATE_ROW", FLIP_N_ROTATE_ROW)
	return m
}

// FLIP_N_ROTATE_TILE returns the FLIP_N_ROTATE_TILE property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#flip_n_rotate_tile
func (m *Mesh) FLIP_N_ROTATE_TILE() float64 {
	retVal := m.p.Get("FLIP_N_ROTATE_TILE")
	return retVal.Float()
}

// SetFLIP_N_ROTATE_TILE sets the FLIP_N_ROTATE_TILE property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#flip_n_rotate_tile
func (m *Mesh) SetFLIP_N_ROTATE_TILE(FLIP_N_ROTATE_TILE float64) *Mesh {
	m.p.Set("FLIP_N_ROTATE_TILE", FLIP_N_ROTATE_TILE)
	return m
}

// FLIP_ROW returns the FLIP_ROW property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#flip_row
func (m *Mesh) FLIP_ROW() float64 {
	retVal := m.p.Get("FLIP_ROW")
	return retVal.Float()
}

// SetFLIP_ROW sets the FLIP_ROW property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#flip_row
func (m *Mesh) SetFLIP_ROW(FLIP_ROW float64) *Mesh {
	m.p.Set("FLIP_ROW", FLIP_ROW)
	return m
}

// FLIP_TILE returns the FLIP_TILE property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#flip_tile
func (m *Mesh) FLIP_TILE() float64 {
	retVal := m.p.Get("FLIP_TILE")
	return retVal.Float()
}

// SetFLIP_TILE sets the FLIP_TILE property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#flip_tile
func (m *Mesh) SetFLIP_TILE(FLIP_TILE float64) *Mesh {
	m.p.Set("FLIP_TILE", FLIP_TILE)
	return m
}

// FRONTSIDE returns the FRONTSIDE property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#frontside
func (m *Mesh) FRONTSIDE() float64 {
	retVal := m.p.Get("FRONTSIDE")
	return retVal.Float()
}

// SetFRONTSIDE sets the FRONTSIDE property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#frontside
func (m *Mesh) SetFRONTSIDE(FRONTSIDE float64) *Mesh {
	m.p.Set("FRONTSIDE", FRONTSIDE)
	return m
}

// Geometry returns the Geometry property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#geometry
func (m *Mesh) Geometry() *Geometry {
	retVal := m.p.Get("geometry")
	return GeometryFromJSObject(retVal, m.ctx)
}

// SetGeometry sets the Geometry property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#geometry
func (m *Mesh) SetGeometry(geometry *Geometry) *Mesh {
	m.p.Set("geometry", geometry.JSObject())
	return m
}

// HasInstances returns the HasInstances property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#hasinstances
func (m *Mesh) HasInstances() bool {
	retVal := m.p.Get("hasInstances")
	return retVal.Bool()
}

// SetHasInstances sets the HasInstances property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#hasinstances
func (m *Mesh) SetHasInstances(hasInstances bool) *Mesh {
	m.p.Set("hasInstances", hasInstances)
	return m
}

// HasLODLevels returns the HasLODLevels property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#haslodlevels
func (m *Mesh) HasLODLevels() bool {
	retVal := m.p.Get("hasLODLevels")
	return retVal.Bool()
}

// SetHasLODLevels sets the HasLODLevels property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#haslodlevels
func (m *Mesh) SetHasLODLevels(hasLODLevels bool) *Mesh {
	m.p.Set("hasLODLevels", hasLODLevels)
	return m
}

// Instances returns the Instances property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#instances
func (m *Mesh) Instances() *InstancedMesh {
	retVal := m.p.Get("instances")
	return InstancedMeshFromJSObject(retVal, m.ctx)
}

// SetInstances sets the Instances property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#instances
func (m *Mesh) SetInstances(instances *InstancedMesh) *Mesh {
	m.p.Set("instances", instances.JSObject())
	return m
}

// IsBlocked returns the IsBlocked property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#isblocked
func (m *Mesh) IsBlocked() bool {
	retVal := m.p.Get("isBlocked")
	return retVal.Bool()
}

// SetIsBlocked sets the IsBlocked property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#isblocked
func (m *Mesh) SetIsBlocked(isBlocked bool) *Mesh {
	m.p.Set("isBlocked", isBlocked)
	return m
}

// IsUnIndexed returns the IsUnIndexed property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#isunindexed
func (m *Mesh) IsUnIndexed() bool {
	retVal := m.p.Get("isUnIndexed")
	return retVal.Bool()
}

// SetIsUnIndexed sets the IsUnIndexed property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#isunindexed
func (m *Mesh) SetIsUnIndexed(isUnIndexed bool) *Mesh {
	m.p.Set("isUnIndexed", isUnIndexed)
	return m
}

// LEFT returns the LEFT property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#left
func (m *Mesh) LEFT() float64 {
	retVal := m.p.Get("LEFT")
	return retVal.Float()
}

// SetLEFT sets the LEFT property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#left
func (m *Mesh) SetLEFT(LEFT float64) *Mesh {
	m.p.Set("LEFT", LEFT)
	return m
}

// ManualUpdateOfWorldMatrixInstancedBuffer returns the ManualUpdateOfWorldMatrixInstancedBuffer property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#manualupdateofworldmatrixinstancedbuffer
func (m *Mesh) ManualUpdateOfWorldMatrixInstancedBuffer() bool {
	retVal := m.p.Get("manualUpdateOfWorldMatrixInstancedBuffer")
	return retVal.Bool()
}

// SetManualUpdateOfWorldMatrixInstancedBuffer sets the ManualUpdateOfWorldMatrixInstancedBuffer property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#manualupdateofworldmatrixinstancedbuffer
func (m *Mesh) SetManualUpdateOfWorldMatrixInstancedBuffer(manualUpdateOfWorldMatrixInstancedBuffer bool) *Mesh {
	m.p.Set("manualUpdateOfWorldMatrixInstancedBuffer", manualUpdateOfWorldMatrixInstancedBuffer)
	return m
}

// MorphTargetManager returns the MorphTargetManager property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#morphtargetmanager
func (m *Mesh) MorphTargetManager() *MorphTargetManager {
	retVal := m.p.Get("morphTargetManager")
	return MorphTargetManagerFromJSObject(retVal, m.ctx)
}

// SetMorphTargetManager sets the MorphTargetManager property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#morphtargetmanager
func (m *Mesh) SetMorphTargetManager(morphTargetManager *MorphTargetManager) *Mesh {
	m.p.Set("morphTargetManager", morphTargetManager.JSObject())
	return m
}

// NO_CAP returns the NO_CAP property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#no_cap
func (m *Mesh) NO_CAP() float64 {
	retVal := m.p.Get("NO_CAP")
	return retVal.Float()
}

// SetNO_CAP sets the NO_CAP property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#no_cap
func (m *Mesh) SetNO_CAP(NO_CAP float64) *Mesh {
	m.p.Set("NO_CAP", NO_CAP)
	return m
}

// NO_FLIP returns the NO_FLIP property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#no_flip
func (m *Mesh) NO_FLIP() float64 {
	retVal := m.p.Get("NO_FLIP")
	return retVal.Float()
}

// SetNO_FLIP sets the NO_FLIP property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#no_flip
func (m *Mesh) SetNO_FLIP(NO_FLIP float64) *Mesh {
	m.p.Set("NO_FLIP", NO_FLIP)
	return m
}

// OnAfterRenderObservable returns the OnAfterRenderObservable property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#onafterrenderobservable
func (m *Mesh) OnAfterRenderObservable() *Observable {
	retVal := m.p.Get("onAfterRenderObservable")
	return ObservableFromJSObject(retVal, m.ctx)
}

// SetOnAfterRenderObservable sets the OnAfterRenderObservable property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#onafterrenderobservable
func (m *Mesh) SetOnAfterRenderObservable(onAfterRenderObservable *Observable) *Mesh {
	m.p.Set("onAfterRenderObservable", onAfterRenderObservable.JSObject())
	return m
}

// OnBeforeBindObservable returns the OnBeforeBindObservable property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#onbeforebindobservable
func (m *Mesh) OnBeforeBindObservable() *Observable {
	retVal := m.p.Get("onBeforeBindObservable")
	return ObservableFromJSObject(retVal, m.ctx)
}

// SetOnBeforeBindObservable sets the OnBeforeBindObservable property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#onbeforebindobservable
func (m *Mesh) SetOnBeforeBindObservable(onBeforeBindObservable *Observable) *Mesh {
	m.p.Set("onBeforeBindObservable", onBeforeBindObservable.JSObject())
	return m
}

// OnBeforeDraw returns the OnBeforeDraw property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#onbeforedraw
func (m *Mesh) OnBeforeDraw() js.Value {
	retVal := m.p.Get("onBeforeDraw")
	return retVal
}

// SetOnBeforeDraw sets the OnBeforeDraw property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#onbeforedraw
func (m *Mesh) SetOnBeforeDraw(onBeforeDraw func()) *Mesh {
	m.p.Set("onBeforeDraw", js.FuncOf(func(this js.Value, args []js.Value) interface{} { onBeforeDraw(); return nil }))
	return m
}

// OnBeforeDrawObservable returns the OnBeforeDrawObservable property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#onbeforedrawobservable
func (m *Mesh) OnBeforeDrawObservable() *Observable {
	retVal := m.p.Get("onBeforeDrawObservable")
	return ObservableFromJSObject(retVal, m.ctx)
}

// SetOnBeforeDrawObservable sets the OnBeforeDrawObservable property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#onbeforedrawobservable
func (m *Mesh) SetOnBeforeDrawObservable(onBeforeDrawObservable *Observable) *Mesh {
	m.p.Set("onBeforeDrawObservable", onBeforeDrawObservable.JSObject())
	return m
}

// OnBeforeRenderObservable returns the OnBeforeRenderObservable property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#onbeforerenderobservable
func (m *Mesh) OnBeforeRenderObservable() *Observable {
	retVal := m.p.Get("onBeforeRenderObservable")
	return ObservableFromJSObject(retVal, m.ctx)
}

// SetOnBeforeRenderObservable sets the OnBeforeRenderObservable property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#onbeforerenderobservable
func (m *Mesh) SetOnBeforeRenderObservable(onBeforeRenderObservable *Observable) *Mesh {
	m.p.Set("onBeforeRenderObservable", onBeforeRenderObservable.JSObject())
	return m
}

// OnLODLevelSelection returns the OnLODLevelSelection property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#onlodlevelselection
func (m *Mesh) OnLODLevelSelection() js.Value {
	retVal := m.p.Get("onLODLevelSelection")
	return retVal
}

// SetOnLODLevelSelection sets the OnLODLevelSelection property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#onlodlevelselection
func (m *Mesh) SetOnLODLevelSelection(onLODLevelSelection func()) *Mesh {
	m.p.Set("onLODLevelSelection", js.FuncOf(func(this js.Value, args []js.Value) interface{} { onLODLevelSelection(); return nil }))
	return m
}

// OverrideMaterialSideOrientation returns the OverrideMaterialSideOrientation property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#overridematerialsideorientation
func (m *Mesh) OverrideMaterialSideOrientation() float64 {
	retVal := m.p.Get("overrideMaterialSideOrientation")
	return retVal.Float()
}

// SetOverrideMaterialSideOrientation sets the OverrideMaterialSideOrientation property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#overridematerialsideorientation
func (m *Mesh) SetOverrideMaterialSideOrientation(overrideMaterialSideOrientation float64) *Mesh {
	m.p.Set("overrideMaterialSideOrientation", overrideMaterialSideOrientation)
	return m
}

// OverridenInstanceCount returns the OverridenInstanceCount property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#overrideninstancecount
func (m *Mesh) OverridenInstanceCount() float64 {
	retVal := m.p.Get("overridenInstanceCount")
	return retVal.Float()
}

// SetOverridenInstanceCount sets the OverridenInstanceCount property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#overrideninstancecount
func (m *Mesh) SetOverridenInstanceCount(overridenInstanceCount float64) *Mesh {
	m.p.Set("overridenInstanceCount", overridenInstanceCount)
	return m
}

// RIGHT returns the RIGHT property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#right
func (m *Mesh) RIGHT() float64 {
	retVal := m.p.Get("RIGHT")
	return retVal.Float()
}

// SetRIGHT sets the RIGHT property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#right
func (m *Mesh) SetRIGHT(RIGHT float64) *Mesh {
	m.p.Set("RIGHT", RIGHT)
	return m
}

// ROTATE_ROW returns the ROTATE_ROW property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#rotate_row
func (m *Mesh) ROTATE_ROW() float64 {
	retVal := m.p.Get("ROTATE_ROW")
	return retVal.Float()
}

// SetROTATE_ROW sets the ROTATE_ROW property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#rotate_row
func (m *Mesh) SetROTATE_ROW(ROTATE_ROW float64) *Mesh {
	m.p.Set("ROTATE_ROW", ROTATE_ROW)
	return m
}

// ROTATE_TILE returns the ROTATE_TILE property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#rotate_tile
func (m *Mesh) ROTATE_TILE() float64 {
	retVal := m.p.Get("ROTATE_TILE")
	return retVal.Float()
}

// SetROTATE_TILE sets the ROTATE_TILE property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#rotate_tile
func (m *Mesh) SetROTATE_TILE(ROTATE_TILE float64) *Mesh {
	m.p.Set("ROTATE_TILE", ROTATE_TILE)
	return m
}

// Source returns the Source property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#source
func (m *Mesh) Source() *Mesh {
	retVal := m.p.Get("source")
	return MeshFromJSObject(retVal, m.ctx)
}

// SetSource sets the Source property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#source
func (m *Mesh) SetSource(source *Mesh) *Mesh {
	m.p.Set("source", source.JSObject())
	return m
}

// TOP returns the TOP property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#top
func (m *Mesh) TOP() float64 {
	retVal := m.p.Get("TOP")
	return retVal.Float()
}

// SetTOP sets the TOP property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#top
func (m *Mesh) SetTOP(TOP float64) *Mesh {
	m.p.Set("TOP", TOP)
	return m
}

// WorldMatrixInstancedBuffer returns the WorldMatrixInstancedBuffer property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#worldmatrixinstancedbuffer
func (m *Mesh) WorldMatrixInstancedBuffer() js.Value {
	retVal := m.p.Get("worldMatrixInstancedBuffer")
	return retVal
}

// SetWorldMatrixInstancedBuffer sets the WorldMatrixInstancedBuffer property of class Mesh.
//
// https://doc.babylonjs.com/api/classes/babylon.mesh#worldmatrixinstancedbuffer
func (m *Mesh) SetWorldMatrixInstancedBuffer(worldMatrixInstancedBuffer js.Value) *Mesh {
	m.p.Set("worldMatrixInstancedBuffer", worldMatrixInstancedBuffer)
	return m
}

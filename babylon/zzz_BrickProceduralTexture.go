// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// BrickProceduralTexture represents a babylon.js BrickProceduralTexture.
//
type BrickProceduralTexture struct {
	*ProceduralTexture
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (b *BrickProceduralTexture) JSObject() js.Value { return b.p }

// BrickProceduralTexture returns a BrickProceduralTexture JavaScript class.
func (ba *Babylon) BrickProceduralTexture() *BrickProceduralTexture {
	p := ba.ctx.Get("BrickProceduralTexture")
	return BrickProceduralTextureFromJSObject(p, ba.ctx)
}

// BrickProceduralTextureFromJSObject returns a wrapped BrickProceduralTexture JavaScript class.
func BrickProceduralTextureFromJSObject(p js.Value, ctx js.Value) *BrickProceduralTexture {
	return &BrickProceduralTexture{ProceduralTexture: ProceduralTextureFromJSObject(p, ctx), ctx: ctx}
}

// BrickProceduralTextureArrayToJSArray returns a JavaScript Array for the wrapped array.
func BrickProceduralTextureArrayToJSArray(array []*BrickProceduralTexture) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewBrickProceduralTextureOpts contains optional parameters for NewBrickProceduralTexture.
type NewBrickProceduralTextureOpts struct {
	FallbackTexture *Texture
	GenerateMipMaps *bool
}

// NewBrickProceduralTexture returns a new BrickProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.brickproceduraltexture
func (ba *Babylon) NewBrickProceduralTexture(name string, size float64, scene *Scene, opts *NewBrickProceduralTextureOpts) *BrickProceduralTexture {
	if opts == nil {
		opts = &NewBrickProceduralTextureOpts{}
	}

	args := make([]interface{}, 0, 3+2)

	args = append(args, name)
	args = append(args, size)
	args = append(args, scene.JSObject())

	if opts.FallbackTexture == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.FallbackTexture.JSObject())
	}
	if opts.GenerateMipMaps == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.GenerateMipMaps)
	}

	p := ba.ctx.Get("BrickProceduralTexture").New(args...)
	return BrickProceduralTextureFromJSObject(p, ba.ctx)
}

// Parse calls the Parse method on the BrickProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.brickproceduraltexture#parse
func (b *BrickProceduralTexture) Parse(parsedTexture JSObject, scene *Scene, rootUrl string) *BrickProceduralTexture {

	args := make([]interface{}, 0, 3+0)

	if parsedTexture == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, parsedTexture.JSObject())
	}

	if scene == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, scene.JSObject())
	}

	args = append(args, rootUrl)

	retVal := b.p.Call("Parse", args...)
	return BrickProceduralTextureFromJSObject(retVal, b.ctx)
}

// Serialize calls the Serialize method on the BrickProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.brickproceduraltexture#serialize
func (b *BrickProceduralTexture) Serialize() js.Value {

	retVal := b.p.Call("serialize")
	return retVal
}

// UpdateShaderUniforms calls the UpdateShaderUniforms method on the BrickProceduralTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.brickproceduraltexture#updateshaderuniforms
func (b *BrickProceduralTexture) UpdateShaderUniforms() {

	b.p.Call("updateShaderUniforms")
}

// BrickColor returns the BrickColor property of class BrickProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.brickproceduraltexture#brickcolor
func (b *BrickProceduralTexture) BrickColor() *Color3 {
	retVal := b.p.Get("brickColor")
	return Color3FromJSObject(retVal, b.ctx)
}

// SetBrickColor sets the BrickColor property of class BrickProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.brickproceduraltexture#brickcolor
func (b *BrickProceduralTexture) SetBrickColor(brickColor *Color3) *BrickProceduralTexture {
	b.p.Set("brickColor", brickColor.JSObject())
	return b
}

// JointColor returns the JointColor property of class BrickProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.brickproceduraltexture#jointcolor
func (b *BrickProceduralTexture) JointColor() *Color3 {
	retVal := b.p.Get("jointColor")
	return Color3FromJSObject(retVal, b.ctx)
}

// SetJointColor sets the JointColor property of class BrickProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.brickproceduraltexture#jointcolor
func (b *BrickProceduralTexture) SetJointColor(jointColor *Color3) *BrickProceduralTexture {
	b.p.Set("jointColor", jointColor.JSObject())
	return b
}

// NumberOfBricksHeight returns the NumberOfBricksHeight property of class BrickProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.brickproceduraltexture#numberofbricksheight
func (b *BrickProceduralTexture) NumberOfBricksHeight() float64 {
	retVal := b.p.Get("numberOfBricksHeight")
	return retVal.Float()
}

// SetNumberOfBricksHeight sets the NumberOfBricksHeight property of class BrickProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.brickproceduraltexture#numberofbricksheight
func (b *BrickProceduralTexture) SetNumberOfBricksHeight(numberOfBricksHeight float64) *BrickProceduralTexture {
	b.p.Set("numberOfBricksHeight", numberOfBricksHeight)
	return b
}

// NumberOfBricksWidth returns the NumberOfBricksWidth property of class BrickProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.brickproceduraltexture#numberofbrickswidth
func (b *BrickProceduralTexture) NumberOfBricksWidth() float64 {
	retVal := b.p.Get("numberOfBricksWidth")
	return retVal.Float()
}

// SetNumberOfBricksWidth sets the NumberOfBricksWidth property of class BrickProceduralTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.brickproceduraltexture#numberofbrickswidth
func (b *BrickProceduralTexture) SetNumberOfBricksWidth(numberOfBricksWidth float64) *BrickProceduralTexture {
	b.p.Set("numberOfBricksWidth", numberOfBricksWidth)
	return b
}

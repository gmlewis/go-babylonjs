// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// BoxParticleEmitter represents a babylon.js BoxParticleEmitter.
// Particle emitter emitting particles from the inside of a box.
// It emits the particles randomly between 2 given directions.
type BoxParticleEmitter struct {
	p   js.Value
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (b *BoxParticleEmitter) JSObject() js.Value { return b.p }

// BoxParticleEmitter returns a BoxParticleEmitter JavaScript class.
func (ba *Babylon) BoxParticleEmitter() *BoxParticleEmitter {
	p := ba.ctx.Get("BoxParticleEmitter")
	return BoxParticleEmitterFromJSObject(p, ba.ctx)
}

// BoxParticleEmitterFromJSObject returns a wrapped BoxParticleEmitter JavaScript class.
func BoxParticleEmitterFromJSObject(p js.Value, ctx js.Value) *BoxParticleEmitter {
	return &BoxParticleEmitter{p: p, ctx: ctx}
}

// BoxParticleEmitterArrayToJSArray returns a JavaScript Array for the wrapped array.
func BoxParticleEmitterArrayToJSArray(array []*BoxParticleEmitter) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewBoxParticleEmitter returns a new BoxParticleEmitter object.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#constructor
func (ba *Babylon) NewBoxParticleEmitter() *BoxParticleEmitter {

	args := make([]interface{}, 0, 0+0)

	p := ba.ctx.Get("BoxParticleEmitter").New(args...)
	return BoxParticleEmitterFromJSObject(p, ba.ctx)
}

// ApplyToShader calls the ApplyToShader method on the BoxParticleEmitter object.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#applytoshader
func (b *BoxParticleEmitter) ApplyToShader(effect *Effect) {

	args := make([]interface{}, 0, 1+0)

	if effect == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, effect.JSObject())
	}

	b.p.Call("applyToShader", args...)
}

// Clone calls the Clone method on the BoxParticleEmitter object.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#clone
func (b *BoxParticleEmitter) Clone() *BoxParticleEmitter {

	retVal := b.p.Call("clone")
	return BoxParticleEmitterFromJSObject(retVal, b.ctx)
}

// GetClassName calls the GetClassName method on the BoxParticleEmitter object.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#getclassname
func (b *BoxParticleEmitter) GetClassName() string {

	retVal := b.p.Call("getClassName")
	return retVal.String()
}

// GetEffectDefines calls the GetEffectDefines method on the BoxParticleEmitter object.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#geteffectdefines
func (b *BoxParticleEmitter) GetEffectDefines() string {

	retVal := b.p.Call("getEffectDefines")
	return retVal.String()
}

// Parse calls the Parse method on the BoxParticleEmitter object.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#parse
func (b *BoxParticleEmitter) Parse(serializationObject JSObject) {

	args := make([]interface{}, 0, 1+0)

	if serializationObject == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, serializationObject.JSObject())
	}

	b.p.Call("parse", args...)
}

// Serialize calls the Serialize method on the BoxParticleEmitter object.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#serialize
func (b *BoxParticleEmitter) Serialize() js.Value {

	retVal := b.p.Call("serialize")
	return retVal
}

// StartDirectionFunction calls the StartDirectionFunction method on the BoxParticleEmitter object.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#startdirectionfunction
func (b *BoxParticleEmitter) StartDirectionFunction(worldMatrix *Matrix, directionToUpdate *Vector3, particle *Particle) {

	args := make([]interface{}, 0, 3+0)

	if worldMatrix == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, worldMatrix.JSObject())
	}

	if directionToUpdate == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, directionToUpdate.JSObject())
	}

	if particle == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, particle.JSObject())
	}

	b.p.Call("startDirectionFunction", args...)
}

// StartPositionFunction calls the StartPositionFunction method on the BoxParticleEmitter object.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#startpositionfunction
func (b *BoxParticleEmitter) StartPositionFunction(worldMatrix *Matrix, positionToUpdate *Vector3, particle *Particle) {

	args := make([]interface{}, 0, 3+0)

	if worldMatrix == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, worldMatrix.JSObject())
	}

	if positionToUpdate == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, positionToUpdate.JSObject())
	}

	if particle == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, particle.JSObject())
	}

	b.p.Call("startPositionFunction", args...)
}

// Direction1 returns the Direction1 property of class BoxParticleEmitter.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#direction1
func (b *BoxParticleEmitter) Direction1() *Vector3 {
	retVal := b.p.Get("direction1")
	return Vector3FromJSObject(retVal, b.ctx)
}

// SetDirection1 sets the Direction1 property of class BoxParticleEmitter.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#direction1
func (b *BoxParticleEmitter) SetDirection1(direction1 *Vector3) *BoxParticleEmitter {
	b.p.Set("direction1", direction1.JSObject())
	return b
}

// Direction2 returns the Direction2 property of class BoxParticleEmitter.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#direction2
func (b *BoxParticleEmitter) Direction2() *Vector3 {
	retVal := b.p.Get("direction2")
	return Vector3FromJSObject(retVal, b.ctx)
}

// SetDirection2 sets the Direction2 property of class BoxParticleEmitter.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#direction2
func (b *BoxParticleEmitter) SetDirection2(direction2 *Vector3) *BoxParticleEmitter {
	b.p.Set("direction2", direction2.JSObject())
	return b
}

// MaxEmitBox returns the MaxEmitBox property of class BoxParticleEmitter.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#maxemitbox
func (b *BoxParticleEmitter) MaxEmitBox() *Vector3 {
	retVal := b.p.Get("maxEmitBox")
	return Vector3FromJSObject(retVal, b.ctx)
}

// SetMaxEmitBox sets the MaxEmitBox property of class BoxParticleEmitter.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#maxemitbox
func (b *BoxParticleEmitter) SetMaxEmitBox(maxEmitBox *Vector3) *BoxParticleEmitter {
	b.p.Set("maxEmitBox", maxEmitBox.JSObject())
	return b
}

// MinEmitBox returns the MinEmitBox property of class BoxParticleEmitter.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#minemitbox
func (b *BoxParticleEmitter) MinEmitBox() *Vector3 {
	retVal := b.p.Get("minEmitBox")
	return Vector3FromJSObject(retVal, b.ctx)
}

// SetMinEmitBox sets the MinEmitBox property of class BoxParticleEmitter.
//
// https://doc.babylonjs.com/api/classes/babylon.boxparticleemitter#minemitbox
func (b *BoxParticleEmitter) SetMinEmitBox(minEmitBox *Vector3) *BoxParticleEmitter {
	b.p.Set("minEmitBox", minEmitBox.JSObject())
	return b
}

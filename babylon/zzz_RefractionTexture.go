// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// RefractionTexture represents a babylon.js RefractionTexture.
// Creates a refraction texture used by refraction channel of the standard material.
// It is like a mirror but to see through a material.
//
// See: https://doc.babylonjs.com/how_to/reflect#refraction
type RefractionTexture struct {
	*RenderTargetTexture
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (r *RefractionTexture) JSObject() js.Value { return r.p }

// RefractionTexture returns a RefractionTexture JavaScript class.
func (ba *Babylon) RefractionTexture() *RefractionTexture {
	p := ba.ctx.Get("RefractionTexture")
	return RefractionTextureFromJSObject(p, ba.ctx)
}

// RefractionTextureFromJSObject returns a wrapped RefractionTexture JavaScript class.
func RefractionTextureFromJSObject(p js.Value, ctx js.Value) *RefractionTexture {
	return &RefractionTexture{RenderTargetTexture: RenderTargetTextureFromJSObject(p, ctx), ctx: ctx}
}

// RefractionTextureArrayToJSArray returns a JavaScript Array for the wrapped array.
func RefractionTextureArrayToJSArray(array []*RefractionTexture) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewRefractionTextureOpts contains optional parameters for NewRefractionTexture.
type NewRefractionTextureOpts struct {
	GenerateMipMaps *bool
}

// NewRefractionTexture returns a new RefractionTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.refractiontexture
func (ba *Babylon) NewRefractionTexture(name string, size float64, scene *Scene, opts *NewRefractionTextureOpts) *RefractionTexture {
	if opts == nil {
		opts = &NewRefractionTextureOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	args = append(args, name)
	args = append(args, size)
	args = append(args, scene.JSObject())

	if opts.GenerateMipMaps == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.GenerateMipMaps)
	}

	p := ba.ctx.Get("RefractionTexture").New(args...)
	return RefractionTextureFromJSObject(p, ba.ctx)
}

// Clone calls the Clone method on the RefractionTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.refractiontexture#clone
func (r *RefractionTexture) Clone() *RefractionTexture {

	retVal := r.p.Call("clone")
	return RefractionTextureFromJSObject(retVal, r.ctx)
}

// Serialize calls the Serialize method on the RefractionTexture object.
//
// https://doc.babylonjs.com/api/classes/babylon.refractiontexture#serialize
func (r *RefractionTexture) Serialize() interface{} {

	retVal := r.p.Call("serialize")
	return retVal
}

/*

// Depth returns the Depth property of class RefractionTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.refractiontexture#depth
func (r *RefractionTexture) Depth(depth float64) *RefractionTexture {
	p := ba.ctx.Get("RefractionTexture").New(depth)
	return RefractionTextureFromJSObject(p, ba.ctx)
}

// SetDepth sets the Depth property of class RefractionTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.refractiontexture#depth
func (r *RefractionTexture) SetDepth(depth float64) *RefractionTexture {
	p := ba.ctx.Get("RefractionTexture").New(depth)
	return RefractionTextureFromJSObject(p, ba.ctx)
}

// RefractionPlane returns the RefractionPlane property of class RefractionTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.refractiontexture#refractionplane
func (r *RefractionTexture) RefractionPlane(refractionPlane *Plane) *RefractionTexture {
	p := ba.ctx.Get("RefractionTexture").New(refractionPlane.JSObject())
	return RefractionTextureFromJSObject(p, ba.ctx)
}

// SetRefractionPlane sets the RefractionPlane property of class RefractionTexture.
//
// https://doc.babylonjs.com/api/classes/babylon.refractiontexture#refractionplane
func (r *RefractionTexture) SetRefractionPlane(refractionPlane *Plane) *RefractionTexture {
	p := ba.ctx.Get("RefractionTexture").New(refractionPlane.JSObject())
	return RefractionTextureFromJSObject(p, ba.ctx)
}

*/

// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// InstancedMesh represents a babylon.js InstancedMesh.
// Creates an instance based on a source mesh.
type InstancedMesh struct {
	*AbstractMesh
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (i *InstancedMesh) JSObject() js.Value { return i.p }

// InstancedMesh returns a InstancedMesh JavaScript class.
func (ba *Babylon) InstancedMesh() *InstancedMesh {
	p := ba.ctx.Get("InstancedMesh")
	return InstancedMeshFromJSObject(p, ba.ctx)
}

// InstancedMeshFromJSObject returns a wrapped InstancedMesh JavaScript class.
func InstancedMeshFromJSObject(p js.Value, ctx js.Value) *InstancedMesh {
	return &InstancedMesh{AbstractMesh: AbstractMeshFromJSObject(p, ctx), ctx: ctx}
}

// InstancedMeshArrayToJSArray returns a JavaScript Array for the wrapped array.
func InstancedMeshArrayToJSArray(array []*InstancedMesh) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewInstancedMesh returns a new InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh
func (ba *Babylon) NewInstancedMesh(name string, source *Mesh) *InstancedMesh {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, source.JSObject())

	p := ba.ctx.Get("InstancedMesh").New(args...)
	return InstancedMeshFromJSObject(p, ba.ctx)
}

// InstancedMeshCloneOpts contains optional parameters for InstancedMesh.Clone.
type InstancedMeshCloneOpts struct {
	NewParent          *Node
	DoNotCloneChildren *bool
}

// Clone calls the Clone method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#clone
func (i *InstancedMesh) Clone(name string, opts *InstancedMeshCloneOpts) *AbstractMesh {
	if opts == nil {
		opts = &InstancedMeshCloneOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, name)

	if opts.NewParent == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.NewParent.JSObject())
	}
	if opts.DoNotCloneChildren == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotCloneChildren)
	}

	retVal := i.p.Call("clone", args...)
	return AbstractMeshFromJSObject(retVal, i.ctx)
}

// InstancedMeshDisposeOpts contains optional parameters for InstancedMesh.Dispose.
type InstancedMeshDisposeOpts struct {
	DoNotRecurse               *bool
	DisposeMaterialAndTextures *bool
}

// Dispose calls the Dispose method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#dispose
func (i *InstancedMesh) Dispose(opts *InstancedMeshDisposeOpts) {
	if opts == nil {
		opts = &InstancedMeshDisposeOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.DoNotRecurse == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotRecurse)
	}
	if opts.DisposeMaterialAndTextures == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DisposeMaterialAndTextures)
	}

	i.p.Call("dispose", args...)
}

// GetClassName calls the GetClassName method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#getclassname
func (i *InstancedMesh) GetClassName() string {

	retVal := i.p.Call("getClassName")
	return retVal.String()
}

// GetIndices calls the GetIndices method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#getindices
func (i *InstancedMesh) GetIndices() js.Value {

	retVal := i.p.Call("getIndices")
	return retVal
}

// GetLOD calls the GetLOD method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#getlod
func (i *InstancedMesh) GetLOD(camera *Camera) *AbstractMesh {

	args := make([]interface{}, 0, 1+0)

	args = append(args, camera.JSObject())

	retVal := i.p.Call("getLOD", args...)
	return AbstractMeshFromJSObject(retVal, i.ctx)
}

// GetTotalIndices calls the GetTotalIndices method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#gettotalindices
func (i *InstancedMesh) GetTotalIndices() float64 {

	retVal := i.p.Call("getTotalIndices")
	return retVal.Float()
}

// GetTotalVertices calls the GetTotalVertices method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#gettotalvertices
func (i *InstancedMesh) GetTotalVertices() float64 {

	retVal := i.p.Call("getTotalVertices")
	return retVal.Float()
}

// InstancedMeshGetVerticesDataOpts contains optional parameters for InstancedMesh.GetVerticesData.
type InstancedMeshGetVerticesDataOpts struct {
	CopyWhenShared *bool
}

// GetVerticesData calls the GetVerticesData method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#getverticesdata
func (i *InstancedMesh) GetVerticesData(kind string, opts *InstancedMeshGetVerticesDataOpts) js.Value {
	if opts == nil {
		opts = &InstancedMeshGetVerticesDataOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, kind)

	if opts.CopyWhenShared == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CopyWhenShared)
	}

	retVal := i.p.Call("getVerticesData", args...)
	return retVal
}

// GetWorldMatrix calls the GetWorldMatrix method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#getworldmatrix
func (i *InstancedMesh) GetWorldMatrix() *Matrix {

	retVal := i.p.Call("getWorldMatrix")
	return MatrixFromJSObject(retVal, i.ctx)
}

// InstancedMeshIsReadyOpts contains optional parameters for InstancedMesh.IsReady.
type InstancedMeshIsReadyOpts struct {
	CompleteCheck *bool
}

// IsReady calls the IsReady method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#isready
func (i *InstancedMesh) IsReady(opts *InstancedMeshIsReadyOpts) bool {
	if opts == nil {
		opts = &InstancedMeshIsReadyOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.CompleteCheck == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.CompleteCheck)
	}

	retVal := i.p.Call("isReady", args...)
	return retVal.Bool()
}

// IsVerticesDataPresent calls the IsVerticesDataPresent method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#isverticesdatapresent
func (i *InstancedMesh) IsVerticesDataPresent(kind string) bool {

	args := make([]interface{}, 0, 1+0)

	args = append(args, kind)

	retVal := i.p.Call("isVerticesDataPresent", args...)
	return retVal.Bool()
}

// InstancedMeshRefreshBoundingInfoOpts contains optional parameters for InstancedMesh.RefreshBoundingInfo.
type InstancedMeshRefreshBoundingInfoOpts struct {
	ApplySkeleton *bool
}

// RefreshBoundingInfo calls the RefreshBoundingInfo method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#refreshboundinginfo
func (i *InstancedMesh) RefreshBoundingInfo(opts *InstancedMeshRefreshBoundingInfoOpts) *InstancedMesh {
	if opts == nil {
		opts = &InstancedMeshRefreshBoundingInfoOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.ApplySkeleton == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ApplySkeleton)
	}

	retVal := i.p.Call("refreshBoundingInfo", args...)
	return InstancedMeshFromJSObject(retVal, i.ctx)
}

// InstancedMeshSetIndicesOpts contains optional parameters for InstancedMesh.SetIndices.
type InstancedMeshSetIndicesOpts struct {
	TotalVertices *float64
}

// SetIndices calls the SetIndices method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#setindices
func (i *InstancedMesh) SetIndices(indices js.Value, opts *InstancedMeshSetIndicesOpts) *Mesh {
	if opts == nil {
		opts = &InstancedMeshSetIndicesOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, indices)

	if opts.TotalVertices == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.TotalVertices)
	}

	retVal := i.p.Call("setIndices", args...)
	return MeshFromJSObject(retVal, i.ctx)
}

// InstancedMeshSetVerticesDataOpts contains optional parameters for InstancedMesh.SetVerticesData.
type InstancedMeshSetVerticesDataOpts struct {
	Updatable *bool
	Stride    *float64
}

// SetVerticesData calls the SetVerticesData method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#setverticesdata
func (i *InstancedMesh) SetVerticesData(kind string, data js.Value, opts *InstancedMeshSetVerticesDataOpts) *AbstractMesh {
	if opts == nil {
		opts = &InstancedMeshSetVerticesDataOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, kind)
	args = append(args, data)

	if opts.Updatable == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Updatable)
	}
	if opts.Stride == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Stride)
	}

	retVal := i.p.Call("setVerticesData", args...)
	return AbstractMeshFromJSObject(retVal, i.ctx)
}

// InstancedMeshUpdateVerticesDataOpts contains optional parameters for InstancedMesh.UpdateVerticesData.
type InstancedMeshUpdateVerticesDataOpts struct {
	UpdateExtends *bool
	MakeItUnique  *bool
}

// UpdateVerticesData calls the UpdateVerticesData method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#updateverticesdata
func (i *InstancedMesh) UpdateVerticesData(kind string, data js.Value, opts *InstancedMeshUpdateVerticesDataOpts) *Mesh {
	if opts == nil {
		opts = &InstancedMeshUpdateVerticesDataOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	args = append(args, kind)
	args = append(args, data)

	if opts.UpdateExtends == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UpdateExtends)
	}
	if opts.MakeItUnique == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.MakeItUnique)
	}

	retVal := i.p.Call("updateVerticesData", args...)
	return MeshFromJSObject(retVal, i.ctx)
}

// _removeLightSource calls the _removeLightSource method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#_removelightsource
func (i *InstancedMesh) _removeLightSource(light *Light, dispose bool) {

	args := make([]interface{}, 0, 2+0)

	args = append(args, light.JSObject())
	args = append(args, dispose)

	i.p.Call("_removeLightSource", args...)
}

// _resyncLightSource calls the _resyncLightSource method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#_resynclightsource
func (i *InstancedMesh) _resyncLightSource(light *Light) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, light.JSObject())

	i.p.Call("_resyncLightSource", args...)
}

// _resyncLightSources calls the _resyncLightSources method on the InstancedMesh object.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#_resynclightsources
func (i *InstancedMesh) _resyncLightSources() {

	i.p.Call("_resyncLightSources")
}

// IsAnInstance returns the IsAnInstance property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#isaninstance
func (i *InstancedMesh) IsAnInstance() bool {
	retVal := i.p.Get("isAnInstance")
	return retVal.Bool()
}

// SetIsAnInstance sets the IsAnInstance property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#isaninstance
func (i *InstancedMesh) SetIsAnInstance(isAnInstance bool) *InstancedMesh {
	i.p.Set("isAnInstance", isAnInstance)
	return i
}

// LightSources returns the LightSources property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#lightsources
func (i *InstancedMesh) LightSources() []*Light {
	retVal := i.p.Get("lightSources")
	result := []*Light{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, LightFromJSObject(retVal.Index(ri), i.ctx))
	}
	return result
}

// SetLightSources sets the LightSources property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#lightsources
func (i *InstancedMesh) SetLightSources(lightSources []*Light) *InstancedMesh {
	i.p.Set("lightSources", lightSources)
	return i
}

// Material returns the Material property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#material
func (i *InstancedMesh) Material() *Material {
	retVal := i.p.Get("material")
	return MaterialFromJSObject(retVal, i.ctx)
}

// SetMaterial sets the Material property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#material
func (i *InstancedMesh) SetMaterial(material *Material) *InstancedMesh {
	i.p.Set("material", material.JSObject())
	return i
}

// ReceiveShadows returns the ReceiveShadows property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#receiveshadows
func (i *InstancedMesh) ReceiveShadows() bool {
	retVal := i.p.Get("receiveShadows")
	return retVal.Bool()
}

// SetReceiveShadows sets the ReceiveShadows property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#receiveshadows
func (i *InstancedMesh) SetReceiveShadows(receiveShadows bool) *InstancedMesh {
	i.p.Set("receiveShadows", receiveShadows)
	return i
}

// RenderingGroupId returns the RenderingGroupId property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#renderinggroupid
func (i *InstancedMesh) RenderingGroupId() float64 {
	retVal := i.p.Get("renderingGroupId")
	return retVal.Float()
}

// SetRenderingGroupId sets the RenderingGroupId property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#renderinggroupid
func (i *InstancedMesh) SetRenderingGroupId(renderingGroupId float64) *InstancedMesh {
	i.p.Set("renderingGroupId", renderingGroupId)
	return i
}

// Skeleton returns the Skeleton property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#skeleton
func (i *InstancedMesh) Skeleton() *Skeleton {
	retVal := i.p.Get("skeleton")
	return SkeletonFromJSObject(retVal, i.ctx)
}

// SetSkeleton sets the Skeleton property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#skeleton
func (i *InstancedMesh) SetSkeleton(skeleton *Skeleton) *InstancedMesh {
	i.p.Set("skeleton", skeleton.JSObject())
	return i
}

// SourceMesh returns the SourceMesh property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#sourcemesh
func (i *InstancedMesh) SourceMesh() *Mesh {
	retVal := i.p.Get("sourceMesh")
	return MeshFromJSObject(retVal, i.ctx)
}

// SetSourceMesh sets the SourceMesh property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#sourcemesh
func (i *InstancedMesh) SetSourceMesh(sourceMesh *Mesh) *InstancedMesh {
	i.p.Set("sourceMesh", sourceMesh.JSObject())
	return i
}

// Visibility returns the Visibility property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#visibility
func (i *InstancedMesh) Visibility() float64 {
	retVal := i.p.Get("visibility")
	return retVal.Float()
}

// SetVisibility sets the Visibility property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#visibility
func (i *InstancedMesh) SetVisibility(visibility float64) *InstancedMesh {
	i.p.Set("visibility", visibility)
	return i
}

// _positions returns the _positions property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#_positions
func (i *InstancedMesh) _positions() []*Vector3 {
	retVal := i.p.Get("_positions")
	result := []*Vector3{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, Vector3FromJSObject(retVal.Index(ri), i.ctx))
	}
	return result
}

// Set_positions sets the _positions property of class InstancedMesh.
//
// https://doc.babylonjs.com/api/classes/babylon.instancedmesh#_positions
func (i *InstancedMesh) Set_positions(_positions []*Vector3) *InstancedMesh {
	i.p.Set("_positions", _positions)
	return i
}

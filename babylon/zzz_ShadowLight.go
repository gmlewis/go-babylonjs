// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// ShadowLight represents a babylon.js ShadowLight.
// Base implementation IShadowLight
// It groups all the common behaviour in order to reduce dupplication and better follow the DRY pattern.
type ShadowLight struct {
	*Light
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (s *ShadowLight) JSObject() js.Value { return s.p }

// ShadowLight returns a ShadowLight JavaScript class.
func (ba *Babylon) ShadowLight() *ShadowLight {
	p := ba.ctx.Get("ShadowLight")
	return ShadowLightFromJSObject(p, ba.ctx)
}

// ShadowLightFromJSObject returns a wrapped ShadowLight JavaScript class.
func ShadowLightFromJSObject(p js.Value, ctx js.Value) *ShadowLight {
	return &ShadowLight{Light: LightFromJSObject(p, ctx), ctx: ctx}
}

// ShadowLightArrayToJSArray returns a JavaScript Array for the wrapped array.
func ShadowLightArrayToJSArray(array []*ShadowLight) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewShadowLight returns a new ShadowLight object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#constructor
func (ba *Babylon) NewShadowLight(name string, scene *Scene) *ShadowLight {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, scene.JSObject())

	p := ba.ctx.Get("ShadowLight").New(args...)
	return ShadowLightFromJSObject(p, ba.ctx)
}

// ComputeTransformedInformation calls the ComputeTransformedInformation method on the ShadowLight object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#computetransformedinformation
func (s *ShadowLight) ComputeTransformedInformation() bool {

	retVal := s.p.Call("computeTransformedInformation")
	return retVal.Bool()
}

// ShadowLightComputeWorldMatrixOpts contains optional parameters for ShadowLight.ComputeWorldMatrix.
type ShadowLightComputeWorldMatrixOpts struct {
	Force *bool
}

// ComputeWorldMatrix calls the ComputeWorldMatrix method on the ShadowLight object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#computeworldmatrix
func (s *ShadowLight) ComputeWorldMatrix(opts *ShadowLightComputeWorldMatrixOpts) *Matrix {
	if opts == nil {
		opts = &ShadowLightComputeWorldMatrixOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.Force == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Force)
	}

	retVal := s.p.Call("computeWorldMatrix", args...)
	return MatrixFromJSObject(retVal, s.ctx)
}

// ForceProjectionMatrixCompute calls the ForceProjectionMatrixCompute method on the ShadowLight object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#forceprojectionmatrixcompute
func (s *ShadowLight) ForceProjectionMatrixCompute() {

	s.p.Call("forceProjectionMatrixCompute")
}

// GetAbsolutePosition calls the GetAbsolutePosition method on the ShadowLight object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#getabsoluteposition
func (s *ShadowLight) GetAbsolutePosition() *Vector3 {

	retVal := s.p.Call("getAbsolutePosition")
	return Vector3FromJSObject(retVal, s.ctx)
}

// GetDepthMaxZ calls the GetDepthMaxZ method on the ShadowLight object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#getdepthmaxz
func (s *ShadowLight) GetDepthMaxZ(activeCamera *Camera) float64 {

	args := make([]interface{}, 0, 1+0)

	if activeCamera == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, activeCamera.JSObject())
	}

	retVal := s.p.Call("getDepthMaxZ", args...)
	return retVal.Float()
}

// GetDepthMinZ calls the GetDepthMinZ method on the ShadowLight object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#getdepthminz
func (s *ShadowLight) GetDepthMinZ(activeCamera *Camera) float64 {

	args := make([]interface{}, 0, 1+0)

	if activeCamera == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, activeCamera.JSObject())
	}

	retVal := s.p.Call("getDepthMinZ", args...)
	return retVal.Float()
}

// GetDepthScale calls the GetDepthScale method on the ShadowLight object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#getdepthscale
func (s *ShadowLight) GetDepthScale() float64 {

	retVal := s.p.Call("getDepthScale")
	return retVal.Float()
}

// GetRotation calls the GetRotation method on the ShadowLight object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#getrotation
func (s *ShadowLight) GetRotation() *Vector3 {

	retVal := s.p.Call("getRotation")
	return Vector3FromJSObject(retVal, s.ctx)
}

// ShadowLightGetShadowDirectionOpts contains optional parameters for ShadowLight.GetShadowDirection.
type ShadowLightGetShadowDirectionOpts struct {
	FaceIndex *float64
}

// GetShadowDirection calls the GetShadowDirection method on the ShadowLight object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#getshadowdirection
func (s *ShadowLight) GetShadowDirection(opts *ShadowLightGetShadowDirectionOpts) *Vector3 {
	if opts == nil {
		opts = &ShadowLightGetShadowDirectionOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.FaceIndex == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.FaceIndex)
	}

	retVal := s.p.Call("getShadowDirection", args...)
	return Vector3FromJSObject(retVal, s.ctx)
}

// NeedCube calls the NeedCube method on the ShadowLight object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#needcube
func (s *ShadowLight) NeedCube() bool {

	retVal := s.p.Call("needCube")
	return retVal.Bool()
}

// NeedProjectionMatrixCompute calls the NeedProjectionMatrixCompute method on the ShadowLight object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#needprojectionmatrixcompute
func (s *ShadowLight) NeedProjectionMatrixCompute() bool {

	retVal := s.p.Call("needProjectionMatrixCompute")
	return retVal.Bool()
}

// SetDirectionToTarget calls the SetDirectionToTarget method on the ShadowLight object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#setdirectiontotarget
func (s *ShadowLight) SetDirectionToTarget(target *Vector3) *Vector3 {

	args := make([]interface{}, 0, 1+0)

	if target == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, target.JSObject())
	}

	retVal := s.p.Call("setDirectionToTarget", args...)
	return Vector3FromJSObject(retVal, s.ctx)
}

// SetShadowProjectionMatrix calls the SetShadowProjectionMatrix method on the ShadowLight object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#setshadowprojectionmatrix
func (s *ShadowLight) SetShadowProjectionMatrix(matrix *Matrix, viewMatrix *Matrix, renderList []*AbstractMesh) *IShadowLight {

	args := make([]interface{}, 0, 3+0)

	if matrix == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, matrix.JSObject())
	}

	if viewMatrix == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, viewMatrix.JSObject())
	}

	args = append(args, AbstractMeshArrayToJSArray(renderList))

	retVal := s.p.Call("setShadowProjectionMatrix", args...)
	return IShadowLightFromJSObject(retVal, s.ctx)
}

// CustomProjectionMatrixBuilder returns the CustomProjectionMatrixBuilder property of class ShadowLight.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#customprojectionmatrixbuilder
func (s *ShadowLight) CustomProjectionMatrixBuilder() js.Value {
	retVal := s.p.Get("customProjectionMatrixBuilder")
	return retVal
}

// SetCustomProjectionMatrixBuilder sets the CustomProjectionMatrixBuilder property of class ShadowLight.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#customprojectionmatrixbuilder
func (s *ShadowLight) SetCustomProjectionMatrixBuilder(customProjectionMatrixBuilder JSFunc) *ShadowLight {
	s.p.Set("customProjectionMatrixBuilder", js.FuncOf(customProjectionMatrixBuilder))
	return s
}

// Direction returns the Direction property of class ShadowLight.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#direction
func (s *ShadowLight) Direction() *Vector3 {
	retVal := s.p.Get("direction")
	return Vector3FromJSObject(retVal, s.ctx)
}

// SetDirection sets the Direction property of class ShadowLight.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#direction
func (s *ShadowLight) SetDirection(direction *Vector3) *ShadowLight {
	s.p.Set("direction", direction.JSObject())
	return s
}

// Position returns the Position property of class ShadowLight.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#position
func (s *ShadowLight) Position() *Vector3 {
	retVal := s.p.Get("position")
	return Vector3FromJSObject(retVal, s.ctx)
}

// SetPosition sets the Position property of class ShadowLight.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#position
func (s *ShadowLight) SetPosition(position *Vector3) *ShadowLight {
	s.p.Set("position", position.JSObject())
	return s
}

// ShadowMaxZ returns the ShadowMaxZ property of class ShadowLight.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#shadowmaxz
func (s *ShadowLight) ShadowMaxZ() float64 {
	retVal := s.p.Get("shadowMaxZ")
	return retVal.Float()
}

// SetShadowMaxZ sets the ShadowMaxZ property of class ShadowLight.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#shadowmaxz
func (s *ShadowLight) SetShadowMaxZ(shadowMaxZ float64) *ShadowLight {
	s.p.Set("shadowMaxZ", shadowMaxZ)
	return s
}

// ShadowMinZ returns the ShadowMinZ property of class ShadowLight.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#shadowminz
func (s *ShadowLight) ShadowMinZ() float64 {
	retVal := s.p.Get("shadowMinZ")
	return retVal.Float()
}

// SetShadowMinZ sets the ShadowMinZ property of class ShadowLight.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#shadowminz
func (s *ShadowLight) SetShadowMinZ(shadowMinZ float64) *ShadowLight {
	s.p.Set("shadowMinZ", shadowMinZ)
	return s
}

// TransformedDirection returns the TransformedDirection property of class ShadowLight.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#transformeddirection
func (s *ShadowLight) TransformedDirection() *Vector3 {
	retVal := s.p.Get("transformedDirection")
	return Vector3FromJSObject(retVal, s.ctx)
}

// SetTransformedDirection sets the TransformedDirection property of class ShadowLight.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#transformeddirection
func (s *ShadowLight) SetTransformedDirection(transformedDirection *Vector3) *ShadowLight {
	s.p.Set("transformedDirection", transformedDirection.JSObject())
	return s
}

// TransformedPosition returns the TransformedPosition property of class ShadowLight.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#transformedposition
func (s *ShadowLight) TransformedPosition() *Vector3 {
	retVal := s.p.Get("transformedPosition")
	return Vector3FromJSObject(retVal, s.ctx)
}

// SetTransformedPosition sets the TransformedPosition property of class ShadowLight.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowlight#transformedposition
func (s *ShadowLight) SetTransformedPosition(transformedPosition *Vector3) *ShadowLight {
	s.p.Set("transformedPosition", transformedPosition.JSObject())
	return s
}

// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// TransformNode represents a babylon.js TransformNode.
// A TransformNode is an object that is not rendered but can be used as a center of transformation. This can decrease memory usage and increase rendering speed compared to using an empty mesh as a parent and is less complicated than using a pivot matrix.
//
// See: https://doc.babylonjs.com/how_to/transformnode
type TransformNode struct {
	*Node
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (t *TransformNode) JSObject() js.Value { return t.p }

// TransformNode returns a TransformNode JavaScript class.
func (ba *Babylon) TransformNode() *TransformNode {
	p := ba.ctx.Get("TransformNode")
	return TransformNodeFromJSObject(p, ba.ctx)
}

// TransformNodeFromJSObject returns a wrapped TransformNode JavaScript class.
func TransformNodeFromJSObject(p js.Value, ctx js.Value) *TransformNode {
	return &TransformNode{Node: NodeFromJSObject(p, ctx), ctx: ctx}
}

// TransformNodeArrayToJSArray returns a JavaScript Array for the wrapped array.
func TransformNodeArrayToJSArray(array []*TransformNode) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewTransformNodeOpts contains optional parameters for NewTransformNode.
type NewTransformNodeOpts struct {
	Scene  *Scene
	IsPure *bool
}

// NewTransformNode returns a new TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode
func (ba *Babylon) NewTransformNode(name string, opts *NewTransformNodeOpts) *TransformNode {
	if opts == nil {
		opts = &NewTransformNodeOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	args = append(args, name)

	if opts.Scene == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Scene.JSObject())
	}
	if opts.IsPure == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IsPure)
	}

	p := ba.ctx.Get("TransformNode").New(args...)
	return TransformNodeFromJSObject(p, ba.ctx)
}

// AddRotation calls the AddRotation method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#addrotation
func (t *TransformNode) AddRotation(x float64, y float64, z float64) *TransformNode {

	args := make([]interface{}, 0, 3+0)

	args = append(args, x)
	args = append(args, y)
	args = append(args, z)

	retVal := t.p.Call("addRotation", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// AttachToBone calls the AttachToBone method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#attachtobone
func (t *TransformNode) AttachToBone(bone *Bone, affectedTransformNode *TransformNode) *TransformNode {

	args := make([]interface{}, 0, 2+0)

	args = append(args, bone.JSObject())
	args = append(args, affectedTransformNode.JSObject())

	retVal := t.p.Call("attachToBone", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// TransformNodeCloneOpts contains optional parameters for TransformNode.Clone.
type TransformNodeCloneOpts struct {
	DoNotCloneChildren *bool
}

// Clone calls the Clone method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#clone
func (t *TransformNode) Clone(name string, newParent *Node, opts *TransformNodeCloneOpts) *TransformNode {
	if opts == nil {
		opts = &TransformNodeCloneOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, name)
	args = append(args, newParent.JSObject())

	if opts.DoNotCloneChildren == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotCloneChildren)
	}

	retVal := t.p.Call("clone", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// TransformNodeComputeWorldMatrixOpts contains optional parameters for TransformNode.ComputeWorldMatrix.
type TransformNodeComputeWorldMatrixOpts struct {
	Force *bool
}

// ComputeWorldMatrix calls the ComputeWorldMatrix method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#computeworldmatrix
func (t *TransformNode) ComputeWorldMatrix(opts *TransformNodeComputeWorldMatrixOpts) *Matrix {
	if opts == nil {
		opts = &TransformNodeComputeWorldMatrixOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.Force == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Force)
	}

	retVal := t.p.Call("computeWorldMatrix", args...)
	return MatrixFromJSObject(retVal, t.ctx)
}

// DetachFromBone calls the DetachFromBone method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#detachfrombone
func (t *TransformNode) DetachFromBone() *TransformNode {

	retVal := t.p.Call("detachFromBone")
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// TransformNodeDisposeOpts contains optional parameters for TransformNode.Dispose.
type TransformNodeDisposeOpts struct {
	DoNotRecurse               *bool
	DisposeMaterialAndTextures *bool
}

// Dispose calls the Dispose method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#dispose
func (t *TransformNode) Dispose(opts *TransformNodeDisposeOpts) {
	if opts == nil {
		opts = &TransformNodeDisposeOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.DoNotRecurse == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DoNotRecurse)
	}
	if opts.DisposeMaterialAndTextures == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DisposeMaterialAndTextures)
	}

	t.p.Call("dispose", args...)
}

// TransformNodeFreezeWorldMatrixOpts contains optional parameters for TransformNode.FreezeWorldMatrix.
type TransformNodeFreezeWorldMatrixOpts struct {
	NewWorldMatrix *Matrix
}

// FreezeWorldMatrix calls the FreezeWorldMatrix method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#freezeworldmatrix
func (t *TransformNode) FreezeWorldMatrix(opts *TransformNodeFreezeWorldMatrixOpts) *TransformNode {
	if opts == nil {
		opts = &TransformNodeFreezeWorldMatrixOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.NewWorldMatrix == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.NewWorldMatrix.JSObject())
	}

	retVal := t.p.Call("freezeWorldMatrix", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// GetAbsolutePivotPoint calls the GetAbsolutePivotPoint method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#getabsolutepivotpoint
func (t *TransformNode) GetAbsolutePivotPoint() *Vector3 {

	retVal := t.p.Call("getAbsolutePivotPoint")
	return Vector3FromJSObject(retVal, t.ctx)
}

// GetAbsolutePivotPointToRef calls the GetAbsolutePivotPointToRef method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#getabsolutepivotpointtoref
func (t *TransformNode) GetAbsolutePivotPointToRef(result *Vector3) *TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, result.JSObject())

	retVal := t.p.Call("getAbsolutePivotPointToRef", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// GetAbsolutePosition calls the GetAbsolutePosition method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#getabsoluteposition
func (t *TransformNode) GetAbsolutePosition() *Vector3 {

	retVal := t.p.Call("getAbsolutePosition")
	return Vector3FromJSObject(retVal, t.ctx)
}

// TransformNodeGetChildTransformNodesOpts contains optional parameters for TransformNode.GetChildTransformNodes.
type TransformNodeGetChildTransformNodesOpts struct {
	DirectDescendantsOnly *bool
	Predicate             func()
}

// GetChildTransformNodes calls the GetChildTransformNodes method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#getchildtransformnodes
func (t *TransformNode) GetChildTransformNodes(opts *TransformNodeGetChildTransformNodesOpts) []*TransformNode {
	if opts == nil {
		opts = &TransformNodeGetChildTransformNodesOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	if opts.DirectDescendantsOnly == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.DirectDescendantsOnly)
	}
	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.Predicate(); return nil }) /* never freed! */)
	}

	retVal := t.p.Call("getChildTransformNodes", args...)
	result := []*TransformNode{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, TransformNodeFromJSObject(retVal.Index(ri), t.ctx))
	}
	return result
}

// GetClassName calls the GetClassName method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#getclassname
func (t *TransformNode) GetClassName() string {

	retVal := t.p.Call("getClassName")
	return retVal.String()
}

// GetDirection calls the GetDirection method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#getdirection
func (t *TransformNode) GetDirection(localAxis *Vector3) *Vector3 {

	args := make([]interface{}, 0, 1+0)

	args = append(args, localAxis.JSObject())

	retVal := t.p.Call("getDirection", args...)
	return Vector3FromJSObject(retVal, t.ctx)
}

// GetDirectionToRef calls the GetDirectionToRef method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#getdirectiontoref
func (t *TransformNode) GetDirectionToRef(localAxis *Vector3, result *Vector3) *TransformNode {

	args := make([]interface{}, 0, 2+0)

	args = append(args, localAxis.JSObject())
	args = append(args, result.JSObject())

	retVal := t.p.Call("getDirectionToRef", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// TransformNodeGetDistanceToCameraOpts contains optional parameters for TransformNode.GetDistanceToCamera.
type TransformNodeGetDistanceToCameraOpts struct {
	Camera *Camera
}

// GetDistanceToCamera calls the GetDistanceToCamera method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#getdistancetocamera
func (t *TransformNode) GetDistanceToCamera(opts *TransformNodeGetDistanceToCameraOpts) float64 {
	if opts == nil {
		opts = &TransformNodeGetDistanceToCameraOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.Camera == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Camera.JSObject())
	}

	retVal := t.p.Call("getDistanceToCamera", args...)
	return retVal.Float()
}

// GetPivotMatrix calls the GetPivotMatrix method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#getpivotmatrix
func (t *TransformNode) GetPivotMatrix() *Matrix {

	retVal := t.p.Call("getPivotMatrix")
	return MatrixFromJSObject(retVal, t.ctx)
}

// GetPivotPoint calls the GetPivotPoint method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#getpivotpoint
func (t *TransformNode) GetPivotPoint() *Vector3 {

	retVal := t.p.Call("getPivotPoint")
	return Vector3FromJSObject(retVal, t.ctx)
}

// GetPivotPointToRef calls the GetPivotPointToRef method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#getpivotpointtoref
func (t *TransformNode) GetPivotPointToRef(result *Vector3) *TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, result.JSObject())

	retVal := t.p.Call("getPivotPointToRef", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// GetPoseMatrix calls the GetPoseMatrix method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#getposematrix
func (t *TransformNode) GetPoseMatrix() *Matrix {

	retVal := t.p.Call("getPoseMatrix")
	return MatrixFromJSObject(retVal, t.ctx)
}

// GetPositionExpressedInLocalSpace calls the GetPositionExpressedInLocalSpace method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#getpositionexpressedinlocalspace
func (t *TransformNode) GetPositionExpressedInLocalSpace() *Vector3 {

	retVal := t.p.Call("getPositionExpressedInLocalSpace")
	return Vector3FromJSObject(retVal, t.ctx)
}

// TransformNodeGetPositionInCameraSpaceOpts contains optional parameters for TransformNode.GetPositionInCameraSpace.
type TransformNodeGetPositionInCameraSpaceOpts struct {
	Camera *Camera
}

// GetPositionInCameraSpace calls the GetPositionInCameraSpace method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#getpositionincameraspace
func (t *TransformNode) GetPositionInCameraSpace(opts *TransformNodeGetPositionInCameraSpaceOpts) *Vector3 {
	if opts == nil {
		opts = &TransformNodeGetPositionInCameraSpaceOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.Camera == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Camera.JSObject())
	}

	retVal := t.p.Call("getPositionInCameraSpace", args...)
	return Vector3FromJSObject(retVal, t.ctx)
}

// TransformNodeInstantiateHierarchyOpts contains optional parameters for TransformNode.InstantiateHierarchy.
type TransformNodeInstantiateHierarchyOpts struct {
	NewParent        *TransformNode
	Options          map[string]interface{}
	OnNewNodeCreated func()
}

// InstantiateHierarchy calls the InstantiateHierarchy method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#instantiatehierarchy
func (t *TransformNode) InstantiateHierarchy(opts *TransformNodeInstantiateHierarchyOpts) *TransformNode {
	if opts == nil {
		opts = &TransformNodeInstantiateHierarchyOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.NewParent == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.NewParent.JSObject())
	}
	if opts.Options == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Options)
	}
	if opts.OnNewNodeCreated == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.OnNewNodeCreated(); return nil }) /* never freed! */)
	}

	retVal := t.p.Call("instantiateHierarchy", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// LocallyTranslate calls the LocallyTranslate method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#locallytranslate
func (t *TransformNode) LocallyTranslate(vector3 *Vector3) *TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, vector3.JSObject())

	retVal := t.p.Call("locallyTranslate", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// TransformNodeLookAtOpts contains optional parameters for TransformNode.LookAt.
type TransformNodeLookAtOpts struct {
	YawCor   *float64
	PitchCor *float64
	RollCor  *float64
	Space    js.Value
}

// LookAt calls the LookAt method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#lookat
func (t *TransformNode) LookAt(targetPoint *Vector3, opts *TransformNodeLookAtOpts) *TransformNode {
	if opts == nil {
		opts = &TransformNodeLookAtOpts{}
	}

	args := make([]interface{}, 0, 1+4)

	args = append(args, targetPoint.JSObject())

	if opts.YawCor == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.YawCor)
	}
	if opts.PitchCor == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.PitchCor)
	}
	if opts.RollCor == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.RollCor)
	}
	args = append(args, opts.Space)

	retVal := t.p.Call("lookAt", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// MarkAsDirty calls the MarkAsDirty method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#markasdirty
func (t *TransformNode) MarkAsDirty(property string) *TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, property)

	retVal := t.p.Call("markAsDirty", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// TransformNodeNormalizeToUnitCubeOpts contains optional parameters for TransformNode.NormalizeToUnitCube.
type TransformNodeNormalizeToUnitCubeOpts struct {
	IncludeDescendants *bool
	IgnoreRotation     *bool
	Predicate          func()
}

// NormalizeToUnitCube calls the NormalizeToUnitCube method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#normalizetounitcube
func (t *TransformNode) NormalizeToUnitCube(opts *TransformNodeNormalizeToUnitCubeOpts) *TransformNode {
	if opts == nil {
		opts = &TransformNodeNormalizeToUnitCubeOpts{}
	}

	args := make([]interface{}, 0, 0+3)

	if opts.IncludeDescendants == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IncludeDescendants)
	}
	if opts.IgnoreRotation == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.IgnoreRotation)
	}
	if opts.Predicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { opts.Predicate(); return nil }) /* never freed! */)
	}

	retVal := t.p.Call("normalizeToUnitCube", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// Parse calls the Parse method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#parse
func (t *TransformNode) Parse(parsedTransformNode interface{}, scene *Scene, rootUrl string) *TransformNode {

	args := make([]interface{}, 0, 3+0)

	args = append(args, parsedTransformNode)
	args = append(args, scene.JSObject())
	args = append(args, rootUrl)

	retVal := t.p.Call("Parse", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// RegisterAfterWorldMatrixUpdate calls the RegisterAfterWorldMatrixUpdate method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#registerafterworldmatrixupdate
func (t *TransformNode) RegisterAfterWorldMatrixUpdate(jsFunc func()) *TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	retVal := t.p.Call("registerAfterWorldMatrixUpdate", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// TransformNodeRotateOpts contains optional parameters for TransformNode.Rotate.
type TransformNodeRotateOpts struct {
	Space js.Value
}

// Rotate calls the Rotate method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#rotate
func (t *TransformNode) Rotate(axis *Vector3, amount float64, opts *TransformNodeRotateOpts) *TransformNode {
	if opts == nil {
		opts = &TransformNodeRotateOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, axis.JSObject())
	args = append(args, amount)

	args = append(args, opts.Space)

	retVal := t.p.Call("rotate", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// RotateAround calls the RotateAround method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#rotatearound
func (t *TransformNode) RotateAround(point *Vector3, axis *Vector3, amount float64) *TransformNode {

	args := make([]interface{}, 0, 3+0)

	args = append(args, point.JSObject())
	args = append(args, axis.JSObject())
	args = append(args, amount)

	retVal := t.p.Call("rotateAround", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// TransformNodeSerializeOpts contains optional parameters for TransformNode.Serialize.
type TransformNodeSerializeOpts struct {
	CurrentSerializationObject *interface{}
}

// Serialize calls the Serialize method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#serialize
func (t *TransformNode) Serialize(opts *TransformNodeSerializeOpts) interface{} {
	if opts == nil {
		opts = &TransformNodeSerializeOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.CurrentSerializationObject == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.CurrentSerializationObject)
	}

	retVal := t.p.Call("serialize", args...)
	return retVal
}

// SetAbsolutePosition calls the SetAbsolutePosition method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#setabsoluteposition
func (t *TransformNode) SetAbsolutePosition(absolutePosition *Vector3) *TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, absolutePosition.JSObject())

	retVal := t.p.Call("setAbsolutePosition", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// TransformNodeSetDirectionOpts contains optional parameters for TransformNode.SetDirection.
type TransformNodeSetDirectionOpts struct {
	YawCor   *float64
	PitchCor *float64
	RollCor  *float64
}

// SetDirection calls the SetDirection method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#setdirection
func (t *TransformNode) SetDirection(localAxis *Vector3, opts *TransformNodeSetDirectionOpts) *TransformNode {
	if opts == nil {
		opts = &TransformNodeSetDirectionOpts{}
	}

	args := make([]interface{}, 0, 1+3)

	args = append(args, localAxis.JSObject())

	if opts.YawCor == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.YawCor)
	}
	if opts.PitchCor == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.PitchCor)
	}
	if opts.RollCor == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.RollCor)
	}

	retVal := t.p.Call("setDirection", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// SetParent calls the SetParent method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#setparent
func (t *TransformNode) SetParent(node *Node) *TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, node.JSObject())

	retVal := t.p.Call("setParent", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// TransformNodeSetPivotMatrixOpts contains optional parameters for TransformNode.SetPivotMatrix.
type TransformNodeSetPivotMatrixOpts struct {
	PostMultiplyPivotMatrix *bool
}

// SetPivotMatrix calls the SetPivotMatrix method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#setpivotmatrix
func (t *TransformNode) SetPivotMatrix(matrix *Matrix, opts *TransformNodeSetPivotMatrixOpts) *TransformNode {
	if opts == nil {
		opts = &TransformNodeSetPivotMatrixOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, matrix.JSObject())

	if opts.PostMultiplyPivotMatrix == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.PostMultiplyPivotMatrix)
	}

	retVal := t.p.Call("setPivotMatrix", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// TransformNodeSetPivotPointOpts contains optional parameters for TransformNode.SetPivotPoint.
type TransformNodeSetPivotPointOpts struct {
	Space js.Value
}

// SetPivotPoint calls the SetPivotPoint method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#setpivotpoint
func (t *TransformNode) SetPivotPoint(point *Vector3, opts *TransformNodeSetPivotPointOpts) *TransformNode {
	if opts == nil {
		opts = &TransformNodeSetPivotPointOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	args = append(args, point.JSObject())

	args = append(args, opts.Space)

	retVal := t.p.Call("setPivotPoint", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// SetPositionWithLocalVector calls the SetPositionWithLocalVector method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#setpositionwithlocalvector
func (t *TransformNode) SetPositionWithLocalVector(vector3 *Vector3) *TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, vector3.JSObject())

	retVal := t.p.Call("setPositionWithLocalVector", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// SetPreTransformMatrix calls the SetPreTransformMatrix method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#setpretransformmatrix
func (t *TransformNode) SetPreTransformMatrix(matrix *Matrix) *TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, matrix.JSObject())

	retVal := t.p.Call("setPreTransformMatrix", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// TransformNodeTranslateOpts contains optional parameters for TransformNode.Translate.
type TransformNodeTranslateOpts struct {
	Space js.Value
}

// Translate calls the Translate method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#translate
func (t *TransformNode) Translate(axis *Vector3, distance float64, opts *TransformNodeTranslateOpts) *TransformNode {
	if opts == nil {
		opts = &TransformNodeTranslateOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, axis.JSObject())
	args = append(args, distance)

	args = append(args, opts.Space)

	retVal := t.p.Call("translate", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// UnfreezeWorldMatrix calls the UnfreezeWorldMatrix method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#unfreezeworldmatrix
func (t *TransformNode) UnfreezeWorldMatrix() *TransformNode {

	retVal := t.p.Call("unfreezeWorldMatrix")
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// UnregisterAfterWorldMatrixUpdate calls the UnregisterAfterWorldMatrixUpdate method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#unregisterafterworldmatrixupdate
func (t *TransformNode) UnregisterAfterWorldMatrixUpdate(jsFunc func()) *TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, js.FuncOf(func(this js.Value, args []js.Value) interface{} { jsFunc(); return nil }))

	retVal := t.p.Call("unregisterAfterWorldMatrixUpdate", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// UpdatePoseMatrix calls the UpdatePoseMatrix method on the TransformNode object.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#updateposematrix
func (t *TransformNode) UpdatePoseMatrix(matrix *Matrix) *TransformNode {

	args := make([]interface{}, 0, 1+0)

	args = append(args, matrix.JSObject())

	retVal := t.p.Call("updatePoseMatrix", args...)
	return TransformNodeFromJSObject(retVal, t.ctx)
}

// AbsolutePosition returns the AbsolutePosition property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#absoluteposition
func (t *TransformNode) AbsolutePosition() *Vector3 {
	retVal := t.p.Get("absolutePosition")
	return Vector3FromJSObject(retVal, t.ctx)
}

// AbsoluteRotationQuaternion returns the AbsoluteRotationQuaternion property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#absoluterotationquaternion
func (t *TransformNode) AbsoluteRotationQuaternion() *Quaternion {
	retVal := t.p.Get("absoluteRotationQuaternion")
	return QuaternionFromJSObject(retVal, t.ctx)
}

// SetAbsoluteRotationQuaternion sets the AbsoluteRotationQuaternion property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#absoluterotationquaternion
func (t *TransformNode) SetAbsoluteRotationQuaternion(absoluteRotationQuaternion *Quaternion) *TransformNode {
	t.p.Set("absoluteRotationQuaternion", absoluteRotationQuaternion.JSObject())
	return t
}

// AbsoluteScaling returns the AbsoluteScaling property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#absolutescaling
func (t *TransformNode) AbsoluteScaling() *Vector3 {
	retVal := t.p.Get("absoluteScaling")
	return Vector3FromJSObject(retVal, t.ctx)
}

// SetAbsoluteScaling sets the AbsoluteScaling property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#absolutescaling
func (t *TransformNode) SetAbsoluteScaling(absoluteScaling *Vector3) *TransformNode {
	t.p.Set("absoluteScaling", absoluteScaling.JSObject())
	return t
}

// BILLBOARDMODE_ALL returns the BILLBOARDMODE_ALL property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#billboardmode_all
func (t *TransformNode) BILLBOARDMODE_ALL() float64 {
	retVal := t.p.Get("BILLBOARDMODE_ALL")
	return retVal.Float()
}

// SetBILLBOARDMODE_ALL sets the BILLBOARDMODE_ALL property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#billboardmode_all
func (t *TransformNode) SetBILLBOARDMODE_ALL(BILLBOARDMODE_ALL float64) *TransformNode {
	t.p.Set("BILLBOARDMODE_ALL", BILLBOARDMODE_ALL)
	return t
}

// BILLBOARDMODE_NONE returns the BILLBOARDMODE_NONE property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#billboardmode_none
func (t *TransformNode) BILLBOARDMODE_NONE() float64 {
	retVal := t.p.Get("BILLBOARDMODE_NONE")
	return retVal.Float()
}

// SetBILLBOARDMODE_NONE sets the BILLBOARDMODE_NONE property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#billboardmode_none
func (t *TransformNode) SetBILLBOARDMODE_NONE(BILLBOARDMODE_NONE float64) *TransformNode {
	t.p.Set("BILLBOARDMODE_NONE", BILLBOARDMODE_NONE)
	return t
}

// BILLBOARDMODE_USE_POSITION returns the BILLBOARDMODE_USE_POSITION property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#billboardmode_use_position
func (t *TransformNode) BILLBOARDMODE_USE_POSITION() float64 {
	retVal := t.p.Get("BILLBOARDMODE_USE_POSITION")
	return retVal.Float()
}

// SetBILLBOARDMODE_USE_POSITION sets the BILLBOARDMODE_USE_POSITION property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#billboardmode_use_position
func (t *TransformNode) SetBILLBOARDMODE_USE_POSITION(BILLBOARDMODE_USE_POSITION float64) *TransformNode {
	t.p.Set("BILLBOARDMODE_USE_POSITION", BILLBOARDMODE_USE_POSITION)
	return t
}

// BILLBOARDMODE_X returns the BILLBOARDMODE_X property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#billboardmode_x
func (t *TransformNode) BILLBOARDMODE_X() float64 {
	retVal := t.p.Get("BILLBOARDMODE_X")
	return retVal.Float()
}

// SetBILLBOARDMODE_X sets the BILLBOARDMODE_X property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#billboardmode_x
func (t *TransformNode) SetBILLBOARDMODE_X(BILLBOARDMODE_X float64) *TransformNode {
	t.p.Set("BILLBOARDMODE_X", BILLBOARDMODE_X)
	return t
}

// BILLBOARDMODE_Y returns the BILLBOARDMODE_Y property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#billboardmode_y
func (t *TransformNode) BILLBOARDMODE_Y() float64 {
	retVal := t.p.Get("BILLBOARDMODE_Y")
	return retVal.Float()
}

// SetBILLBOARDMODE_Y sets the BILLBOARDMODE_Y property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#billboardmode_y
func (t *TransformNode) SetBILLBOARDMODE_Y(BILLBOARDMODE_Y float64) *TransformNode {
	t.p.Set("BILLBOARDMODE_Y", BILLBOARDMODE_Y)
	return t
}

// BILLBOARDMODE_Z returns the BILLBOARDMODE_Z property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#billboardmode_z
func (t *TransformNode) BILLBOARDMODE_Z() float64 {
	retVal := t.p.Get("BILLBOARDMODE_Z")
	return retVal.Float()
}

// SetBILLBOARDMODE_Z sets the BILLBOARDMODE_Z property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#billboardmode_z
func (t *TransformNode) SetBILLBOARDMODE_Z(BILLBOARDMODE_Z float64) *TransformNode {
	t.p.Set("BILLBOARDMODE_Z", BILLBOARDMODE_Z)
	return t
}

// BillboardMode returns the BillboardMode property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#billboardmode
func (t *TransformNode) BillboardMode() float64 {
	retVal := t.p.Get("billboardMode")
	return retVal.Float()
}

// SetBillboardMode sets the BillboardMode property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#billboardmode
func (t *TransformNode) SetBillboardMode(billboardMode float64) *TransformNode {
	t.p.Set("billboardMode", billboardMode)
	return t
}

// Forward returns the Forward property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#forward
func (t *TransformNode) Forward() *Vector3 {
	retVal := t.p.Get("forward")
	return Vector3FromJSObject(retVal, t.ctx)
}

// SetForward sets the Forward property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#forward
func (t *TransformNode) SetForward(forward *Vector3) *TransformNode {
	t.p.Set("forward", forward.JSObject())
	return t
}

// IgnoreNonUniformScaling returns the IgnoreNonUniformScaling property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#ignorenonuniformscaling
func (t *TransformNode) IgnoreNonUniformScaling() bool {
	retVal := t.p.Get("ignoreNonUniformScaling")
	return retVal.Bool()
}

// SetIgnoreNonUniformScaling sets the IgnoreNonUniformScaling property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#ignorenonuniformscaling
func (t *TransformNode) SetIgnoreNonUniformScaling(ignoreNonUniformScaling bool) *TransformNode {
	t.p.Set("ignoreNonUniformScaling", ignoreNonUniformScaling)
	return t
}

// InfiniteDistance returns the InfiniteDistance property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#infinitedistance
func (t *TransformNode) InfiniteDistance() bool {
	retVal := t.p.Get("infiniteDistance")
	return retVal.Bool()
}

// SetInfiniteDistance sets the InfiniteDistance property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#infinitedistance
func (t *TransformNode) SetInfiniteDistance(infiniteDistance bool) *TransformNode {
	t.p.Set("infiniteDistance", infiniteDistance)
	return t
}

// IsWorldMatrixFrozen returns the IsWorldMatrixFrozen property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#isworldmatrixfrozen
func (t *TransformNode) IsWorldMatrixFrozen() bool {
	retVal := t.p.Get("isWorldMatrixFrozen")
	return retVal.Bool()
}

// SetIsWorldMatrixFrozen sets the IsWorldMatrixFrozen property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#isworldmatrixfrozen
func (t *TransformNode) SetIsWorldMatrixFrozen(isWorldMatrixFrozen bool) *TransformNode {
	t.p.Set("isWorldMatrixFrozen", isWorldMatrixFrozen)
	return t
}

// NonUniformScaling returns the NonUniformScaling property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#nonuniformscaling
func (t *TransformNode) NonUniformScaling() bool {
	retVal := t.p.Get("nonUniformScaling")
	return retVal.Bool()
}

// SetNonUniformScaling sets the NonUniformScaling property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#nonuniformscaling
func (t *TransformNode) SetNonUniformScaling(nonUniformScaling bool) *TransformNode {
	t.p.Set("nonUniformScaling", nonUniformScaling)
	return t
}

// OnAfterWorldMatrixUpdateObservable returns the OnAfterWorldMatrixUpdateObservable property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#onafterworldmatrixupdateobservable
func (t *TransformNode) OnAfterWorldMatrixUpdateObservable() *Observable {
	retVal := t.p.Get("onAfterWorldMatrixUpdateObservable")
	return ObservableFromJSObject(retVal, t.ctx)
}

// SetOnAfterWorldMatrixUpdateObservable sets the OnAfterWorldMatrixUpdateObservable property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#onafterworldmatrixupdateobservable
func (t *TransformNode) SetOnAfterWorldMatrixUpdateObservable(onAfterWorldMatrixUpdateObservable *Observable) *TransformNode {
	t.p.Set("onAfterWorldMatrixUpdateObservable", onAfterWorldMatrixUpdateObservable.JSObject())
	return t
}

// Position returns the Position property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#position
func (t *TransformNode) Position() *Vector3 {
	retVal := t.p.Get("position")
	return Vector3FromJSObject(retVal, t.ctx)
}

// SetPosition sets the Position property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#position
func (t *TransformNode) SetPosition(position *Vector3) *TransformNode {
	t.p.Set("position", position.JSObject())
	return t
}

// PreserveParentRotationForBillboard returns the PreserveParentRotationForBillboard property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#preserveparentrotationforbillboard
func (t *TransformNode) PreserveParentRotationForBillboard() bool {
	retVal := t.p.Get("preserveParentRotationForBillboard")
	return retVal.Bool()
}

// SetPreserveParentRotationForBillboard sets the PreserveParentRotationForBillboard property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#preserveparentrotationforbillboard
func (t *TransformNode) SetPreserveParentRotationForBillboard(preserveParentRotationForBillboard bool) *TransformNode {
	t.p.Set("preserveParentRotationForBillboard", preserveParentRotationForBillboard)
	return t
}

// ReIntegrateRotationIntoRotationQuaternion returns the ReIntegrateRotationIntoRotationQuaternion property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#reintegraterotationintorotationquaternion
func (t *TransformNode) ReIntegrateRotationIntoRotationQuaternion() bool {
	retVal := t.p.Get("reIntegrateRotationIntoRotationQuaternion")
	return retVal.Bool()
}

// SetReIntegrateRotationIntoRotationQuaternion sets the ReIntegrateRotationIntoRotationQuaternion property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#reintegraterotationintorotationquaternion
func (t *TransformNode) SetReIntegrateRotationIntoRotationQuaternion(reIntegrateRotationIntoRotationQuaternion bool) *TransformNode {
	t.p.Set("reIntegrateRotationIntoRotationQuaternion", reIntegrateRotationIntoRotationQuaternion)
	return t
}

// Right returns the Right property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#right
func (t *TransformNode) Right() *Vector3 {
	retVal := t.p.Get("right")
	return Vector3FromJSObject(retVal, t.ctx)
}

// SetRight sets the Right property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#right
func (t *TransformNode) SetRight(right *Vector3) *TransformNode {
	t.p.Set("right", right.JSObject())
	return t
}

// Rotation returns the Rotation property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#rotation
func (t *TransformNode) Rotation() *Vector3 {
	retVal := t.p.Get("rotation")
	return Vector3FromJSObject(retVal, t.ctx)
}

// SetRotation sets the Rotation property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#rotation
func (t *TransformNode) SetRotation(rotation *Vector3) *TransformNode {
	t.p.Set("rotation", rotation.JSObject())
	return t
}

// RotationQuaternion returns the RotationQuaternion property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#rotationquaternion
func (t *TransformNode) RotationQuaternion() *Quaternion {
	retVal := t.p.Get("rotationQuaternion")
	return QuaternionFromJSObject(retVal, t.ctx)
}

// SetRotationQuaternion sets the RotationQuaternion property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#rotationquaternion
func (t *TransformNode) SetRotationQuaternion(rotationQuaternion *Quaternion) *TransformNode {
	t.p.Set("rotationQuaternion", rotationQuaternion.JSObject())
	return t
}

// Scaling returns the Scaling property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#scaling
func (t *TransformNode) Scaling() *Vector3 {
	retVal := t.p.Get("scaling")
	return Vector3FromJSObject(retVal, t.ctx)
}

// SetScaling sets the Scaling property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#scaling
func (t *TransformNode) SetScaling(scaling *Vector3) *TransformNode {
	t.p.Set("scaling", scaling.JSObject())
	return t
}

// ScalingDeterminant returns the ScalingDeterminant property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#scalingdeterminant
func (t *TransformNode) ScalingDeterminant() float64 {
	retVal := t.p.Get("scalingDeterminant")
	return retVal.Float()
}

// SetScalingDeterminant sets the ScalingDeterminant property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#scalingdeterminant
func (t *TransformNode) SetScalingDeterminant(scalingDeterminant float64) *TransformNode {
	t.p.Set("scalingDeterminant", scalingDeterminant)
	return t
}

// Up returns the Up property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#up
func (t *TransformNode) Up() *Vector3 {
	retVal := t.p.Get("up")
	return Vector3FromJSObject(retVal, t.ctx)
}

// SetUp sets the Up property of class TransformNode.
//
// https://doc.babylonjs.com/api/classes/babylon.transformnode#up
func (t *TransformNode) SetUp(up *Vector3) *TransformNode {
	t.p.Set("up", up.JSObject())
	return t
}

// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// OctreeBlock represents a babylon.js OctreeBlock.
// Class used to store a cell in an octree
//
// See: http://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
type OctreeBlock struct {
	p   js.Value
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (o *OctreeBlock) JSObject() js.Value { return o.p }

// OctreeBlock returns a OctreeBlock JavaScript class.
func (ba *Babylon) OctreeBlock() *OctreeBlock {
	p := ba.ctx.Get("OctreeBlock")
	return OctreeBlockFromJSObject(p, ba.ctx)
}

// OctreeBlockFromJSObject returns a wrapped OctreeBlock JavaScript class.
func OctreeBlockFromJSObject(p js.Value, ctx js.Value) *OctreeBlock {
	return &OctreeBlock{p: p, ctx: ctx}
}

// OctreeBlockArrayToJSArray returns a JavaScript Array for the wrapped array.
func OctreeBlockArrayToJSArray(array []*OctreeBlock) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewOctreeBlock returns a new OctreeBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock
func (ba *Babylon) NewOctreeBlock(minPoint *Vector3, maxPoint *Vector3, capacity float64, depth float64, maxDepth float64, creationFunc JSFunc) *OctreeBlock {

	args := make([]interface{}, 0, 6+0)

	args = append(args, minPoint.JSObject())
	args = append(args, maxPoint.JSObject())
	args = append(args, capacity)
	args = append(args, depth)
	args = append(args, maxDepth)
	args = append(args, js.FuncOf(creationFunc))

	p := ba.ctx.Get("OctreeBlock").New(args...)
	return OctreeBlockFromJSObject(p, ba.ctx)
}

// AddEntries calls the AddEntries method on the OctreeBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#addentries
func (o *OctreeBlock) AddEntries(entries []*T) {

	args := make([]interface{}, 0, 1+0)

	args = append(args, TArrayToJSArray(entries))

	o.p.Call("addEntries", args...)
}

// AddEntry calls the AddEntry method on the OctreeBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#addentry
func (o *OctreeBlock) AddEntry(entry *T) {

	args := make([]interface{}, 0, 1+0)

	if entry == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, entry.JSObject())
	}

	o.p.Call("addEntry", args...)
}

// CreateInnerBlocks calls the CreateInnerBlocks method on the OctreeBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#createinnerblocks
func (o *OctreeBlock) CreateInnerBlocks() {

	o.p.Call("createInnerBlocks")
}

// OctreeBlockIntersectsOpts contains optional parameters for OctreeBlock.Intersects.
type OctreeBlockIntersectsOpts struct {
	AllowDuplicate *bool
}

// Intersects calls the Intersects method on the OctreeBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#intersects
func (o *OctreeBlock) Intersects(sphereCenter *Vector3, sphereRadius float64, selection *SmartArrayNoDuplicate, opts *OctreeBlockIntersectsOpts) {
	if opts == nil {
		opts = &OctreeBlockIntersectsOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	if sphereCenter == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, sphereCenter.JSObject())
	}

	args = append(args, sphereRadius)

	if selection == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, selection.JSObject())
	}

	if opts.AllowDuplicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AllowDuplicate)
	}

	o.p.Call("intersects", args...)
}

// IntersectsRay calls the IntersectsRay method on the OctreeBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#intersectsray
func (o *OctreeBlock) IntersectsRay(ray *Ray, selection *SmartArrayNoDuplicate) {

	args := make([]interface{}, 0, 2+0)

	if ray == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, ray.JSObject())
	}

	if selection == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, selection.JSObject())
	}

	o.p.Call("intersectsRay", args...)
}

// RemoveEntry calls the RemoveEntry method on the OctreeBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#removeentry
func (o *OctreeBlock) RemoveEntry(entry *T) {

	args := make([]interface{}, 0, 1+0)

	if entry == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, entry.JSObject())
	}

	o.p.Call("removeEntry", args...)
}

// OctreeBlockSelectOpts contains optional parameters for OctreeBlock.Select.
type OctreeBlockSelectOpts struct {
	AllowDuplicate *bool
}

// Select calls the Select method on the OctreeBlock object.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#select
func (o *OctreeBlock) Select(frustumPlanes []*Plane, selection *SmartArrayNoDuplicate, opts *OctreeBlockSelectOpts) {
	if opts == nil {
		opts = &OctreeBlockSelectOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	args = append(args, PlaneArrayToJSArray(frustumPlanes))

	if selection == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, selection.JSObject())
	}

	if opts.AllowDuplicate == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.AllowDuplicate)
	}

	o.p.Call("select", args...)
}

// Blocks returns the Blocks property of class OctreeBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#blocks
func (o *OctreeBlock) Blocks() []*OctreeBlock {
	retVal := o.p.Get("blocks")
	result := []*OctreeBlock{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, OctreeBlockFromJSObject(retVal.Index(ri), o.ctx))
	}
	return result
}

// SetBlocks sets the Blocks property of class OctreeBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#blocks
func (o *OctreeBlock) SetBlocks(blocks []*OctreeBlock) *OctreeBlock {
	o.p.Set("blocks", blocks)
	return o
}

// Capacity returns the Capacity property of class OctreeBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#capacity
func (o *OctreeBlock) Capacity() float64 {
	retVal := o.p.Get("capacity")
	return retVal.Float()
}

// SetCapacity sets the Capacity property of class OctreeBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#capacity
func (o *OctreeBlock) SetCapacity(capacity float64) *OctreeBlock {
	o.p.Set("capacity", capacity)
	return o
}

// Entries returns the Entries property of class OctreeBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#entries
func (o *OctreeBlock) Entries() []*T {
	retVal := o.p.Get("entries")
	result := []*T{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, TFromJSObject(retVal.Index(ri), o.ctx))
	}
	return result
}

// SetEntries sets the Entries property of class OctreeBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#entries
func (o *OctreeBlock) SetEntries(entries []*T) *OctreeBlock {
	o.p.Set("entries", entries)
	return o
}

// MaxPoint returns the MaxPoint property of class OctreeBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#maxpoint
func (o *OctreeBlock) MaxPoint() *Vector3 {
	retVal := o.p.Get("maxPoint")
	return Vector3FromJSObject(retVal, o.ctx)
}

// SetMaxPoint sets the MaxPoint property of class OctreeBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#maxpoint
func (o *OctreeBlock) SetMaxPoint(maxPoint *Vector3) *OctreeBlock {
	o.p.Set("maxPoint", maxPoint.JSObject())
	return o
}

// MinPoint returns the MinPoint property of class OctreeBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#minpoint
func (o *OctreeBlock) MinPoint() *Vector3 {
	retVal := o.p.Get("minPoint")
	return Vector3FromJSObject(retVal, o.ctx)
}

// SetMinPoint sets the MinPoint property of class OctreeBlock.
//
// https://doc.babylonjs.com/api/classes/babylon.octreeblock#minpoint
func (o *OctreeBlock) SetMinPoint(minPoint *Vector3) *OctreeBlock {
	o.p.Set("minPoint", minPoint.JSObject())
	return o
}

// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// Bone represents a babylon.js Bone.
// Class used to store bone information
//
// See: http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
type Bone struct {
	*Node
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (b *Bone) JSObject() js.Value { return b.p }

// Bone returns a Bone JavaScript class.
func (ba *Babylon) Bone() *Bone {
	p := ba.ctx.Get("Bone")
	return BoneFromJSObject(p, ba.ctx)
}

// BoneFromJSObject returns a wrapped Bone JavaScript class.
func BoneFromJSObject(p js.Value, ctx js.Value) *Bone {
	return &Bone{Node: NodeFromJSObject(p, ctx), ctx: ctx}
}

// BoneArrayToJSArray returns a JavaScript Array for the wrapped array.
func BoneArrayToJSArray(array []*Bone) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewBoneOpts contains optional parameters for NewBone.
type NewBoneOpts struct {
	ParentBone  *Bone
	LocalMatrix *Matrix
	RestPose    *Matrix
	BaseMatrix  *Matrix
	Index       *float64
}

// NewBone returns a new Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#constructor
func (ba *Babylon) NewBone(name string, skeleton *Skeleton, opts *NewBoneOpts) *Bone {
	if opts == nil {
		opts = &NewBoneOpts{}
	}

	args := make([]interface{}, 0, 2+5)

	args = append(args, name)
	args = append(args, skeleton.JSObject())

	if opts.ParentBone == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.ParentBone.JSObject())
	}
	if opts.LocalMatrix == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.LocalMatrix.JSObject())
	}
	if opts.RestPose == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.RestPose.JSObject())
	}
	if opts.BaseMatrix == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.BaseMatrix.JSObject())
	}
	if opts.Index == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.Index)
	}

	p := ba.ctx.Get("Bone").New(args...)
	return BoneFromJSObject(p, ba.ctx)
}

// ComputeAbsoluteTransforms calls the ComputeAbsoluteTransforms method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#computeabsolutetransforms
func (b *Bone) ComputeAbsoluteTransforms() {

	b.p.Call("computeAbsoluteTransforms")
}

// CopyAnimationRange calls the CopyAnimationRange method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#copyanimationrange
func (b *Bone) CopyAnimationRange(source *Bone, rangeName string, frameOffset float64, rescaleAsRequired bool, skelDimensionsRatio *Vector3) bool {

	args := make([]interface{}, 0, 5+0)

	if source == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, source.JSObject())
	}

	args = append(args, rangeName)

	args = append(args, frameOffset)

	args = append(args, rescaleAsRequired)

	if skelDimensionsRatio == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, skelDimensionsRatio.JSObject())
	}

	retVal := b.p.Call("copyAnimationRange", args...)
	return retVal.Bool()
}

// BoneGetAbsolutePositionOpts contains optional parameters for Bone.GetAbsolutePosition.
type BoneGetAbsolutePositionOpts struct {
	Mesh *AbstractMesh
}

// GetAbsolutePosition calls the GetAbsolutePosition method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getabsoluteposition
func (b *Bone) GetAbsolutePosition(opts *BoneGetAbsolutePositionOpts) *Vector3 {
	if opts == nil {
		opts = &BoneGetAbsolutePositionOpts{}
	}

	args := make([]interface{}, 0, 0+1)

	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	retVal := b.p.Call("getAbsolutePosition", args...)
	return Vector3FromJSObject(retVal, b.ctx)
}

// BoneGetAbsolutePositionFromLocalOpts contains optional parameters for Bone.GetAbsolutePositionFromLocal.
type BoneGetAbsolutePositionFromLocalOpts struct {
	Mesh *AbstractMesh
}

// GetAbsolutePositionFromLocal calls the GetAbsolutePositionFromLocal method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getabsolutepositionfromlocal
func (b *Bone) GetAbsolutePositionFromLocal(position *Vector3, opts *BoneGetAbsolutePositionFromLocalOpts) *Vector3 {
	if opts == nil {
		opts = &BoneGetAbsolutePositionFromLocalOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	if position == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, position.JSObject())
	}

	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	retVal := b.p.Call("getAbsolutePositionFromLocal", args...)
	return Vector3FromJSObject(retVal, b.ctx)
}

// GetAbsolutePositionFromLocalToRef calls the GetAbsolutePositionFromLocalToRef method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getabsolutepositionfromlocaltoref
func (b *Bone) GetAbsolutePositionFromLocalToRef(position *Vector3, mesh *AbstractMesh, result *Vector3) {

	args := make([]interface{}, 0, 3+0)

	if position == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, position.JSObject())
	}

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if result == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, result.JSObject())
	}

	b.p.Call("getAbsolutePositionFromLocalToRef", args...)
}

// GetAbsolutePositionToRef calls the GetAbsolutePositionToRef method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getabsolutepositiontoref
func (b *Bone) GetAbsolutePositionToRef(mesh *AbstractMesh, result *Vector3) {

	args := make([]interface{}, 0, 2+0)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if result == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, result.JSObject())
	}

	b.p.Call("getAbsolutePositionToRef", args...)
}

// GetAbsoluteTransform calls the GetAbsoluteTransform method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getabsolutetransform
func (b *Bone) GetAbsoluteTransform() *Matrix {

	retVal := b.p.Call("getAbsoluteTransform")
	return MatrixFromJSObject(retVal, b.ctx)
}

// GetBaseMatrix calls the GetBaseMatrix method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getbasematrix
func (b *Bone) GetBaseMatrix() *Matrix {

	retVal := b.p.Call("getBaseMatrix")
	return MatrixFromJSObject(retVal, b.ctx)
}

// GetChildren calls the GetChildren method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getchildren
func (b *Bone) GetChildren() []*Bone {

	retVal := b.p.Call("getChildren")
	result := []*Bone{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, BoneFromJSObject(retVal.Index(ri), b.ctx))
	}
	return result
}

// GetClassName calls the GetClassName method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getclassname
func (b *Bone) GetClassName() string {

	retVal := b.p.Call("getClassName")
	return retVal.String()
}

// BoneGetDirectionOpts contains optional parameters for Bone.GetDirection.
type BoneGetDirectionOpts struct {
	Mesh *AbstractMesh
}

// GetDirection calls the GetDirection method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getdirection
func (b *Bone) GetDirection(localAxis *Vector3, opts *BoneGetDirectionOpts) *Vector3 {
	if opts == nil {
		opts = &BoneGetDirectionOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	if localAxis == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, localAxis.JSObject())
	}

	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	retVal := b.p.Call("getDirection", args...)
	return Vector3FromJSObject(retVal, b.ctx)
}

// GetDirectionToRef calls the GetDirectionToRef method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getdirectiontoref
func (b *Bone) GetDirectionToRef(localAxis *Vector3, mesh *AbstractMesh, result *Vector3) {

	args := make([]interface{}, 0, 3+0)

	if localAxis == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, localAxis.JSObject())
	}

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if result == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, result.JSObject())
	}

	b.p.Call("getDirectionToRef", args...)
}

// GetIndex calls the GetIndex method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getindex
func (b *Bone) GetIndex() float64 {

	retVal := b.p.Call("getIndex")
	return retVal.Float()
}

// GetInvertedAbsoluteTransform calls the GetInvertedAbsoluteTransform method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getinvertedabsolutetransform
func (b *Bone) GetInvertedAbsoluteTransform() *Matrix {

	retVal := b.p.Call("getInvertedAbsoluteTransform")
	return MatrixFromJSObject(retVal, b.ctx)
}

// GetLocalMatrix calls the GetLocalMatrix method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getlocalmatrix
func (b *Bone) GetLocalMatrix() *Matrix {

	retVal := b.p.Call("getLocalMatrix")
	return MatrixFromJSObject(retVal, b.ctx)
}

// BoneGetLocalPositionFromAbsoluteOpts contains optional parameters for Bone.GetLocalPositionFromAbsolute.
type BoneGetLocalPositionFromAbsoluteOpts struct {
	Mesh *AbstractMesh
}

// GetLocalPositionFromAbsolute calls the GetLocalPositionFromAbsolute method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getlocalpositionfromabsolute
func (b *Bone) GetLocalPositionFromAbsolute(position *Vector3, opts *BoneGetLocalPositionFromAbsoluteOpts) *Vector3 {
	if opts == nil {
		opts = &BoneGetLocalPositionFromAbsoluteOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	if position == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, position.JSObject())
	}

	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	retVal := b.p.Call("getLocalPositionFromAbsolute", args...)
	return Vector3FromJSObject(retVal, b.ctx)
}

// GetLocalPositionFromAbsoluteToRef calls the GetLocalPositionFromAbsoluteToRef method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getlocalpositionfromabsolutetoref
func (b *Bone) GetLocalPositionFromAbsoluteToRef(position *Vector3, mesh *AbstractMesh, result *Vector3) {

	args := make([]interface{}, 0, 3+0)

	if position == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, position.JSObject())
	}

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if result == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, result.JSObject())
	}

	b.p.Call("getLocalPositionFromAbsoluteToRef", args...)
}

// GetParent calls the GetParent method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getparent
func (b *Bone) GetParent() *Bone {

	retVal := b.p.Call("getParent")
	return BoneFromJSObject(retVal, b.ctx)
}

// BoneGetPositionOpts contains optional parameters for Bone.GetPosition.
type BoneGetPositionOpts struct {
	Space js.Value
	Mesh  *AbstractMesh
}

// GetPosition calls the GetPosition method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getposition
func (b *Bone) GetPosition(opts *BoneGetPositionOpts) *Vector3 {
	if opts == nil {
		opts = &BoneGetPositionOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	args = append(args, opts.Space)
	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	retVal := b.p.Call("getPosition", args...)
	return Vector3FromJSObject(retVal, b.ctx)
}

// GetPositionToRef calls the GetPositionToRef method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getpositiontoref
func (b *Bone) GetPositionToRef(space js.Value, mesh *AbstractMesh, result *Vector3) {

	args := make([]interface{}, 0, 3+0)

	args = append(args, space)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if result == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, result.JSObject())
	}

	b.p.Call("getPositionToRef", args...)
}

// GetRestPose calls the GetRestPose method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getrestpose
func (b *Bone) GetRestPose() *Matrix {

	retVal := b.p.Call("getRestPose")
	return MatrixFromJSObject(retVal, b.ctx)
}

// BoneGetRotationOpts contains optional parameters for Bone.GetRotation.
type BoneGetRotationOpts struct {
	Space js.Value
	Mesh  *AbstractMesh
}

// GetRotation calls the GetRotation method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getrotation
func (b *Bone) GetRotation(opts *BoneGetRotationOpts) *Vector3 {
	if opts == nil {
		opts = &BoneGetRotationOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	args = append(args, opts.Space)
	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	retVal := b.p.Call("getRotation", args...)
	return Vector3FromJSObject(retVal, b.ctx)
}

// GetRotationMatrix calls the GetRotationMatrix method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getrotationmatrix
func (b *Bone) GetRotationMatrix(space js.Value, mesh *AbstractMesh) *Matrix {

	args := make([]interface{}, 0, 2+0)

	args = append(args, space)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	retVal := b.p.Call("getRotationMatrix", args...)
	return MatrixFromJSObject(retVal, b.ctx)
}

// GetRotationMatrixToRef calls the GetRotationMatrixToRef method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getrotationmatrixtoref
func (b *Bone) GetRotationMatrixToRef(space js.Value, mesh *AbstractMesh, result *Matrix) {

	args := make([]interface{}, 0, 3+0)

	args = append(args, space)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if result == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, result.JSObject())
	}

	b.p.Call("getRotationMatrixToRef", args...)
}

// BoneGetRotationQuaternionOpts contains optional parameters for Bone.GetRotationQuaternion.
type BoneGetRotationQuaternionOpts struct {
	Space js.Value
	Mesh  *AbstractMesh
}

// GetRotationQuaternion calls the GetRotationQuaternion method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getrotationquaternion
func (b *Bone) GetRotationQuaternion(opts *BoneGetRotationQuaternionOpts) *Quaternion {
	if opts == nil {
		opts = &BoneGetRotationQuaternionOpts{}
	}

	args := make([]interface{}, 0, 0+2)

	args = append(args, opts.Space)
	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	retVal := b.p.Call("getRotationQuaternion", args...)
	return QuaternionFromJSObject(retVal, b.ctx)
}

// GetRotationQuaternionToRef calls the GetRotationQuaternionToRef method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getrotationquaterniontoref
func (b *Bone) GetRotationQuaternionToRef(space js.Value, mesh *AbstractMesh, result *Quaternion) {

	args := make([]interface{}, 0, 3+0)

	args = append(args, space)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if result == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, result.JSObject())
	}

	b.p.Call("getRotationQuaternionToRef", args...)
}

// GetRotationToRef calls the GetRotationToRef method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getrotationtoref
func (b *Bone) GetRotationToRef(space js.Value, mesh *AbstractMesh, result *Vector3) {

	args := make([]interface{}, 0, 3+0)

	args = append(args, space)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if result == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, result.JSObject())
	}

	b.p.Call("getRotationToRef", args...)
}

// GetScale calls the GetScale method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getscale
func (b *Bone) GetScale() *Vector3 {

	retVal := b.p.Call("getScale")
	return Vector3FromJSObject(retVal, b.ctx)
}

// GetScaleToRef calls the GetScaleToRef method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getscaletoref
func (b *Bone) GetScaleToRef(result *Vector3) {

	args := make([]interface{}, 0, 1+0)

	if result == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, result.JSObject())
	}

	b.p.Call("getScaleToRef", args...)
}

// GetSkeleton calls the GetSkeleton method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getskeleton
func (b *Bone) GetSkeleton() *Skeleton {

	retVal := b.p.Call("getSkeleton")
	return SkeletonFromJSObject(retVal, b.ctx)
}

// GetTransformNode calls the GetTransformNode method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#gettransformnode
func (b *Bone) GetTransformNode() *TransformNode {

	retVal := b.p.Call("getTransformNode")
	return TransformNodeFromJSObject(retVal, b.ctx)
}

// GetWorldMatrix calls the GetWorldMatrix method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#getworldmatrix
func (b *Bone) GetWorldMatrix() *Matrix {

	retVal := b.p.Call("getWorldMatrix")
	return MatrixFromJSObject(retVal, b.ctx)
}

// LinkTransformNode calls the LinkTransformNode method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#linktransformnode
func (b *Bone) LinkTransformNode(transformNode *TransformNode) {

	args := make([]interface{}, 0, 1+0)

	if transformNode == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, transformNode.JSObject())
	}

	b.p.Call("linkTransformNode", args...)
}

// MarkAsDirty calls the MarkAsDirty method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#markasdirty
func (b *Bone) MarkAsDirty() {

	b.p.Call("markAsDirty")
}

// ReturnToRest calls the ReturnToRest method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#returntorest
func (b *Bone) ReturnToRest() {

	b.p.Call("returnToRest")
}

// BoneRotateOpts contains optional parameters for Bone.Rotate.
type BoneRotateOpts struct {
	Space js.Value
	Mesh  *AbstractMesh
}

// Rotate calls the Rotate method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#rotate
func (b *Bone) Rotate(axis *Vector3, amount float64, opts *BoneRotateOpts) {
	if opts == nil {
		opts = &BoneRotateOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	if axis == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, axis.JSObject())
	}

	args = append(args, amount)

	args = append(args, opts.Space)
	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	b.p.Call("rotate", args...)
}

// BoneScaleOpts contains optional parameters for Bone.Scale.
type BoneScaleOpts struct {
	ScaleChildren *bool
}

// Scale calls the Scale method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#scale
func (b *Bone) Scale(x float64, y float64, z float64, opts *BoneScaleOpts) {
	if opts == nil {
		opts = &BoneScaleOpts{}
	}

	args := make([]interface{}, 0, 3+1)

	args = append(args, x)

	args = append(args, y)

	args = append(args, z)

	if opts.ScaleChildren == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.ScaleChildren)
	}

	b.p.Call("scale", args...)
}

// BoneSetAbsolutePositionOpts contains optional parameters for Bone.SetAbsolutePosition.
type BoneSetAbsolutePositionOpts struct {
	Mesh *AbstractMesh
}

// SetAbsolutePosition calls the SetAbsolutePosition method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#setabsoluteposition
func (b *Bone) SetAbsolutePosition(position *Vector3, opts *BoneSetAbsolutePositionOpts) {
	if opts == nil {
		opts = &BoneSetAbsolutePositionOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	if position == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, position.JSObject())
	}

	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	b.p.Call("setAbsolutePosition", args...)
}

// BoneSetAxisAngleOpts contains optional parameters for Bone.SetAxisAngle.
type BoneSetAxisAngleOpts struct {
	Space js.Value
	Mesh  *AbstractMesh
}

// SetAxisAngle calls the SetAxisAngle method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#setaxisangle
func (b *Bone) SetAxisAngle(axis *Vector3, angle float64, opts *BoneSetAxisAngleOpts) {
	if opts == nil {
		opts = &BoneSetAxisAngleOpts{}
	}

	args := make([]interface{}, 0, 2+2)

	if axis == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, axis.JSObject())
	}

	args = append(args, angle)

	args = append(args, opts.Space)
	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	b.p.Call("setAxisAngle", args...)
}

// BoneSetParentOpts contains optional parameters for Bone.SetParent.
type BoneSetParentOpts struct {
	UpdateDifferenceMatrix *bool
}

// SetParent calls the SetParent method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#setparent
func (b *Bone) SetParent(parent *Bone, opts *BoneSetParentOpts) {
	if opts == nil {
		opts = &BoneSetParentOpts{}
	}

	args := make([]interface{}, 0, 1+1)

	if parent == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, parent.JSObject())
	}

	if opts.UpdateDifferenceMatrix == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UpdateDifferenceMatrix)
	}

	b.p.Call("setParent", args...)
}

// BoneSetPositionOpts contains optional parameters for Bone.SetPosition.
type BoneSetPositionOpts struct {
	Space js.Value
	Mesh  *AbstractMesh
}

// SetPosition calls the SetPosition method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#setposition
func (b *Bone) SetPosition(position *Vector3, opts *BoneSetPositionOpts) {
	if opts == nil {
		opts = &BoneSetPositionOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	if position == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, position.JSObject())
	}

	args = append(args, opts.Space)
	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	b.p.Call("setPosition", args...)
}

// BoneSetRotationOpts contains optional parameters for Bone.SetRotation.
type BoneSetRotationOpts struct {
	Space js.Value
	Mesh  *AbstractMesh
}

// SetRotation calls the SetRotation method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#setrotation
func (b *Bone) SetRotation(rotation *Vector3, opts *BoneSetRotationOpts) {
	if opts == nil {
		opts = &BoneSetRotationOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	if rotation == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, rotation.JSObject())
	}

	args = append(args, opts.Space)
	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	b.p.Call("setRotation", args...)
}

// BoneSetRotationMatrixOpts contains optional parameters for Bone.SetRotationMatrix.
type BoneSetRotationMatrixOpts struct {
	Space js.Value
	Mesh  *AbstractMesh
}

// SetRotationMatrix calls the SetRotationMatrix method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#setrotationmatrix
func (b *Bone) SetRotationMatrix(rotMat *Matrix, opts *BoneSetRotationMatrixOpts) {
	if opts == nil {
		opts = &BoneSetRotationMatrixOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	if rotMat == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, rotMat.JSObject())
	}

	args = append(args, opts.Space)
	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	b.p.Call("setRotationMatrix", args...)
}

// BoneSetRotationQuaternionOpts contains optional parameters for Bone.SetRotationQuaternion.
type BoneSetRotationQuaternionOpts struct {
	Space js.Value
	Mesh  *AbstractMesh
}

// SetRotationQuaternion calls the SetRotationQuaternion method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#setrotationquaternion
func (b *Bone) SetRotationQuaternion(quat *Quaternion, opts *BoneSetRotationQuaternionOpts) {
	if opts == nil {
		opts = &BoneSetRotationQuaternionOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	if quat == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, quat.JSObject())
	}

	args = append(args, opts.Space)
	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	b.p.Call("setRotationQuaternion", args...)
}

// SetScale calls the SetScale method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#setscale
func (b *Bone) SetScale(scale *Vector3) {

	args := make([]interface{}, 0, 1+0)

	if scale == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, scale.JSObject())
	}

	b.p.Call("setScale", args...)
}

// BoneSetYawPitchRollOpts contains optional parameters for Bone.SetYawPitchRoll.
type BoneSetYawPitchRollOpts struct {
	Space js.Value
	Mesh  *AbstractMesh
}

// SetYawPitchRoll calls the SetYawPitchRoll method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#setyawpitchroll
func (b *Bone) SetYawPitchRoll(yaw float64, pitch float64, roll float64, opts *BoneSetYawPitchRollOpts) {
	if opts == nil {
		opts = &BoneSetYawPitchRollOpts{}
	}

	args := make([]interface{}, 0, 3+2)

	args = append(args, yaw)

	args = append(args, pitch)

	args = append(args, roll)

	args = append(args, opts.Space)
	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	b.p.Call("setYawPitchRoll", args...)
}

// BoneTranslateOpts contains optional parameters for Bone.Translate.
type BoneTranslateOpts struct {
	Space js.Value
	Mesh  *AbstractMesh
}

// Translate calls the Translate method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#translate
func (b *Bone) Translate(vec *Vector3, opts *BoneTranslateOpts) {
	if opts == nil {
		opts = &BoneTranslateOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	if vec == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, vec.JSObject())
	}

	args = append(args, opts.Space)
	if opts.Mesh == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, opts.Mesh.JSObject())
	}

	b.p.Call("translate", args...)
}

// BoneUpdateMatrixOpts contains optional parameters for Bone.UpdateMatrix.
type BoneUpdateMatrixOpts struct {
	UpdateDifferenceMatrix *bool
	UpdateLocalMatrix      *bool
}

// UpdateMatrix calls the UpdateMatrix method on the Bone object.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#updatematrix
func (b *Bone) UpdateMatrix(matrix *Matrix, opts *BoneUpdateMatrixOpts) {
	if opts == nil {
		opts = &BoneUpdateMatrixOpts{}
	}

	args := make([]interface{}, 0, 1+2)

	if matrix == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, matrix.JSObject())
	}

	if opts.UpdateDifferenceMatrix == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UpdateDifferenceMatrix)
	}
	if opts.UpdateLocalMatrix == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UpdateLocalMatrix)
	}

	b.p.Call("updateMatrix", args...)
}

// AnimationPropertiesOverride returns the AnimationPropertiesOverride property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#animationpropertiesoverride
func (b *Bone) AnimationPropertiesOverride() *AnimationPropertiesOverride {
	retVal := b.p.Get("animationPropertiesOverride")
	return AnimationPropertiesOverrideFromJSObject(retVal, b.ctx)
}

// SetAnimationPropertiesOverride sets the AnimationPropertiesOverride property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#animationpropertiesoverride
func (b *Bone) SetAnimationPropertiesOverride(animationPropertiesOverride *AnimationPropertiesOverride) *Bone {
	b.p.Set("animationPropertiesOverride", animationPropertiesOverride.JSObject())
	return b
}

// Animations returns the Animations property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#animations
func (b *Bone) Animations() []*Animation {
	retVal := b.p.Get("animations")
	result := []*Animation{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, AnimationFromJSObject(retVal.Index(ri), b.ctx))
	}
	return result
}

// SetAnimations sets the Animations property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#animations
func (b *Bone) SetAnimations(animations []*Animation) *Bone {
	b.p.Set("animations", animations)
	return b
}

// Children returns the Children property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#children
func (b *Bone) Children() []*Bone {
	retVal := b.p.Get("children")
	result := []*Bone{}
	for ri := 0; ri < retVal.Length(); ri++ {
		result = append(result, BoneFromJSObject(retVal.Index(ri), b.ctx))
	}
	return result
}

// SetChildren sets the Children property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#children
func (b *Bone) SetChildren(children []*Bone) *Bone {
	b.p.Set("children", children)
	return b
}

// Length returns the Length property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#length
func (b *Bone) Length() float64 {
	retVal := b.p.Get("length")
	return retVal.Float()
}

// SetLength sets the Length property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#length
func (b *Bone) SetLength(length float64) *Bone {
	b.p.Set("length", length)
	return b
}

// Name returns the Name property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#name
func (b *Bone) Name() string {
	retVal := b.p.Get("name")
	return retVal.String()
}

// SetName sets the Name property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#name
func (b *Bone) SetName(name string) *Bone {
	b.p.Set("name", name)
	return b
}

// Position returns the Position property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#position
func (b *Bone) Position() *Vector3 {
	retVal := b.p.Get("position")
	return Vector3FromJSObject(retVal, b.ctx)
}

// Rotation returns the Rotation property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#rotation
func (b *Bone) Rotation() *Vector3 {
	retVal := b.p.Get("rotation")
	return Vector3FromJSObject(retVal, b.ctx)
}

// RotationQuaternion returns the RotationQuaternion property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#rotationquaternion
func (b *Bone) RotationQuaternion() *Quaternion {
	retVal := b.p.Get("rotationQuaternion")
	return QuaternionFromJSObject(retVal, b.ctx)
}

// Scaling returns the Scaling property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#scaling
func (b *Bone) Scaling() *Vector3 {
	retVal := b.p.Get("scaling")
	return Vector3FromJSObject(retVal, b.ctx)
}

// SetScaling sets the Scaling property of class Bone.
//
// https://doc.babylonjs.com/api/classes/babylon.bone#scaling
func (b *Bone) SetScaling(scaling *Vector3) *Bone {
	b.p.Set("scaling", scaling.JSObject())
	return b
}

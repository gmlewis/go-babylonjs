// Code generated by docs2go. DO NOT EDIT.

package babylon

import (
	"syscall/js"
)

// ShadowOnlyMaterial represents a babylon.js ShadowOnlyMaterial.
//
type ShadowOnlyMaterial struct {
	p   js.Value
	ctx js.Value
}

// JSObject returns the underlying js.Value.
func (s *ShadowOnlyMaterial) JSObject() js.Value { return s.p }

// ShadowOnlyMaterial returns a ShadowOnlyMaterial JavaScript class.
func (ba *Babylon) ShadowOnlyMaterial() *ShadowOnlyMaterial {
	p := ba.ctx.Get("ShadowOnlyMaterial")
	return ShadowOnlyMaterialFromJSObject(p, ba.ctx)
}

// ShadowOnlyMaterialFromJSObject returns a wrapped ShadowOnlyMaterial JavaScript class.
func ShadowOnlyMaterialFromJSObject(p js.Value, ctx js.Value) *ShadowOnlyMaterial {
	return &ShadowOnlyMaterial{p: p, ctx: ctx}
}

// ShadowOnlyMaterialArrayToJSArray returns a JavaScript Array for the wrapped array.
func ShadowOnlyMaterialArrayToJSArray(array []*ShadowOnlyMaterial) []interface{} {
	var result []interface{}
	for _, v := range array {
		result = append(result, v.JSObject())
	}
	return result
}

// NewShadowOnlyMaterial returns a new ShadowOnlyMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowonlymaterial
func (ba *Babylon) NewShadowOnlyMaterial(name string, scene *Scene) *ShadowOnlyMaterial {

	args := make([]interface{}, 0, 2+0)

	args = append(args, name)
	args = append(args, scene.JSObject())

	p := ba.ctx.Get("ShadowOnlyMaterial").New(args...)
	return ShadowOnlyMaterialFromJSObject(p, ba.ctx)
}

// BindForSubMesh calls the BindForSubMesh method on the ShadowOnlyMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowonlymaterial#bindforsubmesh
func (s *ShadowOnlyMaterial) BindForSubMesh(world *Matrix, mesh *Mesh, subMesh *SubMesh) {

	args := make([]interface{}, 0, 3+0)

	if world == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, world.JSObject())
	}

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if subMesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, subMesh.JSObject())
	}

	s.p.Call("bindForSubMesh", args...)
}

// Clone calls the Clone method on the ShadowOnlyMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowonlymaterial#clone
func (s *ShadowOnlyMaterial) Clone(name string) *ShadowOnlyMaterial {

	args := make([]interface{}, 0, 1+0)

	args = append(args, name)

	retVal := s.p.Call("clone", args...)
	return ShadowOnlyMaterialFromJSObject(retVal, s.ctx)
}

// GetAlphaTestTexture calls the GetAlphaTestTexture method on the ShadowOnlyMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowonlymaterial#getalphatesttexture
func (s *ShadowOnlyMaterial) GetAlphaTestTexture() *BaseTexture {

	retVal := s.p.Call("getAlphaTestTexture")
	return BaseTextureFromJSObject(retVal, s.ctx)
}

// GetClassName calls the GetClassName method on the ShadowOnlyMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowonlymaterial#getclassname
func (s *ShadowOnlyMaterial) GetClassName() string {

	retVal := s.p.Call("getClassName")
	return retVal.String()
}

// ShadowOnlyMaterialIsReadyForSubMeshOpts contains optional parameters for ShadowOnlyMaterial.IsReadyForSubMesh.
type ShadowOnlyMaterialIsReadyForSubMeshOpts struct {
	UseInstances *bool
}

// IsReadyForSubMesh calls the IsReadyForSubMesh method on the ShadowOnlyMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowonlymaterial#isreadyforsubmesh
func (s *ShadowOnlyMaterial) IsReadyForSubMesh(mesh *AbstractMesh, subMesh *SubMesh, opts *ShadowOnlyMaterialIsReadyForSubMeshOpts) bool {
	if opts == nil {
		opts = &ShadowOnlyMaterialIsReadyForSubMeshOpts{}
	}

	args := make([]interface{}, 0, 2+1)

	if mesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, mesh.JSObject())
	}

	if subMesh == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, subMesh.JSObject())
	}

	if opts.UseInstances == nil {
		args = append(args, js.Undefined())
	} else {
		args = append(args, *opts.UseInstances)
	}

	retVal := s.p.Call("isReadyForSubMesh", args...)
	return retVal.Bool()
}

// NeedAlphaBlending calls the NeedAlphaBlending method on the ShadowOnlyMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowonlymaterial#needalphablending
func (s *ShadowOnlyMaterial) NeedAlphaBlending() bool {

	retVal := s.p.Call("needAlphaBlending")
	return retVal.Bool()
}

// NeedAlphaTesting calls the NeedAlphaTesting method on the ShadowOnlyMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowonlymaterial#needalphatesting
func (s *ShadowOnlyMaterial) NeedAlphaTesting() bool {

	retVal := s.p.Call("needAlphaTesting")
	return retVal.Bool()
}

// Parse calls the Parse method on the ShadowOnlyMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowonlymaterial#parse
func (s *ShadowOnlyMaterial) Parse(source JSObject, scene *Scene, rootUrl string) *ShadowOnlyMaterial {

	args := make([]interface{}, 0, 3+0)

	if source == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, source.JSObject())
	}

	if scene == nil {
		args = append(args, js.Null())
	} else {
		args = append(args, scene.JSObject())
	}

	args = append(args, rootUrl)

	retVal := s.p.Call("Parse", args...)
	return ShadowOnlyMaterialFromJSObject(retVal, s.ctx)
}

// Serialize calls the Serialize method on the ShadowOnlyMaterial object.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowonlymaterial#serialize
func (s *ShadowOnlyMaterial) Serialize() js.Value {

	retVal := s.p.Call("serialize")
	return retVal
}

// ActiveLight returns the ActiveLight property of class ShadowOnlyMaterial.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowonlymaterial#activelight
func (s *ShadowOnlyMaterial) ActiveLight() *IShadowLight {
	retVal := s.p.Get("activeLight")
	return IShadowLightFromJSObject(retVal, s.ctx)
}

// SetActiveLight sets the ActiveLight property of class ShadowOnlyMaterial.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowonlymaterial#activelight
func (s *ShadowOnlyMaterial) SetActiveLight(activeLight *IShadowLight) *ShadowOnlyMaterial {
	s.p.Set("activeLight", activeLight.JSObject())
	return s
}

// ShadowColor returns the ShadowColor property of class ShadowOnlyMaterial.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowonlymaterial#shadowcolor
func (s *ShadowOnlyMaterial) ShadowColor() *Color3 {
	retVal := s.p.Get("shadowColor")
	return Color3FromJSObject(retVal, s.ctx)
}

// SetShadowColor sets the ShadowColor property of class ShadowOnlyMaterial.
//
// https://doc.babylonjs.com/api/classes/babylon.shadowonlymaterial#shadowcolor
func (s *ShadowOnlyMaterial) SetShadowColor(shadowColor *Color3) *ShadowOnlyMaterial {
	s.p.Set("shadowColor", shadowColor.JSObject())
	return s
}
